// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: rental_agreement.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const activateAgreement = `-- name: ActivateAgreement :one
UPDATE rental_agreements 
SET status = 'active', updated_at = NOW()
WHERE id = $1 AND tenant_signed_at IS NOT NULL AND landlord_signed_at IS NOT NULL
RETURNING id, application_id, property_id, tenant_id, landlord_id, agreement_document_url, lease_start_date, lease_end_date, monthly_rent, security_deposit, total_upfront_payment, payment_schedule, terms_and_conditions, status, tenant_signed_at, landlord_signed_at, created_at, updated_at
`

// Activate agreement
func (q *Queries) ActivateAgreement(ctx context.Context, id int64) (RentalAgreement, error) {
	row := q.db.QueryRow(ctx, activateAgreement, id)
	var i RentalAgreement
	err := row.Scan(
		&i.ID,
		&i.ApplicationID,
		&i.PropertyID,
		&i.TenantID,
		&i.LandlordID,
		&i.AgreementDocumentUrl,
		&i.LeaseStartDate,
		&i.LeaseEndDate,
		&i.MonthlyRent,
		&i.SecurityDeposit,
		&i.TotalUpfrontPayment,
		&i.PaymentSchedule,
		&i.TermsAndConditions,
		&i.Status,
		&i.TenantSignedAt,
		&i.LandlordSignedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const completeAgreement = `-- name: CompleteAgreement :one
UPDATE rental_agreements 
SET status = 'completed', updated_at = NOW()
WHERE id = $1 
RETURNING id, application_id, property_id, tenant_id, landlord_id, agreement_document_url, lease_start_date, lease_end_date, monthly_rent, security_deposit, total_upfront_payment, payment_schedule, terms_and_conditions, status, tenant_signed_at, landlord_signed_at, created_at, updated_at
`

// Complete agreement
func (q *Queries) CompleteAgreement(ctx context.Context, id int64) (RentalAgreement, error) {
	row := q.db.QueryRow(ctx, completeAgreement, id)
	var i RentalAgreement
	err := row.Scan(
		&i.ID,
		&i.ApplicationID,
		&i.PropertyID,
		&i.TenantID,
		&i.LandlordID,
		&i.AgreementDocumentUrl,
		&i.LeaseStartDate,
		&i.LeaseEndDate,
		&i.MonthlyRent,
		&i.SecurityDeposit,
		&i.TotalUpfrontPayment,
		&i.PaymentSchedule,
		&i.TermsAndConditions,
		&i.Status,
		&i.TenantSignedAt,
		&i.LandlordSignedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const countLandlordRentalAgreements = `-- name: CountLandlordRentalAgreements :one
SELECT COUNT(*) FROM rental_agreements 
WHERE landlord_id = $1
`

// Count landlord's rental agreements
func (q *Queries) CountLandlordRentalAgreements(ctx context.Context, landlordID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countLandlordRentalAgreements, landlordID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countRentalAgreementsByStatus = `-- name: CountRentalAgreementsByStatus :one
SELECT COUNT(*) FROM rental_agreements 
WHERE status = $1
`

// Count rental agreements by status
func (q *Queries) CountRentalAgreementsByStatus(ctx context.Context, status NullAgreementStatusEnum) (int64, error) {
	row := q.db.QueryRow(ctx, countRentalAgreementsByStatus, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countTenantRentalAgreements = `-- name: CountTenantRentalAgreements :one
SELECT COUNT(*) FROM rental_agreements 
WHERE tenant_id = $1
`

// Count tenant's rental agreements
func (q *Queries) CountTenantRentalAgreements(ctx context.Context, tenantID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countTenantRentalAgreements, tenantID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createRentalAgreement = `-- name: CreateRentalAgreement :one
INSERT INTO rental_agreements (
  application_id, property_id, tenant_id, landlord_id, lease_start_date,
  lease_end_date, monthly_rent, security_deposit, total_upfront_payment,
  payment_schedule, terms_and_conditions
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
) RETURNING id, application_id, property_id, tenant_id, landlord_id, agreement_document_url, lease_start_date, lease_end_date, monthly_rent, security_deposit, total_upfront_payment, payment_schedule, terms_and_conditions, status, tenant_signed_at, landlord_signed_at, created_at, updated_at
`

type CreateRentalAgreementParams struct {
	ApplicationID       int64          `json:"application_id"`
	PropertyID          int64          `json:"property_id"`
	TenantID            int64          `json:"tenant_id"`
	LandlordID          int64          `json:"landlord_id"`
	LeaseStartDate      pgtype.Date    `json:"lease_start_date"`
	LeaseEndDate        pgtype.Date    `json:"lease_end_date"`
	MonthlyRent         pgtype.Numeric `json:"monthly_rent"`
	SecurityDeposit     pgtype.Numeric `json:"security_deposit"`
	TotalUpfrontPayment pgtype.Numeric `json:"total_upfront_payment"`
	PaymentSchedule     pgtype.Text    `json:"payment_schedule"`
	TermsAndConditions  pgtype.Text    `json:"terms_and_conditions"`
}

// Create rental agreement
func (q *Queries) CreateRentalAgreement(ctx context.Context, arg CreateRentalAgreementParams) (RentalAgreement, error) {
	row := q.db.QueryRow(ctx, createRentalAgreement,
		arg.ApplicationID,
		arg.PropertyID,
		arg.TenantID,
		arg.LandlordID,
		arg.LeaseStartDate,
		arg.LeaseEndDate,
		arg.MonthlyRent,
		arg.SecurityDeposit,
		arg.TotalUpfrontPayment,
		arg.PaymentSchedule,
		arg.TermsAndConditions,
	)
	var i RentalAgreement
	err := row.Scan(
		&i.ID,
		&i.ApplicationID,
		&i.PropertyID,
		&i.TenantID,
		&i.LandlordID,
		&i.AgreementDocumentUrl,
		&i.LeaseStartDate,
		&i.LeaseEndDate,
		&i.MonthlyRent,
		&i.SecurityDeposit,
		&i.TotalUpfrontPayment,
		&i.PaymentSchedule,
		&i.TermsAndConditions,
		&i.Status,
		&i.TenantSignedAt,
		&i.LandlordSignedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteRentalAgreement = `-- name: DeleteRentalAgreement :exec
DELETE FROM rental_agreements 
WHERE id = $1
`

// Delete rental agreement
func (q *Queries) DeleteRentalAgreement(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteRentalAgreement, id)
	return err
}

const getActiveLandlordAgreements = `-- name: GetActiveLandlordAgreements :many
SELECT ra.id, ra.application_id, ra.property_id, ra.tenant_id, ra.landlord_id, ra.agreement_document_url, ra.lease_start_date, ra.lease_end_date, ra.monthly_rent, ra.security_deposit, ra.total_upfront_payment, ra.payment_schedule, ra.terms_and_conditions, ra.status, ra.tenant_signed_at, ra.landlord_signed_at, ra.created_at, ra.updated_at, p.title as property_title,
       t.first_name as tenant_first_name, t.last_name as tenant_last_name
FROM rental_agreements ra
JOIN properties p ON ra.property_id = p.id
JOIN users t ON ra.tenant_id = t.id
WHERE ra.landlord_id = $1 AND ra.status = 'active'
ORDER BY ra.lease_end_date ASC
LIMIT $2 OFFSET $3
`

type GetActiveLandlordAgreementsParams struct {
	LandlordID int64 `json:"landlord_id"`
	Limit      int32 `json:"limit"`
	Offset     int32 `json:"offset"`
}

type GetActiveLandlordAgreementsRow struct {
	ID                   int64                   `json:"id"`
	ApplicationID        int64                   `json:"application_id"`
	PropertyID           int64                   `json:"property_id"`
	TenantID             int64                   `json:"tenant_id"`
	LandlordID           int64                   `json:"landlord_id"`
	AgreementDocumentUrl pgtype.Text             `json:"agreement_document_url"`
	LeaseStartDate       pgtype.Date             `json:"lease_start_date"`
	LeaseEndDate         pgtype.Date             `json:"lease_end_date"`
	MonthlyRent          pgtype.Numeric          `json:"monthly_rent"`
	SecurityDeposit      pgtype.Numeric          `json:"security_deposit"`
	TotalUpfrontPayment  pgtype.Numeric          `json:"total_upfront_payment"`
	PaymentSchedule      pgtype.Text             `json:"payment_schedule"`
	TermsAndConditions   pgtype.Text             `json:"terms_and_conditions"`
	Status               NullAgreementStatusEnum `json:"status"`
	TenantSignedAt       pgtype.Timestamptz      `json:"tenant_signed_at"`
	LandlordSignedAt     pgtype.Timestamptz      `json:"landlord_signed_at"`
	CreatedAt            pgtype.Timestamptz      `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz      `json:"updated_at"`
	PropertyTitle        string                  `json:"property_title"`
	TenantFirstName      string                  `json:"tenant_first_name"`
	TenantLastName       string                  `json:"tenant_last_name"`
}

// Get active agreements for landlord
func (q *Queries) GetActiveLandlordAgreements(ctx context.Context, arg GetActiveLandlordAgreementsParams) ([]GetActiveLandlordAgreementsRow, error) {
	rows, err := q.db.Query(ctx, getActiveLandlordAgreements, arg.LandlordID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetActiveLandlordAgreementsRow{}
	for rows.Next() {
		var i GetActiveLandlordAgreementsRow
		if err := rows.Scan(
			&i.ID,
			&i.ApplicationID,
			&i.PropertyID,
			&i.TenantID,
			&i.LandlordID,
			&i.AgreementDocumentUrl,
			&i.LeaseStartDate,
			&i.LeaseEndDate,
			&i.MonthlyRent,
			&i.SecurityDeposit,
			&i.TotalUpfrontPayment,
			&i.PaymentSchedule,
			&i.TermsAndConditions,
			&i.Status,
			&i.TenantSignedAt,
			&i.LandlordSignedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PropertyTitle,
			&i.TenantFirstName,
			&i.TenantLastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActiveTenantAgreements = `-- name: GetActiveTenantAgreements :many
SELECT ra.id, ra.application_id, ra.property_id, ra.tenant_id, ra.landlord_id, ra.agreement_document_url, ra.lease_start_date, ra.lease_end_date, ra.monthly_rent, ra.security_deposit, ra.total_upfront_payment, ra.payment_schedule, ra.terms_and_conditions, ra.status, ra.tenant_signed_at, ra.landlord_signed_at, ra.created_at, ra.updated_at, p.title as property_title, p.address as property_address,
       l.first_name as landlord_first_name, l.last_name as landlord_last_name
FROM rental_agreements ra
JOIN properties p ON ra.property_id = p.id
JOIN users l ON ra.landlord_id = l.id
WHERE ra.tenant_id = $1 AND ra.status = 'active'
ORDER BY ra.lease_end_date ASC
LIMIT $2 OFFSET $3
`

type GetActiveTenantAgreementsParams struct {
	TenantID int64 `json:"tenant_id"`
	Limit    int32 `json:"limit"`
	Offset   int32 `json:"offset"`
}

type GetActiveTenantAgreementsRow struct {
	ID                   int64                   `json:"id"`
	ApplicationID        int64                   `json:"application_id"`
	PropertyID           int64                   `json:"property_id"`
	TenantID             int64                   `json:"tenant_id"`
	LandlordID           int64                   `json:"landlord_id"`
	AgreementDocumentUrl pgtype.Text             `json:"agreement_document_url"`
	LeaseStartDate       pgtype.Date             `json:"lease_start_date"`
	LeaseEndDate         pgtype.Date             `json:"lease_end_date"`
	MonthlyRent          pgtype.Numeric          `json:"monthly_rent"`
	SecurityDeposit      pgtype.Numeric          `json:"security_deposit"`
	TotalUpfrontPayment  pgtype.Numeric          `json:"total_upfront_payment"`
	PaymentSchedule      pgtype.Text             `json:"payment_schedule"`
	TermsAndConditions   pgtype.Text             `json:"terms_and_conditions"`
	Status               NullAgreementStatusEnum `json:"status"`
	TenantSignedAt       pgtype.Timestamptz      `json:"tenant_signed_at"`
	LandlordSignedAt     pgtype.Timestamptz      `json:"landlord_signed_at"`
	CreatedAt            pgtype.Timestamptz      `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz      `json:"updated_at"`
	PropertyTitle        string                  `json:"property_title"`
	PropertyAddress      string                  `json:"property_address"`
	LandlordFirstName    string                  `json:"landlord_first_name"`
	LandlordLastName     string                  `json:"landlord_last_name"`
}

// Get active agreements for tenant
func (q *Queries) GetActiveTenantAgreements(ctx context.Context, arg GetActiveTenantAgreementsParams) ([]GetActiveTenantAgreementsRow, error) {
	rows, err := q.db.Query(ctx, getActiveTenantAgreements, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetActiveTenantAgreementsRow{}
	for rows.Next() {
		var i GetActiveTenantAgreementsRow
		if err := rows.Scan(
			&i.ID,
			&i.ApplicationID,
			&i.PropertyID,
			&i.TenantID,
			&i.LandlordID,
			&i.AgreementDocumentUrl,
			&i.LeaseStartDate,
			&i.LeaseEndDate,
			&i.MonthlyRent,
			&i.SecurityDeposit,
			&i.TotalUpfrontPayment,
			&i.PaymentSchedule,
			&i.TermsAndConditions,
			&i.Status,
			&i.TenantSignedAt,
			&i.LandlordSignedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PropertyTitle,
			&i.PropertyAddress,
			&i.LandlordFirstName,
			&i.LandlordLastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAgreementStatistics = `-- name: GetAgreementStatistics :one
SELECT 
  COUNT(*) as total_agreements,
  COUNT(CASE WHEN status = 'active' THEN 1 END) as active_agreements,
  COUNT(CASE WHEN status = 'completed' THEN 1 END) as completed_agreements,
  COUNT(CASE WHEN status = 'pending_signatures' THEN 1 END) as pending_signatures,
  AVG(monthly_rent) as average_rent
FROM rental_agreements
`

type GetAgreementStatisticsRow struct {
	TotalAgreements     int64   `json:"total_agreements"`
	ActiveAgreements    int64   `json:"active_agreements"`
	CompletedAgreements int64   `json:"completed_agreements"`
	PendingSignatures   int64   `json:"pending_signatures"`
	AverageRent         float64 `json:"average_rent"`
}

// Get agreement statistics
func (q *Queries) GetAgreementStatistics(ctx context.Context) (GetAgreementStatisticsRow, error) {
	row := q.db.QueryRow(ctx, getAgreementStatistics)
	var i GetAgreementStatisticsRow
	err := row.Scan(
		&i.TotalAgreements,
		&i.ActiveAgreements,
		&i.CompletedAgreements,
		&i.PendingSignatures,
		&i.AverageRent,
	)
	return i, err
}

const getAgreementsPendingSignatures = `-- name: GetAgreementsPendingSignatures :many
SELECT ra.id, ra.application_id, ra.property_id, ra.tenant_id, ra.landlord_id, ra.agreement_document_url, ra.lease_start_date, ra.lease_end_date, ra.monthly_rent, ra.security_deposit, ra.total_upfront_payment, ra.payment_schedule, ra.terms_and_conditions, ra.status, ra.tenant_signed_at, ra.landlord_signed_at, ra.created_at, ra.updated_at, p.title as property_title,
       t.first_name as tenant_first_name, t.last_name as tenant_last_name,
       l.first_name as landlord_first_name, l.last_name as landlord_last_name
FROM rental_agreements ra
JOIN properties p ON ra.property_id = p.id
JOIN users t ON ra.tenant_id = t.id
JOIN users l ON ra.landlord_id = l.id
WHERE ra.status = 'pending_signatures'
ORDER BY ra.created_at ASC
LIMIT $1 OFFSET $2
`

type GetAgreementsPendingSignaturesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetAgreementsPendingSignaturesRow struct {
	ID                   int64                   `json:"id"`
	ApplicationID        int64                   `json:"application_id"`
	PropertyID           int64                   `json:"property_id"`
	TenantID             int64                   `json:"tenant_id"`
	LandlordID           int64                   `json:"landlord_id"`
	AgreementDocumentUrl pgtype.Text             `json:"agreement_document_url"`
	LeaseStartDate       pgtype.Date             `json:"lease_start_date"`
	LeaseEndDate         pgtype.Date             `json:"lease_end_date"`
	MonthlyRent          pgtype.Numeric          `json:"monthly_rent"`
	SecurityDeposit      pgtype.Numeric          `json:"security_deposit"`
	TotalUpfrontPayment  pgtype.Numeric          `json:"total_upfront_payment"`
	PaymentSchedule      pgtype.Text             `json:"payment_schedule"`
	TermsAndConditions   pgtype.Text             `json:"terms_and_conditions"`
	Status               NullAgreementStatusEnum `json:"status"`
	TenantSignedAt       pgtype.Timestamptz      `json:"tenant_signed_at"`
	LandlordSignedAt     pgtype.Timestamptz      `json:"landlord_signed_at"`
	CreatedAt            pgtype.Timestamptz      `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz      `json:"updated_at"`
	PropertyTitle        string                  `json:"property_title"`
	TenantFirstName      string                  `json:"tenant_first_name"`
	TenantLastName       string                  `json:"tenant_last_name"`
	LandlordFirstName    string                  `json:"landlord_first_name"`
	LandlordLastName     string                  `json:"landlord_last_name"`
}

// Get agreements pending signatures
func (q *Queries) GetAgreementsPendingSignatures(ctx context.Context, arg GetAgreementsPendingSignaturesParams) ([]GetAgreementsPendingSignaturesRow, error) {
	rows, err := q.db.Query(ctx, getAgreementsPendingSignatures, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAgreementsPendingSignaturesRow{}
	for rows.Next() {
		var i GetAgreementsPendingSignaturesRow
		if err := rows.Scan(
			&i.ID,
			&i.ApplicationID,
			&i.PropertyID,
			&i.TenantID,
			&i.LandlordID,
			&i.AgreementDocumentUrl,
			&i.LeaseStartDate,
			&i.LeaseEndDate,
			&i.MonthlyRent,
			&i.SecurityDeposit,
			&i.TotalUpfrontPayment,
			&i.PaymentSchedule,
			&i.TermsAndConditions,
			&i.Status,
			&i.TenantSignedAt,
			&i.LandlordSignedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PropertyTitle,
			&i.TenantFirstName,
			&i.TenantLastName,
			&i.LandlordFirstName,
			&i.LandlordLastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExpiringAgreements = `-- name: GetExpiringAgreements :many
SELECT ra.id, ra.application_id, ra.property_id, ra.tenant_id, ra.landlord_id, ra.agreement_document_url, ra.lease_start_date, ra.lease_end_date, ra.monthly_rent, ra.security_deposit, ra.total_upfront_payment, ra.payment_schedule, ra.terms_and_conditions, ra.status, ra.tenant_signed_at, ra.landlord_signed_at, ra.created_at, ra.updated_at, p.title as property_title,
       t.first_name as tenant_first_name, t.last_name as tenant_last_name, t.email as tenant_email,
       l.first_name as landlord_first_name, l.last_name as landlord_last_name, l.email as landlord_email
FROM rental_agreements ra
JOIN properties p ON ra.property_id = p.id
JOIN users t ON ra.tenant_id = t.id
JOIN users l ON ra.landlord_id = l.id
WHERE ra.status = 'active' AND ra.lease_end_date BETWEEN $1 AND $2
ORDER BY ra.lease_end_date ASC
LIMIT $3 OFFSET $4
`

type GetExpiringAgreementsParams struct {
	LeaseEndDate   pgtype.Date `json:"lease_end_date"`
	LeaseEndDate_2 pgtype.Date `json:"lease_end_date_2"`
	Limit          int32       `json:"limit"`
	Offset         int32       `json:"offset"`
}

type GetExpiringAgreementsRow struct {
	ID                   int64                   `json:"id"`
	ApplicationID        int64                   `json:"application_id"`
	PropertyID           int64                   `json:"property_id"`
	TenantID             int64                   `json:"tenant_id"`
	LandlordID           int64                   `json:"landlord_id"`
	AgreementDocumentUrl pgtype.Text             `json:"agreement_document_url"`
	LeaseStartDate       pgtype.Date             `json:"lease_start_date"`
	LeaseEndDate         pgtype.Date             `json:"lease_end_date"`
	MonthlyRent          pgtype.Numeric          `json:"monthly_rent"`
	SecurityDeposit      pgtype.Numeric          `json:"security_deposit"`
	TotalUpfrontPayment  pgtype.Numeric          `json:"total_upfront_payment"`
	PaymentSchedule      pgtype.Text             `json:"payment_schedule"`
	TermsAndConditions   pgtype.Text             `json:"terms_and_conditions"`
	Status               NullAgreementStatusEnum `json:"status"`
	TenantSignedAt       pgtype.Timestamptz      `json:"tenant_signed_at"`
	LandlordSignedAt     pgtype.Timestamptz      `json:"landlord_signed_at"`
	CreatedAt            pgtype.Timestamptz      `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz      `json:"updated_at"`
	PropertyTitle        string                  `json:"property_title"`
	TenantFirstName      string                  `json:"tenant_first_name"`
	TenantLastName       string                  `json:"tenant_last_name"`
	TenantEmail          string                  `json:"tenant_email"`
	LandlordFirstName    string                  `json:"landlord_first_name"`
	LandlordLastName     string                  `json:"landlord_last_name"`
	LandlordEmail        string                  `json:"landlord_email"`
}

// Get expiring agreements
func (q *Queries) GetExpiringAgreements(ctx context.Context, arg GetExpiringAgreementsParams) ([]GetExpiringAgreementsRow, error) {
	rows, err := q.db.Query(ctx, getExpiringAgreements,
		arg.LeaseEndDate,
		arg.LeaseEndDate_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetExpiringAgreementsRow{}
	for rows.Next() {
		var i GetExpiringAgreementsRow
		if err := rows.Scan(
			&i.ID,
			&i.ApplicationID,
			&i.PropertyID,
			&i.TenantID,
			&i.LandlordID,
			&i.AgreementDocumentUrl,
			&i.LeaseStartDate,
			&i.LeaseEndDate,
			&i.MonthlyRent,
			&i.SecurityDeposit,
			&i.TotalUpfrontPayment,
			&i.PaymentSchedule,
			&i.TermsAndConditions,
			&i.Status,
			&i.TenantSignedAt,
			&i.LandlordSignedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PropertyTitle,
			&i.TenantFirstName,
			&i.TenantLastName,
			&i.TenantEmail,
			&i.LandlordFirstName,
			&i.LandlordLastName,
			&i.LandlordEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLandlordRentalAgreements = `-- name: GetLandlordRentalAgreements :many
SELECT ra.id, ra.application_id, ra.property_id, ra.tenant_id, ra.landlord_id, ra.agreement_document_url, ra.lease_start_date, ra.lease_end_date, ra.monthly_rent, ra.security_deposit, ra.total_upfront_payment, ra.payment_schedule, ra.terms_and_conditions, ra.status, ra.tenant_signed_at, ra.landlord_signed_at, ra.created_at, ra.updated_at, p.title as property_title,
       t.first_name as tenant_first_name, t.last_name as tenant_last_name, t.email as tenant_email
FROM rental_agreements ra
JOIN properties p ON ra.property_id = p.id
JOIN users t ON ra.tenant_id = t.id
WHERE ra.landlord_id = $1
ORDER BY ra.created_at DESC
LIMIT $2 OFFSET $3
`

type GetLandlordRentalAgreementsParams struct {
	LandlordID int64 `json:"landlord_id"`
	Limit      int32 `json:"limit"`
	Offset     int32 `json:"offset"`
}

type GetLandlordRentalAgreementsRow struct {
	ID                   int64                   `json:"id"`
	ApplicationID        int64                   `json:"application_id"`
	PropertyID           int64                   `json:"property_id"`
	TenantID             int64                   `json:"tenant_id"`
	LandlordID           int64                   `json:"landlord_id"`
	AgreementDocumentUrl pgtype.Text             `json:"agreement_document_url"`
	LeaseStartDate       pgtype.Date             `json:"lease_start_date"`
	LeaseEndDate         pgtype.Date             `json:"lease_end_date"`
	MonthlyRent          pgtype.Numeric          `json:"monthly_rent"`
	SecurityDeposit      pgtype.Numeric          `json:"security_deposit"`
	TotalUpfrontPayment  pgtype.Numeric          `json:"total_upfront_payment"`
	PaymentSchedule      pgtype.Text             `json:"payment_schedule"`
	TermsAndConditions   pgtype.Text             `json:"terms_and_conditions"`
	Status               NullAgreementStatusEnum `json:"status"`
	TenantSignedAt       pgtype.Timestamptz      `json:"tenant_signed_at"`
	LandlordSignedAt     pgtype.Timestamptz      `json:"landlord_signed_at"`
	CreatedAt            pgtype.Timestamptz      `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz      `json:"updated_at"`
	PropertyTitle        string                  `json:"property_title"`
	TenantFirstName      string                  `json:"tenant_first_name"`
	TenantLastName       string                  `json:"tenant_last_name"`
	TenantEmail          string                  `json:"tenant_email"`
}

// Get landlord's rental agreements
func (q *Queries) GetLandlordRentalAgreements(ctx context.Context, arg GetLandlordRentalAgreementsParams) ([]GetLandlordRentalAgreementsRow, error) {
	rows, err := q.db.Query(ctx, getLandlordRentalAgreements, arg.LandlordID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetLandlordRentalAgreementsRow{}
	for rows.Next() {
		var i GetLandlordRentalAgreementsRow
		if err := rows.Scan(
			&i.ID,
			&i.ApplicationID,
			&i.PropertyID,
			&i.TenantID,
			&i.LandlordID,
			&i.AgreementDocumentUrl,
			&i.LeaseStartDate,
			&i.LeaseEndDate,
			&i.MonthlyRent,
			&i.SecurityDeposit,
			&i.TotalUpfrontPayment,
			&i.PaymentSchedule,
			&i.TermsAndConditions,
			&i.Status,
			&i.TenantSignedAt,
			&i.LandlordSignedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PropertyTitle,
			&i.TenantFirstName,
			&i.TenantLastName,
			&i.TenantEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRentalAgreementByApplicationID = `-- name: GetRentalAgreementByApplicationID :one
SELECT id, application_id, property_id, tenant_id, landlord_id, agreement_document_url, lease_start_date, lease_end_date, monthly_rent, security_deposit, total_upfront_payment, payment_schedule, terms_and_conditions, status, tenant_signed_at, landlord_signed_at, created_at, updated_at FROM rental_agreements 
WHERE application_id = $1 LIMIT 1
`

// Get rental agreement by application ID
func (q *Queries) GetRentalAgreementByApplicationID(ctx context.Context, applicationID int64) (RentalAgreement, error) {
	row := q.db.QueryRow(ctx, getRentalAgreementByApplicationID, applicationID)
	var i RentalAgreement
	err := row.Scan(
		&i.ID,
		&i.ApplicationID,
		&i.PropertyID,
		&i.TenantID,
		&i.LandlordID,
		&i.AgreementDocumentUrl,
		&i.LeaseStartDate,
		&i.LeaseEndDate,
		&i.MonthlyRent,
		&i.SecurityDeposit,
		&i.TotalUpfrontPayment,
		&i.PaymentSchedule,
		&i.TermsAndConditions,
		&i.Status,
		&i.TenantSignedAt,
		&i.LandlordSignedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRentalAgreementByID = `-- name: GetRentalAgreementByID :one
SELECT id, application_id, property_id, tenant_id, landlord_id, agreement_document_url, lease_start_date, lease_end_date, monthly_rent, security_deposit, total_upfront_payment, payment_schedule, terms_and_conditions, status, tenant_signed_at, landlord_signed_at, created_at, updated_at FROM rental_agreements 
WHERE id = $1 LIMIT 1
`

// Get rental agreement by ID
func (q *Queries) GetRentalAgreementByID(ctx context.Context, id int64) (RentalAgreement, error) {
	row := q.db.QueryRow(ctx, getRentalAgreementByID, id)
	var i RentalAgreement
	err := row.Scan(
		&i.ID,
		&i.ApplicationID,
		&i.PropertyID,
		&i.TenantID,
		&i.LandlordID,
		&i.AgreementDocumentUrl,
		&i.LeaseStartDate,
		&i.LeaseEndDate,
		&i.MonthlyRent,
		&i.SecurityDeposit,
		&i.TotalUpfrontPayment,
		&i.PaymentSchedule,
		&i.TermsAndConditions,
		&i.Status,
		&i.TenantSignedAt,
		&i.LandlordSignedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRentalAgreementWithDetails = `-- name: GetRentalAgreementWithDetails :one
SELECT ra.id, ra.application_id, ra.property_id, ra.tenant_id, ra.landlord_id, ra.agreement_document_url, ra.lease_start_date, ra.lease_end_date, ra.monthly_rent, ra.security_deposit, ra.total_upfront_payment, ra.payment_schedule, ra.terms_and_conditions, ra.status, ra.tenant_signed_at, ra.landlord_signed_at, ra.created_at, ra.updated_at, p.title as property_title, p.address as property_address,
       t.first_name as tenant_first_name, t.last_name as tenant_last_name, t.email as tenant_email, t.phone as tenant_phone,
       l.first_name as landlord_first_name, l.last_name as landlord_last_name, l.email as landlord_email, l.phone as landlord_phone,
       app.preferred_move_in_date
FROM rental_agreements ra
JOIN properties p ON ra.property_id = p.id
JOIN users t ON ra.tenant_id = t.id
JOIN users l ON ra.landlord_id = l.id
JOIN rental_applications app ON ra.application_id = app.id
WHERE ra.id = $1 LIMIT 1
`

type GetRentalAgreementWithDetailsRow struct {
	ID                   int64                   `json:"id"`
	ApplicationID        int64                   `json:"application_id"`
	PropertyID           int64                   `json:"property_id"`
	TenantID             int64                   `json:"tenant_id"`
	LandlordID           int64                   `json:"landlord_id"`
	AgreementDocumentUrl pgtype.Text             `json:"agreement_document_url"`
	LeaseStartDate       pgtype.Date             `json:"lease_start_date"`
	LeaseEndDate         pgtype.Date             `json:"lease_end_date"`
	MonthlyRent          pgtype.Numeric          `json:"monthly_rent"`
	SecurityDeposit      pgtype.Numeric          `json:"security_deposit"`
	TotalUpfrontPayment  pgtype.Numeric          `json:"total_upfront_payment"`
	PaymentSchedule      pgtype.Text             `json:"payment_schedule"`
	TermsAndConditions   pgtype.Text             `json:"terms_and_conditions"`
	Status               NullAgreementStatusEnum `json:"status"`
	TenantSignedAt       pgtype.Timestamptz      `json:"tenant_signed_at"`
	LandlordSignedAt     pgtype.Timestamptz      `json:"landlord_signed_at"`
	CreatedAt            pgtype.Timestamptz      `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz      `json:"updated_at"`
	PropertyTitle        string                  `json:"property_title"`
	PropertyAddress      string                  `json:"property_address"`
	TenantFirstName      string                  `json:"tenant_first_name"`
	TenantLastName       string                  `json:"tenant_last_name"`
	TenantEmail          string                  `json:"tenant_email"`
	TenantPhone          string                  `json:"tenant_phone"`
	LandlordFirstName    string                  `json:"landlord_first_name"`
	LandlordLastName     string                  `json:"landlord_last_name"`
	LandlordEmail        string                  `json:"landlord_email"`
	LandlordPhone        string                  `json:"landlord_phone"`
	PreferredMoveInDate  pgtype.Date             `json:"preferred_move_in_date"`
}

// Get rental agreement with details
func (q *Queries) GetRentalAgreementWithDetails(ctx context.Context, id int64) (GetRentalAgreementWithDetailsRow, error) {
	row := q.db.QueryRow(ctx, getRentalAgreementWithDetails, id)
	var i GetRentalAgreementWithDetailsRow
	err := row.Scan(
		&i.ID,
		&i.ApplicationID,
		&i.PropertyID,
		&i.TenantID,
		&i.LandlordID,
		&i.AgreementDocumentUrl,
		&i.LeaseStartDate,
		&i.LeaseEndDate,
		&i.MonthlyRent,
		&i.SecurityDeposit,
		&i.TotalUpfrontPayment,
		&i.PaymentSchedule,
		&i.TermsAndConditions,
		&i.Status,
		&i.TenantSignedAt,
		&i.LandlordSignedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PropertyTitle,
		&i.PropertyAddress,
		&i.TenantFirstName,
		&i.TenantLastName,
		&i.TenantEmail,
		&i.TenantPhone,
		&i.LandlordFirstName,
		&i.LandlordLastName,
		&i.LandlordEmail,
		&i.LandlordPhone,
		&i.PreferredMoveInDate,
	)
	return i, err
}

const getTenantRentalAgreements = `-- name: GetTenantRentalAgreements :many
SELECT ra.id, ra.application_id, ra.property_id, ra.tenant_id, ra.landlord_id, ra.agreement_document_url, ra.lease_start_date, ra.lease_end_date, ra.monthly_rent, ra.security_deposit, ra.total_upfront_payment, ra.payment_schedule, ra.terms_and_conditions, ra.status, ra.tenant_signed_at, ra.landlord_signed_at, ra.created_at, ra.updated_at, p.title as property_title, p.address as property_address,
       l.first_name as landlord_first_name, l.last_name as landlord_last_name, l.email as landlord_email
FROM rental_agreements ra
JOIN properties p ON ra.property_id = p.id
JOIN users l ON ra.landlord_id = l.id
WHERE ra.tenant_id = $1
ORDER BY ra.created_at DESC
LIMIT $2 OFFSET $3
`

type GetTenantRentalAgreementsParams struct {
	TenantID int64 `json:"tenant_id"`
	Limit    int32 `json:"limit"`
	Offset   int32 `json:"offset"`
}

type GetTenantRentalAgreementsRow struct {
	ID                   int64                   `json:"id"`
	ApplicationID        int64                   `json:"application_id"`
	PropertyID           int64                   `json:"property_id"`
	TenantID             int64                   `json:"tenant_id"`
	LandlordID           int64                   `json:"landlord_id"`
	AgreementDocumentUrl pgtype.Text             `json:"agreement_document_url"`
	LeaseStartDate       pgtype.Date             `json:"lease_start_date"`
	LeaseEndDate         pgtype.Date             `json:"lease_end_date"`
	MonthlyRent          pgtype.Numeric          `json:"monthly_rent"`
	SecurityDeposit      pgtype.Numeric          `json:"security_deposit"`
	TotalUpfrontPayment  pgtype.Numeric          `json:"total_upfront_payment"`
	PaymentSchedule      pgtype.Text             `json:"payment_schedule"`
	TermsAndConditions   pgtype.Text             `json:"terms_and_conditions"`
	Status               NullAgreementStatusEnum `json:"status"`
	TenantSignedAt       pgtype.Timestamptz      `json:"tenant_signed_at"`
	LandlordSignedAt     pgtype.Timestamptz      `json:"landlord_signed_at"`
	CreatedAt            pgtype.Timestamptz      `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz      `json:"updated_at"`
	PropertyTitle        string                  `json:"property_title"`
	PropertyAddress      string                  `json:"property_address"`
	LandlordFirstName    string                  `json:"landlord_first_name"`
	LandlordLastName     string                  `json:"landlord_last_name"`
	LandlordEmail        string                  `json:"landlord_email"`
}

// Get tenant's rental agreements
func (q *Queries) GetTenantRentalAgreements(ctx context.Context, arg GetTenantRentalAgreementsParams) ([]GetTenantRentalAgreementsRow, error) {
	rows, err := q.db.Query(ctx, getTenantRentalAgreements, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTenantRentalAgreementsRow{}
	for rows.Next() {
		var i GetTenantRentalAgreementsRow
		if err := rows.Scan(
			&i.ID,
			&i.ApplicationID,
			&i.PropertyID,
			&i.TenantID,
			&i.LandlordID,
			&i.AgreementDocumentUrl,
			&i.LeaseStartDate,
			&i.LeaseEndDate,
			&i.MonthlyRent,
			&i.SecurityDeposit,
			&i.TotalUpfrontPayment,
			&i.PaymentSchedule,
			&i.TermsAndConditions,
			&i.Status,
			&i.TenantSignedAt,
			&i.LandlordSignedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PropertyTitle,
			&i.PropertyAddress,
			&i.LandlordFirstName,
			&i.LandlordLastName,
			&i.LandlordEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const landlordSignAgreement = `-- name: LandlordSignAgreement :one
UPDATE rental_agreements 
SET landlord_signed_at = NOW(), updated_at = NOW(),
    status = CASE WHEN tenant_signed_at IS NOT NULL THEN 'active' ELSE 'pending_signatures' END
WHERE id = $1 
RETURNING id, application_id, property_id, tenant_id, landlord_id, agreement_document_url, lease_start_date, lease_end_date, monthly_rent, security_deposit, total_upfront_payment, payment_schedule, terms_and_conditions, status, tenant_signed_at, landlord_signed_at, created_at, updated_at
`

// Landlord sign agreement
func (q *Queries) LandlordSignAgreement(ctx context.Context, id int64) (RentalAgreement, error) {
	row := q.db.QueryRow(ctx, landlordSignAgreement, id)
	var i RentalAgreement
	err := row.Scan(
		&i.ID,
		&i.ApplicationID,
		&i.PropertyID,
		&i.TenantID,
		&i.LandlordID,
		&i.AgreementDocumentUrl,
		&i.LeaseStartDate,
		&i.LeaseEndDate,
		&i.MonthlyRent,
		&i.SecurityDeposit,
		&i.TotalUpfrontPayment,
		&i.PaymentSchedule,
		&i.TermsAndConditions,
		&i.Status,
		&i.TenantSignedAt,
		&i.LandlordSignedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const tenantSignAgreement = `-- name: TenantSignAgreement :one
UPDATE rental_agreements 
SET tenant_signed_at = NOW(), updated_at = NOW(),
    status = CASE WHEN landlord_signed_at IS NOT NULL THEN 'active' ELSE 'pending_signatures' END
WHERE id = $1 
RETURNING id, application_id, property_id, tenant_id, landlord_id, agreement_document_url, lease_start_date, lease_end_date, monthly_rent, security_deposit, total_upfront_payment, payment_schedule, terms_and_conditions, status, tenant_signed_at, landlord_signed_at, created_at, updated_at
`

// Tenant sign agreement
func (q *Queries) TenantSignAgreement(ctx context.Context, id int64) (RentalAgreement, error) {
	row := q.db.QueryRow(ctx, tenantSignAgreement, id)
	var i RentalAgreement
	err := row.Scan(
		&i.ID,
		&i.ApplicationID,
		&i.PropertyID,
		&i.TenantID,
		&i.LandlordID,
		&i.AgreementDocumentUrl,
		&i.LeaseStartDate,
		&i.LeaseEndDate,
		&i.MonthlyRent,
		&i.SecurityDeposit,
		&i.TotalUpfrontPayment,
		&i.PaymentSchedule,
		&i.TermsAndConditions,
		&i.Status,
		&i.TenantSignedAt,
		&i.LandlordSignedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const terminateAgreement = `-- name: TerminateAgreement :one
UPDATE rental_agreements 
SET status = 'terminated', updated_at = NOW()
WHERE id = $1 
RETURNING id, application_id, property_id, tenant_id, landlord_id, agreement_document_url, lease_start_date, lease_end_date, monthly_rent, security_deposit, total_upfront_payment, payment_schedule, terms_and_conditions, status, tenant_signed_at, landlord_signed_at, created_at, updated_at
`

// Terminate agreement
func (q *Queries) TerminateAgreement(ctx context.Context, id int64) (RentalAgreement, error) {
	row := q.db.QueryRow(ctx, terminateAgreement, id)
	var i RentalAgreement
	err := row.Scan(
		&i.ID,
		&i.ApplicationID,
		&i.PropertyID,
		&i.TenantID,
		&i.LandlordID,
		&i.AgreementDocumentUrl,
		&i.LeaseStartDate,
		&i.LeaseEndDate,
		&i.MonthlyRent,
		&i.SecurityDeposit,
		&i.TotalUpfrontPayment,
		&i.PaymentSchedule,
		&i.TermsAndConditions,
		&i.Status,
		&i.TenantSignedAt,
		&i.LandlordSignedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateAgreementDocument = `-- name: UpdateAgreementDocument :one
UPDATE rental_agreements 
SET agreement_document_url = $2, updated_at = NOW()
WHERE id = $1 
RETURNING id, application_id, property_id, tenant_id, landlord_id, agreement_document_url, lease_start_date, lease_end_date, monthly_rent, security_deposit, total_upfront_payment, payment_schedule, terms_and_conditions, status, tenant_signed_at, landlord_signed_at, created_at, updated_at
`

type UpdateAgreementDocumentParams struct {
	ID                   int64       `json:"id"`
	AgreementDocumentUrl pgtype.Text `json:"agreement_document_url"`
}

// Update agreement document
func (q *Queries) UpdateAgreementDocument(ctx context.Context, arg UpdateAgreementDocumentParams) (RentalAgreement, error) {
	row := q.db.QueryRow(ctx, updateAgreementDocument, arg.ID, arg.AgreementDocumentUrl)
	var i RentalAgreement
	err := row.Scan(
		&i.ID,
		&i.ApplicationID,
		&i.PropertyID,
		&i.TenantID,
		&i.LandlordID,
		&i.AgreementDocumentUrl,
		&i.LeaseStartDate,
		&i.LeaseEndDate,
		&i.MonthlyRent,
		&i.SecurityDeposit,
		&i.TotalUpfrontPayment,
		&i.PaymentSchedule,
		&i.TermsAndConditions,
		&i.Status,
		&i.TenantSignedAt,
		&i.LandlordSignedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateAgreementStatus = `-- name: UpdateAgreementStatus :one
UPDATE rental_agreements 
SET status = $2, updated_at = NOW()
WHERE id = $1 
RETURNING id, application_id, property_id, tenant_id, landlord_id, agreement_document_url, lease_start_date, lease_end_date, monthly_rent, security_deposit, total_upfront_payment, payment_schedule, terms_and_conditions, status, tenant_signed_at, landlord_signed_at, created_at, updated_at
`

type UpdateAgreementStatusParams struct {
	ID     int64                   `json:"id"`
	Status NullAgreementStatusEnum `json:"status"`
}

// Update agreement status
func (q *Queries) UpdateAgreementStatus(ctx context.Context, arg UpdateAgreementStatusParams) (RentalAgreement, error) {
	row := q.db.QueryRow(ctx, updateAgreementStatus, arg.ID, arg.Status)
	var i RentalAgreement
	err := row.Scan(
		&i.ID,
		&i.ApplicationID,
		&i.PropertyID,
		&i.TenantID,
		&i.LandlordID,
		&i.AgreementDocumentUrl,
		&i.LeaseStartDate,
		&i.LeaseEndDate,
		&i.MonthlyRent,
		&i.SecurityDeposit,
		&i.TotalUpfrontPayment,
		&i.PaymentSchedule,
		&i.TermsAndConditions,
		&i.Status,
		&i.TenantSignedAt,
		&i.LandlordSignedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateRentalAgreement = `-- name: UpdateRentalAgreement :one
UPDATE rental_agreements 
SET lease_start_date = $2, lease_end_date = $3, monthly_rent = $4,
    security_deposit = $5, total_upfront_payment = $6, payment_schedule = $7,
    terms_and_conditions = $8, updated_at = NOW()
WHERE id = $1 
RETURNING id, application_id, property_id, tenant_id, landlord_id, agreement_document_url, lease_start_date, lease_end_date, monthly_rent, security_deposit, total_upfront_payment, payment_schedule, terms_and_conditions, status, tenant_signed_at, landlord_signed_at, created_at, updated_at
`

type UpdateRentalAgreementParams struct {
	ID                  int64          `json:"id"`
	LeaseStartDate      pgtype.Date    `json:"lease_start_date"`
	LeaseEndDate        pgtype.Date    `json:"lease_end_date"`
	MonthlyRent         pgtype.Numeric `json:"monthly_rent"`
	SecurityDeposit     pgtype.Numeric `json:"security_deposit"`
	TotalUpfrontPayment pgtype.Numeric `json:"total_upfront_payment"`
	PaymentSchedule     pgtype.Text    `json:"payment_schedule"`
	TermsAndConditions  pgtype.Text    `json:"terms_and_conditions"`
}

// Update rental agreement
func (q *Queries) UpdateRentalAgreement(ctx context.Context, arg UpdateRentalAgreementParams) (RentalAgreement, error) {
	row := q.db.QueryRow(ctx, updateRentalAgreement,
		arg.ID,
		arg.LeaseStartDate,
		arg.LeaseEndDate,
		arg.MonthlyRent,
		arg.SecurityDeposit,
		arg.TotalUpfrontPayment,
		arg.PaymentSchedule,
		arg.TermsAndConditions,
	)
	var i RentalAgreement
	err := row.Scan(
		&i.ID,
		&i.ApplicationID,
		&i.PropertyID,
		&i.TenantID,
		&i.LandlordID,
		&i.AgreementDocumentUrl,
		&i.LeaseStartDate,
		&i.LeaseEndDate,
		&i.MonthlyRent,
		&i.SecurityDeposit,
		&i.TotalUpfrontPayment,
		&i.PaymentSchedule,
		&i.TermsAndConditions,
		&i.Status,
		&i.TenantSignedAt,
		&i.LandlordSignedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
