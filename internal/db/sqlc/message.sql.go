// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: message.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countUnreadMessages = `-- name: CountUnreadMessages :one
SELECT COUNT(*) FROM messages 
WHERE recipient_id = $1 AND is_read = false
`

// Count unread messages for user
func (q *Queries) CountUnreadMessages(ctx context.Context, recipientID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countUnreadMessages, recipientID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUnreadMessagesFromSender = `-- name: CountUnreadMessagesFromSender :one
SELECT COUNT(*) FROM messages 
WHERE recipient_id = $1 AND sender_id = $2 AND is_read = false
`

type CountUnreadMessagesFromSenderParams struct {
	RecipientID int64 `json:"recipient_id"`
	SenderID    int64 `json:"sender_id"`
}

// Count unread messages from sender
func (q *Queries) CountUnreadMessagesFromSender(ctx context.Context, arg CountUnreadMessagesFromSenderParams) (int64, error) {
	row := q.db.QueryRow(ctx, countUnreadMessagesFromSender, arg.RecipientID, arg.SenderID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createMessage = `-- name: CreateMessage :one
INSERT INTO messages (
  sender_id, recipient_id, property_id, inspection_request_id, application_id,
  message_type, content, media_url
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING id, sender_id, recipient_id, property_id, inspection_request_id, application_id, message_type, content, media_url, is_read, read_at, created_at
`

type CreateMessageParams struct {
	SenderID            int64               `json:"sender_id"`
	RecipientID         int64               `json:"recipient_id"`
	PropertyID          pgtype.Int8         `json:"property_id"`
	InspectionRequestID pgtype.Int8         `json:"inspection_request_id"`
	ApplicationID       pgtype.Int8         `json:"application_id"`
	MessageType         NullMessageTypeEnum `json:"message_type"`
	Content             string              `json:"content"`
	MediaUrl            pgtype.Text         `json:"media_url"`
}

// Create message
func (q *Queries) CreateMessage(ctx context.Context, arg CreateMessageParams) (Message, error) {
	row := q.db.QueryRow(ctx, createMessage,
		arg.SenderID,
		arg.RecipientID,
		arg.PropertyID,
		arg.InspectionRequestID,
		arg.ApplicationID,
		arg.MessageType,
		arg.Content,
		arg.MediaUrl,
	)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.SenderID,
		&i.RecipientID,
		&i.PropertyID,
		&i.InspectionRequestID,
		&i.ApplicationID,
		&i.MessageType,
		&i.Content,
		&i.MediaUrl,
		&i.IsRead,
		&i.ReadAt,
		&i.CreatedAt,
	)
	return i, err
}

const deleteConversation = `-- name: DeleteConversation :exec
DELETE FROM messages 
WHERE (sender_id = $1 AND recipient_id = $2) 
   OR (sender_id = $2 AND recipient_id = $1)
`

type DeleteConversationParams struct {
	SenderID    int64 `json:"sender_id"`
	RecipientID int64 `json:"recipient_id"`
}

// Delete conversation between users
func (q *Queries) DeleteConversation(ctx context.Context, arg DeleteConversationParams) error {
	_, err := q.db.Exec(ctx, deleteConversation, arg.SenderID, arg.RecipientID)
	return err
}

const deleteMessage = `-- name: DeleteMessage :exec
DELETE FROM messages 
WHERE id = $1
`

// Delete message
func (q *Queries) DeleteMessage(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteMessage, id)
	return err
}

const getApplicationConversation = `-- name: GetApplicationConversation :many
SELECT m.id, m.sender_id, m.recipient_id, m.property_id, m.inspection_request_id, m.application_id, m.message_type, m.content, m.media_url, m.is_read, m.read_at, m.created_at, s.first_name as sender_first_name, s.last_name as sender_last_name, s.profile_picture_url
FROM messages m
JOIN users s ON m.sender_id = s.id
WHERE m.application_id = $1
ORDER BY m.created_at DESC
LIMIT $2 OFFSET $3
`

type GetApplicationConversationParams struct {
	ApplicationID pgtype.Int8 `json:"application_id"`
	Limit         int32       `json:"limit"`
	Offset        int32       `json:"offset"`
}

type GetApplicationConversationRow struct {
	ID                  int64               `json:"id"`
	SenderID            int64               `json:"sender_id"`
	RecipientID         int64               `json:"recipient_id"`
	PropertyID          pgtype.Int8         `json:"property_id"`
	InspectionRequestID pgtype.Int8         `json:"inspection_request_id"`
	ApplicationID       pgtype.Int8         `json:"application_id"`
	MessageType         NullMessageTypeEnum `json:"message_type"`
	Content             string              `json:"content"`
	MediaUrl            pgtype.Text         `json:"media_url"`
	IsRead              pgtype.Bool         `json:"is_read"`
	ReadAt              pgtype.Timestamptz  `json:"read_at"`
	CreatedAt           pgtype.Timestamptz  `json:"created_at"`
	SenderFirstName     string              `json:"sender_first_name"`
	SenderLastName      string              `json:"sender_last_name"`
	ProfilePictureUrl   pgtype.Text         `json:"profile_picture_url"`
}

// Get application conversation
func (q *Queries) GetApplicationConversation(ctx context.Context, arg GetApplicationConversationParams) ([]GetApplicationConversationRow, error) {
	rows, err := q.db.Query(ctx, getApplicationConversation, arg.ApplicationID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetApplicationConversationRow{}
	for rows.Next() {
		var i GetApplicationConversationRow
		if err := rows.Scan(
			&i.ID,
			&i.SenderID,
			&i.RecipientID,
			&i.PropertyID,
			&i.InspectionRequestID,
			&i.ApplicationID,
			&i.MessageType,
			&i.Content,
			&i.MediaUrl,
			&i.IsRead,
			&i.ReadAt,
			&i.CreatedAt,
			&i.SenderFirstName,
			&i.SenderLastName,
			&i.ProfilePictureUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getConversationBetweenUsers = `-- name: GetConversationBetweenUsers :many
SELECT m.id, m.sender_id, m.recipient_id, m.property_id, m.inspection_request_id, m.application_id, m.message_type, m.content, m.media_url, m.is_read, m.read_at, m.created_at, s.first_name as sender_first_name, s.last_name as sender_last_name, s.profile_picture_url
FROM messages m
JOIN users s ON m.sender_id = s.id
WHERE (m.sender_id = $1 AND m.recipient_id = $2) 
   OR (m.sender_id = $2 AND m.recipient_id = $1)
ORDER BY m.created_at DESC
LIMIT $3 OFFSET $4
`

type GetConversationBetweenUsersParams struct {
	SenderID    int64 `json:"sender_id"`
	RecipientID int64 `json:"recipient_id"`
	Limit       int32 `json:"limit"`
	Offset      int32 `json:"offset"`
}

type GetConversationBetweenUsersRow struct {
	ID                  int64               `json:"id"`
	SenderID            int64               `json:"sender_id"`
	RecipientID         int64               `json:"recipient_id"`
	PropertyID          pgtype.Int8         `json:"property_id"`
	InspectionRequestID pgtype.Int8         `json:"inspection_request_id"`
	ApplicationID       pgtype.Int8         `json:"application_id"`
	MessageType         NullMessageTypeEnum `json:"message_type"`
	Content             string              `json:"content"`
	MediaUrl            pgtype.Text         `json:"media_url"`
	IsRead              pgtype.Bool         `json:"is_read"`
	ReadAt              pgtype.Timestamptz  `json:"read_at"`
	CreatedAt           pgtype.Timestamptz  `json:"created_at"`
	SenderFirstName     string              `json:"sender_first_name"`
	SenderLastName      string              `json:"sender_last_name"`
	ProfilePictureUrl   pgtype.Text         `json:"profile_picture_url"`
}

// Get conversation between two users
func (q *Queries) GetConversationBetweenUsers(ctx context.Context, arg GetConversationBetweenUsersParams) ([]GetConversationBetweenUsersRow, error) {
	rows, err := q.db.Query(ctx, getConversationBetweenUsers,
		arg.SenderID,
		arg.RecipientID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetConversationBetweenUsersRow{}
	for rows.Next() {
		var i GetConversationBetweenUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.SenderID,
			&i.RecipientID,
			&i.PropertyID,
			&i.InspectionRequestID,
			&i.ApplicationID,
			&i.MessageType,
			&i.Content,
			&i.MediaUrl,
			&i.IsRead,
			&i.ReadAt,
			&i.CreatedAt,
			&i.SenderFirstName,
			&i.SenderLastName,
			&i.ProfilePictureUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInspectionConversation = `-- name: GetInspectionConversation :many
SELECT m.id, m.sender_id, m.recipient_id, m.property_id, m.inspection_request_id, m.application_id, m.message_type, m.content, m.media_url, m.is_read, m.read_at, m.created_at, s.first_name as sender_first_name, s.last_name as sender_last_name, s.profile_picture_url
FROM messages m
JOIN users s ON m.sender_id = s.id
WHERE m.inspection_request_id = $1
ORDER BY m.created_at DESC
LIMIT $2 OFFSET $3
`

type GetInspectionConversationParams struct {
	InspectionRequestID pgtype.Int8 `json:"inspection_request_id"`
	Limit               int32       `json:"limit"`
	Offset              int32       `json:"offset"`
}

type GetInspectionConversationRow struct {
	ID                  int64               `json:"id"`
	SenderID            int64               `json:"sender_id"`
	RecipientID         int64               `json:"recipient_id"`
	PropertyID          pgtype.Int8         `json:"property_id"`
	InspectionRequestID pgtype.Int8         `json:"inspection_request_id"`
	ApplicationID       pgtype.Int8         `json:"application_id"`
	MessageType         NullMessageTypeEnum `json:"message_type"`
	Content             string              `json:"content"`
	MediaUrl            pgtype.Text         `json:"media_url"`
	IsRead              pgtype.Bool         `json:"is_read"`
	ReadAt              pgtype.Timestamptz  `json:"read_at"`
	CreatedAt           pgtype.Timestamptz  `json:"created_at"`
	SenderFirstName     string              `json:"sender_first_name"`
	SenderLastName      string              `json:"sender_last_name"`
	ProfilePictureUrl   pgtype.Text         `json:"profile_picture_url"`
}

// Get inspection conversation
func (q *Queries) GetInspectionConversation(ctx context.Context, arg GetInspectionConversationParams) ([]GetInspectionConversationRow, error) {
	rows, err := q.db.Query(ctx, getInspectionConversation, arg.InspectionRequestID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetInspectionConversationRow{}
	for rows.Next() {
		var i GetInspectionConversationRow
		if err := rows.Scan(
			&i.ID,
			&i.SenderID,
			&i.RecipientID,
			&i.PropertyID,
			&i.InspectionRequestID,
			&i.ApplicationID,
			&i.MessageType,
			&i.Content,
			&i.MediaUrl,
			&i.IsRead,
			&i.ReadAt,
			&i.CreatedAt,
			&i.SenderFirstName,
			&i.SenderLastName,
			&i.ProfilePictureUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMessageByID = `-- name: GetMessageByID :one
SELECT id, sender_id, recipient_id, property_id, inspection_request_id, application_id, message_type, content, media_url, is_read, read_at, created_at FROM messages 
WHERE id = $1 LIMIT 1
`

// Get message by ID
func (q *Queries) GetMessageByID(ctx context.Context, id int64) (Message, error) {
	row := q.db.QueryRow(ctx, getMessageByID, id)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.SenderID,
		&i.RecipientID,
		&i.PropertyID,
		&i.InspectionRequestID,
		&i.ApplicationID,
		&i.MessageType,
		&i.Content,
		&i.MediaUrl,
		&i.IsRead,
		&i.ReadAt,
		&i.CreatedAt,
	)
	return i, err
}

const getMessageWithSenderDetails = `-- name: GetMessageWithSenderDetails :one
SELECT m.id, m.sender_id, m.recipient_id, m.property_id, m.inspection_request_id, m.application_id, m.message_type, m.content, m.media_url, m.is_read, m.read_at, m.created_at, u.first_name as sender_first_name, u.last_name as sender_last_name, u.profile_picture_url
FROM messages m
JOIN users u ON m.sender_id = u.id
WHERE m.id = $1 LIMIT 1
`

type GetMessageWithSenderDetailsRow struct {
	ID                  int64               `json:"id"`
	SenderID            int64               `json:"sender_id"`
	RecipientID         int64               `json:"recipient_id"`
	PropertyID          pgtype.Int8         `json:"property_id"`
	InspectionRequestID pgtype.Int8         `json:"inspection_request_id"`
	ApplicationID       pgtype.Int8         `json:"application_id"`
	MessageType         NullMessageTypeEnum `json:"message_type"`
	Content             string              `json:"content"`
	MediaUrl            pgtype.Text         `json:"media_url"`
	IsRead              pgtype.Bool         `json:"is_read"`
	ReadAt              pgtype.Timestamptz  `json:"read_at"`
	CreatedAt           pgtype.Timestamptz  `json:"created_at"`
	SenderFirstName     string              `json:"sender_first_name"`
	SenderLastName      string              `json:"sender_last_name"`
	ProfilePictureUrl   pgtype.Text         `json:"profile_picture_url"`
}

// Get message with sender details
func (q *Queries) GetMessageWithSenderDetails(ctx context.Context, id int64) (GetMessageWithSenderDetailsRow, error) {
	row := q.db.QueryRow(ctx, getMessageWithSenderDetails, id)
	var i GetMessageWithSenderDetailsRow
	err := row.Scan(
		&i.ID,
		&i.SenderID,
		&i.RecipientID,
		&i.PropertyID,
		&i.InspectionRequestID,
		&i.ApplicationID,
		&i.MessageType,
		&i.Content,
		&i.MediaUrl,
		&i.IsRead,
		&i.ReadAt,
		&i.CreatedAt,
		&i.SenderFirstName,
		&i.SenderLastName,
		&i.ProfilePictureUrl,
	)
	return i, err
}

const getMessagesByProperty = `-- name: GetMessagesByProperty :many
SELECT m.id, m.sender_id, m.recipient_id, m.property_id, m.inspection_request_id, m.application_id, m.message_type, m.content, m.media_url, m.is_read, m.read_at, m.created_at, s.first_name as sender_first_name, s.last_name as sender_last_name,
       r.first_name as recipient_first_name, r.last_name as recipient_last_name
FROM messages m
JOIN users s ON m.sender_id = s.id
JOIN users r ON m.recipient_id = r.id
WHERE m.property_id = $1
ORDER BY m.created_at DESC
LIMIT $2 OFFSET $3
`

type GetMessagesByPropertyParams struct {
	PropertyID pgtype.Int8 `json:"property_id"`
	Limit      int32       `json:"limit"`
	Offset     int32       `json:"offset"`
}

type GetMessagesByPropertyRow struct {
	ID                  int64               `json:"id"`
	SenderID            int64               `json:"sender_id"`
	RecipientID         int64               `json:"recipient_id"`
	PropertyID          pgtype.Int8         `json:"property_id"`
	InspectionRequestID pgtype.Int8         `json:"inspection_request_id"`
	ApplicationID       pgtype.Int8         `json:"application_id"`
	MessageType         NullMessageTypeEnum `json:"message_type"`
	Content             string              `json:"content"`
	MediaUrl            pgtype.Text         `json:"media_url"`
	IsRead              pgtype.Bool         `json:"is_read"`
	ReadAt              pgtype.Timestamptz  `json:"read_at"`
	CreatedAt           pgtype.Timestamptz  `json:"created_at"`
	SenderFirstName     string              `json:"sender_first_name"`
	SenderLastName      string              `json:"sender_last_name"`
	RecipientFirstName  string              `json:"recipient_first_name"`
	RecipientLastName   string              `json:"recipient_last_name"`
}

// Get messages by property
func (q *Queries) GetMessagesByProperty(ctx context.Context, arg GetMessagesByPropertyParams) ([]GetMessagesByPropertyRow, error) {
	rows, err := q.db.Query(ctx, getMessagesByProperty, arg.PropertyID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMessagesByPropertyRow{}
	for rows.Next() {
		var i GetMessagesByPropertyRow
		if err := rows.Scan(
			&i.ID,
			&i.SenderID,
			&i.RecipientID,
			&i.PropertyID,
			&i.InspectionRequestID,
			&i.ApplicationID,
			&i.MessageType,
			&i.Content,
			&i.MediaUrl,
			&i.IsRead,
			&i.ReadAt,
			&i.CreatedAt,
			&i.SenderFirstName,
			&i.SenderLastName,
			&i.RecipientFirstName,
			&i.RecipientLastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPropertyConversation = `-- name: GetPropertyConversation :many
SELECT m.id, m.sender_id, m.recipient_id, m.property_id, m.inspection_request_id, m.application_id, m.message_type, m.content, m.media_url, m.is_read, m.read_at, m.created_at, s.first_name as sender_first_name, s.last_name as sender_last_name, s.profile_picture_url
FROM messages m
JOIN users s ON m.sender_id = s.id
WHERE m.property_id = $1 
  AND ((m.sender_id = $2 AND m.recipient_id = $3) OR (m.sender_id = $3 AND m.recipient_id = $2))
ORDER BY m.created_at DESC
LIMIT $4 OFFSET $5
`

type GetPropertyConversationParams struct {
	PropertyID  pgtype.Int8 `json:"property_id"`
	SenderID    int64       `json:"sender_id"`
	RecipientID int64       `json:"recipient_id"`
	Limit       int32       `json:"limit"`
	Offset      int32       `json:"offset"`
}

type GetPropertyConversationRow struct {
	ID                  int64               `json:"id"`
	SenderID            int64               `json:"sender_id"`
	RecipientID         int64               `json:"recipient_id"`
	PropertyID          pgtype.Int8         `json:"property_id"`
	InspectionRequestID pgtype.Int8         `json:"inspection_request_id"`
	ApplicationID       pgtype.Int8         `json:"application_id"`
	MessageType         NullMessageTypeEnum `json:"message_type"`
	Content             string              `json:"content"`
	MediaUrl            pgtype.Text         `json:"media_url"`
	IsRead              pgtype.Bool         `json:"is_read"`
	ReadAt              pgtype.Timestamptz  `json:"read_at"`
	CreatedAt           pgtype.Timestamptz  `json:"created_at"`
	SenderFirstName     string              `json:"sender_first_name"`
	SenderLastName      string              `json:"sender_last_name"`
	ProfilePictureUrl   pgtype.Text         `json:"profile_picture_url"`
}

// Get property conversation
func (q *Queries) GetPropertyConversation(ctx context.Context, arg GetPropertyConversationParams) ([]GetPropertyConversationRow, error) {
	rows, err := q.db.Query(ctx, getPropertyConversation,
		arg.PropertyID,
		arg.SenderID,
		arg.RecipientID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPropertyConversationRow{}
	for rows.Next() {
		var i GetPropertyConversationRow
		if err := rows.Scan(
			&i.ID,
			&i.SenderID,
			&i.RecipientID,
			&i.PropertyID,
			&i.InspectionRequestID,
			&i.ApplicationID,
			&i.MessageType,
			&i.Content,
			&i.MediaUrl,
			&i.IsRead,
			&i.ReadAt,
			&i.CreatedAt,
			&i.SenderFirstName,
			&i.SenderLastName,
			&i.ProfilePictureUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentMessages = `-- name: GetRecentMessages :many
SELECT m.id, m.sender_id, m.recipient_id, m.property_id, m.inspection_request_id, m.application_id, m.message_type, m.content, m.media_url, m.is_read, m.read_at, m.created_at, s.first_name as sender_first_name, s.last_name as sender_last_name,
       r.first_name as recipient_first_name, r.last_name as recipient_last_name
FROM messages m
JOIN users s ON m.sender_id = s.id
JOIN users r ON m.recipient_id = r.id
WHERE m.sender_id = $1 OR m.recipient_id = $1
ORDER BY m.created_at DESC
LIMIT $2 OFFSET $3
`

type GetRecentMessagesParams struct {
	SenderID int64 `json:"sender_id"`
	Limit    int32 `json:"limit"`
	Offset   int32 `json:"offset"`
}

type GetRecentMessagesRow struct {
	ID                  int64               `json:"id"`
	SenderID            int64               `json:"sender_id"`
	RecipientID         int64               `json:"recipient_id"`
	PropertyID          pgtype.Int8         `json:"property_id"`
	InspectionRequestID pgtype.Int8         `json:"inspection_request_id"`
	ApplicationID       pgtype.Int8         `json:"application_id"`
	MessageType         NullMessageTypeEnum `json:"message_type"`
	Content             string              `json:"content"`
	MediaUrl            pgtype.Text         `json:"media_url"`
	IsRead              pgtype.Bool         `json:"is_read"`
	ReadAt              pgtype.Timestamptz  `json:"read_at"`
	CreatedAt           pgtype.Timestamptz  `json:"created_at"`
	SenderFirstName     string              `json:"sender_first_name"`
	SenderLastName      string              `json:"sender_last_name"`
	RecipientFirstName  string              `json:"recipient_first_name"`
	RecipientLastName   string              `json:"recipient_last_name"`
}

// Get recent messages for user
func (q *Queries) GetRecentMessages(ctx context.Context, arg GetRecentMessagesParams) ([]GetRecentMessagesRow, error) {
	rows, err := q.db.Query(ctx, getRecentMessages, arg.SenderID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecentMessagesRow{}
	for rows.Next() {
		var i GetRecentMessagesRow
		if err := rows.Scan(
			&i.ID,
			&i.SenderID,
			&i.RecipientID,
			&i.PropertyID,
			&i.InspectionRequestID,
			&i.ApplicationID,
			&i.MessageType,
			&i.Content,
			&i.MediaUrl,
			&i.IsRead,
			&i.ReadAt,
			&i.CreatedAt,
			&i.SenderFirstName,
			&i.SenderLastName,
			&i.RecipientFirstName,
			&i.RecipientLastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnreadMessages = `-- name: GetUnreadMessages :many
SELECT m.id, m.sender_id, m.recipient_id, m.property_id, m.inspection_request_id, m.application_id, m.message_type, m.content, m.media_url, m.is_read, m.read_at, m.created_at, s.first_name as sender_first_name, s.last_name as sender_last_name, s.profile_picture_url
FROM messages m
JOIN users s ON m.sender_id = s.id
WHERE m.recipient_id = $1 AND m.is_read = false
ORDER BY m.created_at DESC
LIMIT $2 OFFSET $3
`

type GetUnreadMessagesParams struct {
	RecipientID int64 `json:"recipient_id"`
	Limit       int32 `json:"limit"`
	Offset      int32 `json:"offset"`
}

type GetUnreadMessagesRow struct {
	ID                  int64               `json:"id"`
	SenderID            int64               `json:"sender_id"`
	RecipientID         int64               `json:"recipient_id"`
	PropertyID          pgtype.Int8         `json:"property_id"`
	InspectionRequestID pgtype.Int8         `json:"inspection_request_id"`
	ApplicationID       pgtype.Int8         `json:"application_id"`
	MessageType         NullMessageTypeEnum `json:"message_type"`
	Content             string              `json:"content"`
	MediaUrl            pgtype.Text         `json:"media_url"`
	IsRead              pgtype.Bool         `json:"is_read"`
	ReadAt              pgtype.Timestamptz  `json:"read_at"`
	CreatedAt           pgtype.Timestamptz  `json:"created_at"`
	SenderFirstName     string              `json:"sender_first_name"`
	SenderLastName      string              `json:"sender_last_name"`
	ProfilePictureUrl   pgtype.Text         `json:"profile_picture_url"`
}

// Get unread messages for user
func (q *Queries) GetUnreadMessages(ctx context.Context, arg GetUnreadMessagesParams) ([]GetUnreadMessagesRow, error) {
	rows, err := q.db.Query(ctx, getUnreadMessages, arg.RecipientID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUnreadMessagesRow{}
	for rows.Next() {
		var i GetUnreadMessagesRow
		if err := rows.Scan(
			&i.ID,
			&i.SenderID,
			&i.RecipientID,
			&i.PropertyID,
			&i.InspectionRequestID,
			&i.ApplicationID,
			&i.MessageType,
			&i.Content,
			&i.MediaUrl,
			&i.IsRead,
			&i.ReadAt,
			&i.CreatedAt,
			&i.SenderFirstName,
			&i.SenderLastName,
			&i.ProfilePictureUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserConversations = `-- name: GetUserConversations :many
SELECT DISTINCT ON (
  CASE 
    WHEN m.sender_id = $1 THEN m.recipient_id 
    ELSE m.sender_id 
  END
) 
  CASE 
    WHEN m.sender_id = $1 THEN m.recipient_id 
    ELSE m.sender_id 
  END as other_user_id,
  u.first_name, u.last_name, u.profile_picture_url,
  m.content as last_message,
  m.created_at as last_message_time,
  m.is_read,
  COUNT(CASE WHEN m.recipient_id = $1 AND m.is_read = false THEN 1 END) OVER (
    PARTITION BY CASE WHEN m.sender_id = $1 THEN m.recipient_id ELSE m.sender_id END
  ) as unread_count
FROM messages m
JOIN users u ON u.id = CASE WHEN m.sender_id = $1 THEN m.recipient_id ELSE m.sender_id END
WHERE m.sender_id = $1 OR m.recipient_id = $1
ORDER BY 
  CASE 
    WHEN m.sender_id = $1 THEN m.recipient_id 
    ELSE m.sender_id 
  END,
  m.created_at DESC
LIMIT $2 OFFSET $3
`

type GetUserConversationsParams struct {
	SenderID int64 `json:"sender_id"`
	Limit    int32 `json:"limit"`
	Offset   int32 `json:"offset"`
}

type GetUserConversationsRow struct {
	OtherUserID       interface{}        `json:"other_user_id"`
	FirstName         string             `json:"first_name"`
	LastName          string             `json:"last_name"`
	ProfilePictureUrl pgtype.Text        `json:"profile_picture_url"`
	LastMessage       string             `json:"last_message"`
	LastMessageTime   pgtype.Timestamptz `json:"last_message_time"`
	IsRead            pgtype.Bool        `json:"is_read"`
	UnreadCount       int64              `json:"unread_count"`
}

// Get user's conversations (distinct recipients)
func (q *Queries) GetUserConversations(ctx context.Context, arg GetUserConversationsParams) ([]GetUserConversationsRow, error) {
	rows, err := q.db.Query(ctx, getUserConversations, arg.SenderID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserConversationsRow{}
	for rows.Next() {
		var i GetUserConversationsRow
		if err := rows.Scan(
			&i.OtherUserID,
			&i.FirstName,
			&i.LastName,
			&i.ProfilePictureUrl,
			&i.LastMessage,
			&i.LastMessageTime,
			&i.IsRead,
			&i.UnreadCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markMessageAsRead = `-- name: MarkMessageAsRead :exec
UPDATE messages 
SET is_read = true, read_at = NOW()
WHERE id = $1
`

// Mark message as read
func (q *Queries) MarkMessageAsRead(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, markMessageAsRead, id)
	return err
}

const markMessagesAsRead = `-- name: MarkMessagesAsRead :exec
UPDATE messages 
SET is_read = true, read_at = NOW()
WHERE id = ANY($1::bigint[])
`

// Mark multiple messages as read
func (q *Queries) MarkMessagesAsRead(ctx context.Context, dollar_1 []int64) error {
	_, err := q.db.Exec(ctx, markMessagesAsRead, dollar_1)
	return err
}

const searchMessages = `-- name: SearchMessages :many
SELECT m.id, m.sender_id, m.recipient_id, m.property_id, m.inspection_request_id, m.application_id, m.message_type, m.content, m.media_url, m.is_read, m.read_at, m.created_at, s.first_name as sender_first_name, s.last_name as sender_last_name
FROM messages m
JOIN users s ON m.sender_id = s.id
WHERE (m.sender_id = $1 OR m.recipient_id = $1) 
  AND m.content ILIKE '%' || $2 || '%'
ORDER BY m.created_at DESC
LIMIT $3 OFFSET $4
`

type SearchMessagesParams struct {
	SenderID int64       `json:"sender_id"`
	Column2  pgtype.Text `json:"column_2"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

type SearchMessagesRow struct {
	ID                  int64               `json:"id"`
	SenderID            int64               `json:"sender_id"`
	RecipientID         int64               `json:"recipient_id"`
	PropertyID          pgtype.Int8         `json:"property_id"`
	InspectionRequestID pgtype.Int8         `json:"inspection_request_id"`
	ApplicationID       pgtype.Int8         `json:"application_id"`
	MessageType         NullMessageTypeEnum `json:"message_type"`
	Content             string              `json:"content"`
	MediaUrl            pgtype.Text         `json:"media_url"`
	IsRead              pgtype.Bool         `json:"is_read"`
	ReadAt              pgtype.Timestamptz  `json:"read_at"`
	CreatedAt           pgtype.Timestamptz  `json:"created_at"`
	SenderFirstName     string              `json:"sender_first_name"`
	SenderLastName      string              `json:"sender_last_name"`
}

// Search messages
func (q *Queries) SearchMessages(ctx context.Context, arg SearchMessagesParams) ([]SearchMessagesRow, error) {
	rows, err := q.db.Query(ctx, searchMessages,
		arg.SenderID,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchMessagesRow{}
	for rows.Next() {
		var i SearchMessagesRow
		if err := rows.Scan(
			&i.ID,
			&i.SenderID,
			&i.RecipientID,
			&i.PropertyID,
			&i.InspectionRequestID,
			&i.ApplicationID,
			&i.MessageType,
			&i.Content,
			&i.MediaUrl,
			&i.IsRead,
			&i.ReadAt,
			&i.CreatedAt,
			&i.SenderFirstName,
			&i.SenderLastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
