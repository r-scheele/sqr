// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: property_search_cache.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkSearchCached = `-- name: CheckSearchCached :one
SELECT EXISTS(
  SELECT 1 FROM property_search_cache 
  WHERE search_hash = $1 AND expires_at > NOW()
)
`

// Check if search is cached
func (q *Queries) CheckSearchCached(ctx context.Context, searchHash string) (bool, error) {
	row := q.db.QueryRow(ctx, checkSearchCached, searchHash)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const cleanupExpiredCache = `-- name: CleanupExpiredCache :exec
DELETE FROM property_search_cache 
WHERE expires_at <= NOW()
`

// Clean up expired cache entries
func (q *Queries) CleanupExpiredCache(ctx context.Context) error {
	_, err := q.db.Exec(ctx, cleanupExpiredCache)
	return err
}

const cleanupOldCache = `-- name: CleanupOldCache :exec
DELETE FROM property_search_cache 
WHERE created_at < $1
`

// Clean up old cache entries
func (q *Queries) CleanupOldCache(ctx context.Context, createdAt pgtype.Timestamptz) error {
	_, err := q.db.Exec(ctx, cleanupOldCache, createdAt)
	return err
}

const countActiveCacheEntries = `-- name: CountActiveCacheEntries :one
SELECT COUNT(*) FROM property_search_cache 
WHERE expires_at > NOW()
`

// Count active cache entries
func (q *Queries) CountActiveCacheEntries(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countActiveCacheEntries)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countExpiredCacheEntries = `-- name: CountExpiredCacheEntries :one
SELECT COUNT(*) FROM property_search_cache 
WHERE expires_at <= NOW()
`

// Count expired cache entries
func (q *Queries) CountExpiredCacheEntries(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countExpiredCacheEntries)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countTotalCacheEntries = `-- name: CountTotalCacheEntries :one
SELECT COUNT(*) FROM property_search_cache
`

// Count total cache entries
func (q *Queries) CountTotalCacheEntries(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countTotalCacheEntries)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPropertySearchCache = `-- name: CreatePropertySearchCache :one
INSERT INTO property_search_cache (
  search_hash, search_params, property_ids, result_count, expires_at
) VALUES (
  $1, $2, $3, $4, $5
) RETURNING id, search_hash, search_params, property_ids, result_count, expires_at, created_at
`

type CreatePropertySearchCacheParams struct {
	SearchHash   string      `json:"search_hash"`
	SearchParams pgtype.Text `json:"search_params"`
	PropertyIds  pgtype.Text `json:"property_ids"`
	ResultCount  int32       `json:"result_count"`
	ExpiresAt    time.Time   `json:"expires_at"`
}

// Create property search cache
func (q *Queries) CreatePropertySearchCache(ctx context.Context, arg CreatePropertySearchCacheParams) (PropertySearchCache, error) {
	row := q.db.QueryRow(ctx, createPropertySearchCache,
		arg.SearchHash,
		arg.SearchParams,
		arg.PropertyIds,
		arg.ResultCount,
		arg.ExpiresAt,
	)
	var i PropertySearchCache
	err := row.Scan(
		&i.ID,
		&i.SearchHash,
		&i.SearchParams,
		&i.PropertyIds,
		&i.ResultCount,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const deleteCacheBySearchHash = `-- name: DeleteCacheBySearchHash :exec
DELETE FROM property_search_cache 
WHERE search_hash = $1
`

// Delete cache by search hash
func (q *Queries) DeleteCacheBySearchHash(ctx context.Context, searchHash string) error {
	_, err := q.db.Exec(ctx, deleteCacheBySearchHash, searchHash)
	return err
}

const deletePropertySearchCache = `-- name: DeletePropertySearchCache :exec
DELETE FROM property_search_cache 
WHERE id = $1
`

// Delete property search cache
func (q *Queries) DeletePropertySearchCache(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deletePropertySearchCache, id)
	return err
}

const extendCacheExpiry = `-- name: ExtendCacheExpiry :one
UPDATE property_search_cache 
SET expires_at = $2
WHERE search_hash = $1 
RETURNING id, search_hash, search_params, property_ids, result_count, expires_at, created_at
`

type ExtendCacheExpiryParams struct {
	SearchHash string    `json:"search_hash"`
	ExpiresAt  time.Time `json:"expires_at"`
}

// Extend cache expiry
func (q *Queries) ExtendCacheExpiry(ctx context.Context, arg ExtendCacheExpiryParams) (PropertySearchCache, error) {
	row := q.db.QueryRow(ctx, extendCacheExpiry, arg.SearchHash, arg.ExpiresAt)
	var i PropertySearchCache
	err := row.Scan(
		&i.ID,
		&i.SearchHash,
		&i.SearchParams,
		&i.PropertyIds,
		&i.ResultCount,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getActiveCacheEntries = `-- name: GetActiveCacheEntries :many
SELECT id, search_hash, search_params, property_ids, result_count, expires_at, created_at FROM property_search_cache 
WHERE expires_at > NOW()
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type GetActiveCacheEntriesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

// Get active cache entries
func (q *Queries) GetActiveCacheEntries(ctx context.Context, arg GetActiveCacheEntriesParams) ([]PropertySearchCache, error) {
	rows, err := q.db.Query(ctx, getActiveCacheEntries, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PropertySearchCache{}
	for rows.Next() {
		var i PropertySearchCache
		if err := rows.Scan(
			&i.ID,
			&i.SearchHash,
			&i.SearchParams,
			&i.PropertyIds,
			&i.ResultCount,
			&i.ExpiresAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCacheBySearchHash = `-- name: GetCacheBySearchHash :one
SELECT id, search_hash, search_params, property_ids, result_count, expires_at, created_at FROM property_search_cache 
WHERE search_hash = $1 AND expires_at > NOW()
LIMIT 1
`

// Get cache by search hash
func (q *Queries) GetCacheBySearchHash(ctx context.Context, searchHash string) (PropertySearchCache, error) {
	row := q.db.QueryRow(ctx, getCacheBySearchHash, searchHash)
	var i PropertySearchCache
	err := row.Scan(
		&i.ID,
		&i.SearchHash,
		&i.SearchParams,
		&i.PropertyIds,
		&i.ResultCount,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getCacheEntriesByResultCount = `-- name: GetCacheEntriesByResultCount :many
SELECT id, search_hash, search_params, property_ids, result_count, expires_at, created_at FROM property_search_cache 
WHERE result_count >= $1 AND expires_at > NOW()
ORDER BY result_count DESC, created_at DESC
LIMIT $2 OFFSET $3
`

type GetCacheEntriesByResultCountParams struct {
	ResultCount int32 `json:"result_count"`
	Limit       int32 `json:"limit"`
	Offset      int32 `json:"offset"`
}

// Get cache entries by result count
func (q *Queries) GetCacheEntriesByResultCount(ctx context.Context, arg GetCacheEntriesByResultCountParams) ([]PropertySearchCache, error) {
	rows, err := q.db.Query(ctx, getCacheEntriesByResultCount, arg.ResultCount, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PropertySearchCache{}
	for rows.Next() {
		var i PropertySearchCache
		if err := rows.Scan(
			&i.ID,
			&i.SearchHash,
			&i.SearchParams,
			&i.PropertyIds,
			&i.ResultCount,
			&i.ExpiresAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCacheHitStatistics = `-- name: GetCacheHitStatistics :one
SELECT 
  COUNT(DISTINCT search_hash) as unique_searches,
  COUNT(*) as total_cache_entries,
  AVG(result_count) as average_results,
  SUM(CASE WHEN expires_at > NOW() THEN 1 ELSE 0 END) as active_caches
FROM property_search_cache 
WHERE created_at >= $1
`

type GetCacheHitStatisticsRow struct {
	UniqueSearches    int64   `json:"unique_searches"`
	TotalCacheEntries int64   `json:"total_cache_entries"`
	AverageResults    float64 `json:"average_results"`
	ActiveCaches      int64   `json:"active_caches"`
}

// Get cache hit statistics
func (q *Queries) GetCacheHitStatistics(ctx context.Context, createdAt pgtype.Timestamptz) (GetCacheHitStatisticsRow, error) {
	row := q.db.QueryRow(ctx, getCacheHitStatistics, createdAt)
	var i GetCacheHitStatisticsRow
	err := row.Scan(
		&i.UniqueSearches,
		&i.TotalCacheEntries,
		&i.AverageResults,
		&i.ActiveCaches,
	)
	return i, err
}

const getCacheStatistics = `-- name: GetCacheStatistics :one
SELECT 
  COUNT(*) as total_entries,
  COUNT(CASE WHEN expires_at > NOW() THEN 1 END) as active_entries,
  COUNT(CASE WHEN expires_at <= NOW() THEN 1 END) as expired_entries,
  AVG(result_count) as average_result_count,
  MAX(result_count) as max_result_count,
  MIN(result_count) as min_result_count
FROM property_search_cache
`

type GetCacheStatisticsRow struct {
	TotalEntries       int64       `json:"total_entries"`
	ActiveEntries      int64       `json:"active_entries"`
	ExpiredEntries     int64       `json:"expired_entries"`
	AverageResultCount float64     `json:"average_result_count"`
	MaxResultCount     interface{} `json:"max_result_count"`
	MinResultCount     interface{} `json:"min_result_count"`
}

// Get cache statistics
func (q *Queries) GetCacheStatistics(ctx context.Context) (GetCacheStatisticsRow, error) {
	row := q.db.QueryRow(ctx, getCacheStatistics)
	var i GetCacheStatisticsRow
	err := row.Scan(
		&i.TotalEntries,
		&i.ActiveEntries,
		&i.ExpiredEntries,
		&i.AverageResultCount,
		&i.MaxResultCount,
		&i.MinResultCount,
	)
	return i, err
}

const getExpiredCacheEntries = `-- name: GetExpiredCacheEntries :many
SELECT id, search_hash, search_params, property_ids, result_count, expires_at, created_at FROM property_search_cache 
WHERE expires_at <= NOW()
ORDER BY expires_at ASC
LIMIT $1 OFFSET $2
`

type GetExpiredCacheEntriesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

// Get expired cache entries
func (q *Queries) GetExpiredCacheEntries(ctx context.Context, arg GetExpiredCacheEntriesParams) ([]PropertySearchCache, error) {
	rows, err := q.db.Query(ctx, getExpiredCacheEntries, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PropertySearchCache{}
	for rows.Next() {
		var i PropertySearchCache
		if err := rows.Scan(
			&i.ID,
			&i.SearchHash,
			&i.SearchParams,
			&i.PropertyIds,
			&i.ResultCount,
			&i.ExpiresAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMostCachedSearches = `-- name: GetMostCachedSearches :many
SELECT 
  search_params,
  COUNT(*) as cache_count,
  AVG(result_count) as avg_results,
  MAX(created_at) as last_cached
FROM property_search_cache 
WHERE created_at >= $1
GROUP BY search_params
ORDER BY cache_count DESC, avg_results DESC
LIMIT $2 OFFSET $3
`

type GetMostCachedSearchesParams struct {
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	Limit     int32              `json:"limit"`
	Offset    int32              `json:"offset"`
}

type GetMostCachedSearchesRow struct {
	SearchParams pgtype.Text `json:"search_params"`
	CacheCount   int64       `json:"cache_count"`
	AvgResults   float64     `json:"avg_results"`
	LastCached   interface{} `json:"last_cached"`
}

// Get most cached searches
func (q *Queries) GetMostCachedSearches(ctx context.Context, arg GetMostCachedSearchesParams) ([]GetMostCachedSearchesRow, error) {
	rows, err := q.db.Query(ctx, getMostCachedSearches, arg.CreatedAt, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMostCachedSearchesRow{}
	for rows.Next() {
		var i GetMostCachedSearchesRow
		if err := rows.Scan(
			&i.SearchParams,
			&i.CacheCount,
			&i.AvgResults,
			&i.LastCached,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPopularSearchCaches = `-- name: GetPopularSearchCaches :many
SELECT search_hash, search_params, result_count, COUNT(*) as access_count
FROM property_search_cache 
WHERE created_at >= $1
GROUP BY search_hash, search_params, result_count
ORDER BY access_count DESC, result_count DESC
LIMIT $2 OFFSET $3
`

type GetPopularSearchCachesParams struct {
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	Limit     int32              `json:"limit"`
	Offset    int32              `json:"offset"`
}

type GetPopularSearchCachesRow struct {
	SearchHash   string      `json:"search_hash"`
	SearchParams pgtype.Text `json:"search_params"`
	ResultCount  int32       `json:"result_count"`
	AccessCount  int64       `json:"access_count"`
}

// Get popular search caches
func (q *Queries) GetPopularSearchCaches(ctx context.Context, arg GetPopularSearchCachesParams) ([]GetPopularSearchCachesRow, error) {
	rows, err := q.db.Query(ctx, getPopularSearchCaches, arg.CreatedAt, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPopularSearchCachesRow{}
	for rows.Next() {
		var i GetPopularSearchCachesRow
		if err := rows.Scan(
			&i.SearchHash,
			&i.SearchParams,
			&i.ResultCount,
			&i.AccessCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPropertySearchCacheByID = `-- name: GetPropertySearchCacheByID :one
SELECT id, search_hash, search_params, property_ids, result_count, expires_at, created_at FROM property_search_cache 
WHERE id = $1 LIMIT 1
`

// Get property search cache by ID
func (q *Queries) GetPropertySearchCacheByID(ctx context.Context, id int64) (PropertySearchCache, error) {
	row := q.db.QueryRow(ctx, getPropertySearchCacheByID, id)
	var i PropertySearchCache
	err := row.Scan(
		&i.ID,
		&i.SearchHash,
		&i.SearchParams,
		&i.PropertyIds,
		&i.ResultCount,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const searchCacheEntries = `-- name: SearchCacheEntries :many
SELECT id, search_hash, search_params, property_ids, result_count, expires_at, created_at FROM property_search_cache 
WHERE search_params ILIKE '%' || $1 || '%'
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type SearchCacheEntriesParams struct {
	Column1 pgtype.Text `json:"column_1"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

// Search cache entries
func (q *Queries) SearchCacheEntries(ctx context.Context, arg SearchCacheEntriesParams) ([]PropertySearchCache, error) {
	rows, err := q.db.Query(ctx, searchCacheEntries, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PropertySearchCache{}
	for rows.Next() {
		var i PropertySearchCache
		if err := rows.Scan(
			&i.ID,
			&i.SearchHash,
			&i.SearchParams,
			&i.PropertyIds,
			&i.ResultCount,
			&i.ExpiresAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSearchCache = `-- name: UpdateSearchCache :one
UPDATE property_search_cache 
SET property_ids = $2, result_count = $3, expires_at = $4
WHERE search_hash = $1 
RETURNING id, search_hash, search_params, property_ids, result_count, expires_at, created_at
`

type UpdateSearchCacheParams struct {
	SearchHash  string      `json:"search_hash"`
	PropertyIds pgtype.Text `json:"property_ids"`
	ResultCount int32       `json:"result_count"`
	ExpiresAt   time.Time   `json:"expires_at"`
}

// Update search cache
func (q *Queries) UpdateSearchCache(ctx context.Context, arg UpdateSearchCacheParams) (PropertySearchCache, error) {
	row := q.db.QueryRow(ctx, updateSearchCache,
		arg.SearchHash,
		arg.PropertyIds,
		arg.ResultCount,
		arg.ExpiresAt,
	)
	var i PropertySearchCache
	err := row.Scan(
		&i.ID,
		&i.SearchHash,
		&i.SearchParams,
		&i.PropertyIds,
		&i.ResultCount,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}
