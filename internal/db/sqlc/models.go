// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0

package db

import (
	"database/sql/driver"
	"fmt"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

type AgreementStatusEnum string

const (
	AgreementStatusEnumDraft             AgreementStatusEnum = "draft"
	AgreementStatusEnumPendingSignatures AgreementStatusEnum = "pending_signatures"
	AgreementStatusEnumActive            AgreementStatusEnum = "active"
	AgreementStatusEnumCompleted         AgreementStatusEnum = "completed"
	AgreementStatusEnumTerminated        AgreementStatusEnum = "terminated"
)

func (e *AgreementStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AgreementStatusEnum(s)
	case string:
		*e = AgreementStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for AgreementStatusEnum: %T", src)
	}
	return nil
}

type NullAgreementStatusEnum struct {
	AgreementStatusEnum AgreementStatusEnum `json:"agreement_status_enum"`
	Valid               bool                `json:"valid"` // Valid is true if AgreementStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAgreementStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.AgreementStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AgreementStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAgreementStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AgreementStatusEnum), nil
}

type ApplicationStatusEnum string

const (
	ApplicationStatusEnumSubmitted   ApplicationStatusEnum = "submitted"
	ApplicationStatusEnumUnderReview ApplicationStatusEnum = "under_review"
	ApplicationStatusEnumApproved    ApplicationStatusEnum = "approved"
	ApplicationStatusEnumRejected    ApplicationStatusEnum = "rejected"
	ApplicationStatusEnumWithdrawn   ApplicationStatusEnum = "withdrawn"
)

func (e *ApplicationStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ApplicationStatusEnum(s)
	case string:
		*e = ApplicationStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for ApplicationStatusEnum: %T", src)
	}
	return nil
}

type NullApplicationStatusEnum struct {
	ApplicationStatusEnum ApplicationStatusEnum `json:"application_status_enum"`
	Valid                 bool                  `json:"valid"` // Valid is true if ApplicationStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullApplicationStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.ApplicationStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ApplicationStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullApplicationStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ApplicationStatusEnum), nil
}

type AuditActionEnum string

const (
	AuditActionEnumCreate       AuditActionEnum = "create"
	AuditActionEnumUpdate       AuditActionEnum = "update"
	AuditActionEnumDelete       AuditActionEnum = "delete"
	AuditActionEnumLogin        AuditActionEnum = "login"
	AuditActionEnumLogout       AuditActionEnum = "logout"
	AuditActionEnumPayment      AuditActionEnum = "payment"
	AuditActionEnumVerification AuditActionEnum = "verification"
)

func (e *AuditActionEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AuditActionEnum(s)
	case string:
		*e = AuditActionEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for AuditActionEnum: %T", src)
	}
	return nil
}

type NullAuditActionEnum struct {
	AuditActionEnum AuditActionEnum `json:"audit_action_enum"`
	Valid           bool            `json:"valid"` // Valid is true if AuditActionEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAuditActionEnum) Scan(value interface{}) error {
	if value == nil {
		ns.AuditActionEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AuditActionEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAuditActionEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AuditActionEnum), nil
}

type DisputeEntityEnum string

const (
	DisputeEntityEnumProperty          DisputeEntityEnum = "property"
	DisputeEntityEnumInspectionRequest DisputeEntityEnum = "inspection_request"
	DisputeEntityEnumRentalAgreement   DisputeEntityEnum = "rental_agreement"
)

func (e *DisputeEntityEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = DisputeEntityEnum(s)
	case string:
		*e = DisputeEntityEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for DisputeEntityEnum: %T", src)
	}
	return nil
}

type NullDisputeEntityEnum struct {
	DisputeEntityEnum DisputeEntityEnum `json:"dispute_entity_enum"`
	Valid             bool              `json:"valid"` // Valid is true if DisputeEntityEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullDisputeEntityEnum) Scan(value interface{}) error {
	if value == nil {
		ns.DisputeEntityEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.DisputeEntityEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullDisputeEntityEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.DisputeEntityEnum), nil
}

type DisputeStatusEnum string

const (
	DisputeStatusEnumOpen          DisputeStatusEnum = "open"
	DisputeStatusEnumInvestigating DisputeStatusEnum = "investigating"
	DisputeStatusEnumResolved      DisputeStatusEnum = "resolved"
	DisputeStatusEnumClosed        DisputeStatusEnum = "closed"
)

func (e *DisputeStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = DisputeStatusEnum(s)
	case string:
		*e = DisputeStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for DisputeStatusEnum: %T", src)
	}
	return nil
}

type NullDisputeStatusEnum struct {
	DisputeStatusEnum DisputeStatusEnum `json:"dispute_status_enum"`
	Valid             bool              `json:"valid"` // Valid is true if DisputeStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullDisputeStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.DisputeStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.DisputeStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullDisputeStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.DisputeStatusEnum), nil
}

type DisputeTypeEnum string

const (
	DisputeTypeEnumPayment           DisputeTypeEnum = "payment"
	DisputeTypeEnumPropertyCondition DisputeTypeEnum = "property_condition"
	DisputeTypeEnumServiceQuality    DisputeTypeEnum = "service_quality"
	DisputeTypeEnumBreachOfAgreement DisputeTypeEnum = "breach_of_agreement"
	DisputeTypeEnumFraud             DisputeTypeEnum = "fraud"
)

func (e *DisputeTypeEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = DisputeTypeEnum(s)
	case string:
		*e = DisputeTypeEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for DisputeTypeEnum: %T", src)
	}
	return nil
}

type NullDisputeTypeEnum struct {
	DisputeTypeEnum DisputeTypeEnum `json:"dispute_type_enum"`
	Valid           bool            `json:"valid"` // Valid is true if DisputeTypeEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullDisputeTypeEnum) Scan(value interface{}) error {
	if value == nil {
		ns.DisputeTypeEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.DisputeTypeEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullDisputeTypeEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.DisputeTypeEnum), nil
}

type FurnishingStatusEnum string

const (
	FurnishingStatusEnumFurnished     FurnishingStatusEnum = "furnished"
	FurnishingStatusEnumSemiFurnished FurnishingStatusEnum = "semi_furnished"
	FurnishingStatusEnumUnfurnished   FurnishingStatusEnum = "unfurnished"
)

func (e *FurnishingStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = FurnishingStatusEnum(s)
	case string:
		*e = FurnishingStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for FurnishingStatusEnum: %T", src)
	}
	return nil
}

type NullFurnishingStatusEnum struct {
	FurnishingStatusEnum FurnishingStatusEnum `json:"furnishing_status_enum"`
	Valid                bool                 `json:"valid"` // Valid is true if FurnishingStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullFurnishingStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.FurnishingStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.FurnishingStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullFurnishingStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.FurnishingStatusEnum), nil
}

type InquiryStatusEnum string

const (
	InquiryStatusEnumSent      InquiryStatusEnum = "sent"
	InquiryStatusEnumRead      InquiryStatusEnum = "read"
	InquiryStatusEnumResponded InquiryStatusEnum = "responded"
	InquiryStatusEnumClosed    InquiryStatusEnum = "closed"
)

func (e *InquiryStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = InquiryStatusEnum(s)
	case string:
		*e = InquiryStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for InquiryStatusEnum: %T", src)
	}
	return nil
}

type NullInquiryStatusEnum struct {
	InquiryStatusEnum InquiryStatusEnum `json:"inquiry_status_enum"`
	Valid             bool              `json:"valid"` // Valid is true if InquiryStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullInquiryStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.InquiryStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.InquiryStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullInquiryStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.InquiryStatusEnum), nil
}

type InquiryTypeEnum string

const (
	InquiryTypeEnumGeneral        InquiryTypeEnum = "general"
	InquiryTypeEnumViewingRequest InquiryTypeEnum = "viewing_request"
	InquiryTypeEnumApplication    InquiryTypeEnum = "application"
)

func (e *InquiryTypeEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = InquiryTypeEnum(s)
	case string:
		*e = InquiryTypeEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for InquiryTypeEnum: %T", src)
	}
	return nil
}

type NullInquiryTypeEnum struct {
	InquiryTypeEnum InquiryTypeEnum `json:"inquiry_type_enum"`
	Valid           bool            `json:"valid"` // Valid is true if InquiryTypeEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullInquiryTypeEnum) Scan(value interface{}) error {
	if value == nil {
		ns.InquiryTypeEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.InquiryTypeEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullInquiryTypeEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.InquiryTypeEnum), nil
}

type InspectionStatusEnum string

const (
	InspectionStatusEnumPending       InspectionStatusEnum = "pending"
	InspectionStatusEnumConfirmed     InspectionStatusEnum = "confirmed"
	InspectionStatusEnumAgentAssigned InspectionStatusEnum = "agent_assigned"
	InspectionStatusEnumCompleted     InspectionStatusEnum = "completed"
	InspectionStatusEnumCancelled     InspectionStatusEnum = "cancelled"
	InspectionStatusEnumRefunded      InspectionStatusEnum = "refunded"
)

func (e *InspectionStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = InspectionStatusEnum(s)
	case string:
		*e = InspectionStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for InspectionStatusEnum: %T", src)
	}
	return nil
}

type NullInspectionStatusEnum struct {
	InspectionStatusEnum InspectionStatusEnum `json:"inspection_status_enum"`
	Valid                bool                 `json:"valid"` // Valid is true if InspectionStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullInspectionStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.InspectionStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.InspectionStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullInspectionStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.InspectionStatusEnum), nil
}

type InspectionTypeEnum string

const (
	InspectionTypeEnumSelfInspection  InspectionTypeEnum = "self_inspection"
	InspectionTypeEnumAgentInspection InspectionTypeEnum = "agent_inspection"
)

func (e *InspectionTypeEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = InspectionTypeEnum(s)
	case string:
		*e = InspectionTypeEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for InspectionTypeEnum: %T", src)
	}
	return nil
}

type NullInspectionTypeEnum struct {
	InspectionTypeEnum InspectionTypeEnum `json:"inspection_type_enum"`
	Valid              bool               `json:"valid"` // Valid is true if InspectionTypeEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullInspectionTypeEnum) Scan(value interface{}) error {
	if value == nil {
		ns.InspectionTypeEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.InspectionTypeEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullInspectionTypeEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.InspectionTypeEnum), nil
}

type MediaTypeEnum string

const (
	MediaTypeEnumImage       MediaTypeEnum = "image"
	MediaTypeEnumVideo       MediaTypeEnum = "video"
	MediaTypeEnumVirtualTour MediaTypeEnum = "virtual_tour"
)

func (e *MediaTypeEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = MediaTypeEnum(s)
	case string:
		*e = MediaTypeEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for MediaTypeEnum: %T", src)
	}
	return nil
}

type NullMediaTypeEnum struct {
	MediaTypeEnum MediaTypeEnum `json:"media_type_enum"`
	Valid         bool          `json:"valid"` // Valid is true if MediaTypeEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullMediaTypeEnum) Scan(value interface{}) error {
	if value == nil {
		ns.MediaTypeEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.MediaTypeEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullMediaTypeEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.MediaTypeEnum), nil
}

type MessageTypeEnum string

const (
	MessageTypeEnumText     MessageTypeEnum = "text"
	MessageTypeEnumImage    MessageTypeEnum = "image"
	MessageTypeEnumDocument MessageTypeEnum = "document"
	MessageTypeEnumSystem   MessageTypeEnum = "system"
)

func (e *MessageTypeEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = MessageTypeEnum(s)
	case string:
		*e = MessageTypeEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for MessageTypeEnum: %T", src)
	}
	return nil
}

type NullMessageTypeEnum struct {
	MessageTypeEnum MessageTypeEnum `json:"message_type_enum"`
	Valid           bool            `json:"valid"` // Valid is true if MessageTypeEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullMessageTypeEnum) Scan(value interface{}) error {
	if value == nil {
		ns.MessageTypeEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.MessageTypeEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullMessageTypeEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.MessageTypeEnum), nil
}

type NotificationEntityEnum string

const (
	NotificationEntityEnumProperty          NotificationEntityEnum = "property"
	NotificationEntityEnumInspectionRequest NotificationEntityEnum = "inspection_request"
	NotificationEntityEnumRentalApplication NotificationEntityEnum = "rental_application"
	NotificationEntityEnumMessage           NotificationEntityEnum = "message"
)

func (e *NotificationEntityEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = NotificationEntityEnum(s)
	case string:
		*e = NotificationEntityEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for NotificationEntityEnum: %T", src)
	}
	return nil
}

type NullNotificationEntityEnum struct {
	NotificationEntityEnum NotificationEntityEnum `json:"notification_entity_enum"`
	Valid                  bool                   `json:"valid"` // Valid is true if NotificationEntityEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullNotificationEntityEnum) Scan(value interface{}) error {
	if value == nil {
		ns.NotificationEntityEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.NotificationEntityEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullNotificationEntityEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.NotificationEntityEnum), nil
}

type NotificationTypeEnum string

const (
	NotificationTypeEnumInspectionScheduled NotificationTypeEnum = "inspection_scheduled"
	NotificationTypeEnumApplicationStatus   NotificationTypeEnum = "application_status"
	NotificationTypeEnumPaymentReceived     NotificationTypeEnum = "payment_received"
	NotificationTypeEnumMessageReceived     NotificationTypeEnum = "message_received"
	NotificationTypeEnumSystemAlert         NotificationTypeEnum = "system_alert"
)

func (e *NotificationTypeEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = NotificationTypeEnum(s)
	case string:
		*e = NotificationTypeEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for NotificationTypeEnum: %T", src)
	}
	return nil
}

type NullNotificationTypeEnum struct {
	NotificationTypeEnum NotificationTypeEnum `json:"notification_type_enum"`
	Valid                bool                 `json:"valid"` // Valid is true if NotificationTypeEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullNotificationTypeEnum) Scan(value interface{}) error {
	if value == nil {
		ns.NotificationTypeEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.NotificationTypeEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullNotificationTypeEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.NotificationTypeEnum), nil
}

type OverallConditionEnum string

const (
	OverallConditionEnumExcellent OverallConditionEnum = "excellent"
	OverallConditionEnumGood      OverallConditionEnum = "good"
	OverallConditionEnumFair      OverallConditionEnum = "fair"
	OverallConditionEnumPoor      OverallConditionEnum = "poor"
)

func (e *OverallConditionEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = OverallConditionEnum(s)
	case string:
		*e = OverallConditionEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for OverallConditionEnum: %T", src)
	}
	return nil
}

type NullOverallConditionEnum struct {
	OverallConditionEnum OverallConditionEnum `json:"overall_condition_enum"`
	Valid                bool                 `json:"valid"` // Valid is true if OverallConditionEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullOverallConditionEnum) Scan(value interface{}) error {
	if value == nil {
		ns.OverallConditionEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.OverallConditionEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullOverallConditionEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.OverallConditionEnum), nil
}

type PaymentMethodEnum string

const (
	PaymentMethodEnumCard         PaymentMethodEnum = "card"
	PaymentMethodEnumBankTransfer PaymentMethodEnum = "bank_transfer"
	PaymentMethodEnumWallet       PaymentMethodEnum = "wallet"
	PaymentMethodEnumUssd         PaymentMethodEnum = "ussd"
)

func (e *PaymentMethodEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PaymentMethodEnum(s)
	case string:
		*e = PaymentMethodEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for PaymentMethodEnum: %T", src)
	}
	return nil
}

type NullPaymentMethodEnum struct {
	PaymentMethodEnum PaymentMethodEnum `json:"payment_method_enum"`
	Valid             bool              `json:"valid"` // Valid is true if PaymentMethodEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPaymentMethodEnum) Scan(value interface{}) error {
	if value == nil {
		ns.PaymentMethodEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PaymentMethodEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPaymentMethodEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PaymentMethodEnum), nil
}

type PaymentStatusEnum string

const (
	PaymentStatusEnumPending  PaymentStatusEnum = "pending"
	PaymentStatusEnumPaid     PaymentStatusEnum = "paid"
	PaymentStatusEnumRefunded PaymentStatusEnum = "refunded"
)

func (e *PaymentStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PaymentStatusEnum(s)
	case string:
		*e = PaymentStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for PaymentStatusEnum: %T", src)
	}
	return nil
}

type NullPaymentStatusEnum struct {
	PaymentStatusEnum PaymentStatusEnum `json:"payment_status_enum"`
	Valid             bool              `json:"valid"` // Valid is true if PaymentStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPaymentStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.PaymentStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PaymentStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPaymentStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PaymentStatusEnum), nil
}

type PaymentStatusFullEnum string

const (
	PaymentStatusFullEnumPending    PaymentStatusFullEnum = "pending"
	PaymentStatusFullEnumProcessing PaymentStatusFullEnum = "processing"
	PaymentStatusFullEnumCompleted  PaymentStatusFullEnum = "completed"
	PaymentStatusFullEnumFailed     PaymentStatusFullEnum = "failed"
	PaymentStatusFullEnumRefunded   PaymentStatusFullEnum = "refunded"
	PaymentStatusFullEnumCancelled  PaymentStatusFullEnum = "cancelled"
)

func (e *PaymentStatusFullEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PaymentStatusFullEnum(s)
	case string:
		*e = PaymentStatusFullEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for PaymentStatusFullEnum: %T", src)
	}
	return nil
}

type NullPaymentStatusFullEnum struct {
	PaymentStatusFullEnum PaymentStatusFullEnum `json:"payment_status_full_enum"`
	Valid                 bool                  `json:"valid"` // Valid is true if PaymentStatusFullEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPaymentStatusFullEnum) Scan(value interface{}) error {
	if value == nil {
		ns.PaymentStatusFullEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PaymentStatusFullEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPaymentStatusFullEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PaymentStatusFullEnum), nil
}

type PaymentTypeEnum string

const (
	PaymentTypeEnumInspectionFee  PaymentTypeEnum = "inspection_fee"
	PaymentTypeEnumApplicationFee PaymentTypeEnum = "application_fee"
	PaymentTypeEnumRent           PaymentTypeEnum = "rent"
	PaymentTypeEnumDeposit        PaymentTypeEnum = "deposit"
	PaymentTypeEnumRefund         PaymentTypeEnum = "refund"
)

func (e *PaymentTypeEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PaymentTypeEnum(s)
	case string:
		*e = PaymentTypeEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for PaymentTypeEnum: %T", src)
	}
	return nil
}

type NullPaymentTypeEnum struct {
	PaymentTypeEnum PaymentTypeEnum `json:"payment_type_enum"`
	Valid           bool            `json:"valid"` // Valid is true if PaymentTypeEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPaymentTypeEnum) Scan(value interface{}) error {
	if value == nil {
		ns.PaymentTypeEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PaymentTypeEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPaymentTypeEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PaymentTypeEnum), nil
}

type PropertyStatusEnum string

const (
	PropertyStatusEnumDraft    PropertyStatusEnum = "draft"
	PropertyStatusEnumActive   PropertyStatusEnum = "active"
	PropertyStatusEnumRented   PropertyStatusEnum = "rented"
	PropertyStatusEnumInactive PropertyStatusEnum = "inactive"
)

func (e *PropertyStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PropertyStatusEnum(s)
	case string:
		*e = PropertyStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for PropertyStatusEnum: %T", src)
	}
	return nil
}

type NullPropertyStatusEnum struct {
	PropertyStatusEnum PropertyStatusEnum `json:"property_status_enum"`
	Valid              bool               `json:"valid"` // Valid is true if PropertyStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPropertyStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.PropertyStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PropertyStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPropertyStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PropertyStatusEnum), nil
}

type PropertyTypeEnum string

const (
	PropertyTypeEnumApartment  PropertyTypeEnum = "apartment"
	PropertyTypeEnumHouse      PropertyTypeEnum = "house"
	PropertyTypeEnumStudio     PropertyTypeEnum = "studio"
	PropertyTypeEnumDuplex     PropertyTypeEnum = "duplex"
	PropertyTypeEnumCommercial PropertyTypeEnum = "commercial"
)

func (e *PropertyTypeEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PropertyTypeEnum(s)
	case string:
		*e = PropertyTypeEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for PropertyTypeEnum: %T", src)
	}
	return nil
}

type NullPropertyTypeEnum struct {
	PropertyTypeEnum PropertyTypeEnum `json:"property_type_enum"`
	Valid            bool             `json:"valid"` // Valid is true if PropertyTypeEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPropertyTypeEnum) Scan(value interface{}) error {
	if value == nil {
		ns.PropertyTypeEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PropertyTypeEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPropertyTypeEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PropertyTypeEnum), nil
}

type RatingTypeEnum string

const (
	RatingTypeEnumLandlordToTenant RatingTypeEnum = "landlord_to_tenant"
	RatingTypeEnumTenantToLandlord RatingTypeEnum = "tenant_to_landlord"
	RatingTypeEnumTenantToAgent    RatingTypeEnum = "tenant_to_agent"
	RatingTypeEnumAgentToTenant    RatingTypeEnum = "agent_to_tenant"
)

func (e *RatingTypeEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = RatingTypeEnum(s)
	case string:
		*e = RatingTypeEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for RatingTypeEnum: %T", src)
	}
	return nil
}

type NullRatingTypeEnum struct {
	RatingTypeEnum RatingTypeEnum `json:"rating_type_enum"`
	Valid          bool           `json:"valid"` // Valid is true if RatingTypeEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullRatingTypeEnum) Scan(value interface{}) error {
	if value == nil {
		ns.RatingTypeEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.RatingTypeEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullRatingTypeEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.RatingTypeEnum), nil
}

type RelatedEntityEnum string

const (
	RelatedEntityEnumInspectionRequest RelatedEntityEnum = "inspection_request"
	RelatedEntityEnumRentalApplication RelatedEntityEnum = "rental_application"
	RelatedEntityEnumRentalAgreement   RelatedEntityEnum = "rental_agreement"
)

func (e *RelatedEntityEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = RelatedEntityEnum(s)
	case string:
		*e = RelatedEntityEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for RelatedEntityEnum: %T", src)
	}
	return nil
}

type NullRelatedEntityEnum struct {
	RelatedEntityEnum RelatedEntityEnum `json:"related_entity_enum"`
	Valid             bool              `json:"valid"` // Valid is true if RelatedEntityEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullRelatedEntityEnum) Scan(value interface{}) error {
	if value == nil {
		ns.RelatedEntityEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.RelatedEntityEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullRelatedEntityEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.RelatedEntityEnum), nil
}

type RentPeriodEnum string

const (
	RentPeriodEnumMonthly  RentPeriodEnum = "monthly"
	RentPeriodEnumAnnually RentPeriodEnum = "annually"
)

func (e *RentPeriodEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = RentPeriodEnum(s)
	case string:
		*e = RentPeriodEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for RentPeriodEnum: %T", src)
	}
	return nil
}

type NullRentPeriodEnum struct {
	RentPeriodEnum RentPeriodEnum `json:"rent_period_enum"`
	Valid          bool           `json:"valid"` // Valid is true if RentPeriodEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullRentPeriodEnum) Scan(value interface{}) error {
	if value == nil {
		ns.RentPeriodEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.RentPeriodEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullRentPeriodEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.RentPeriodEnum), nil
}

type SettingTypeEnum string

const (
	SettingTypeEnumString  SettingTypeEnum = "string"
	SettingTypeEnumNumber  SettingTypeEnum = "number"
	SettingTypeEnumBoolean SettingTypeEnum = "boolean"
	SettingTypeEnumJson    SettingTypeEnum = "json"
)

func (e *SettingTypeEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = SettingTypeEnum(s)
	case string:
		*e = SettingTypeEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for SettingTypeEnum: %T", src)
	}
	return nil
}

type NullSettingTypeEnum struct {
	SettingTypeEnum SettingTypeEnum `json:"setting_type_enum"`
	Valid           bool            `json:"valid"` // Valid is true if SettingTypeEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullSettingTypeEnum) Scan(value interface{}) error {
	if value == nil {
		ns.SettingTypeEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.SettingTypeEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullSettingTypeEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.SettingTypeEnum), nil
}

type UserTypeEnum string

const (
	UserTypeEnumTenant          UserTypeEnum = "tenant"
	UserTypeEnumLandlord        UserTypeEnum = "landlord"
	UserTypeEnumInspectionAgent UserTypeEnum = "inspection_agent"
	UserTypeEnumAdmin           UserTypeEnum = "admin"
)

func (e *UserTypeEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = UserTypeEnum(s)
	case string:
		*e = UserTypeEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for UserTypeEnum: %T", src)
	}
	return nil
}

type NullUserTypeEnum struct {
	UserTypeEnum UserTypeEnum `json:"user_type_enum"`
	Valid        bool         `json:"valid"` // Valid is true if UserTypeEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullUserTypeEnum) Scan(value interface{}) error {
	if value == nil {
		ns.UserTypeEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.UserTypeEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullUserTypeEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.UserTypeEnum), nil
}

type VerificationStatusEnum string

const (
	VerificationStatusEnumPending  VerificationStatusEnum = "pending"
	VerificationStatusEnumVerified VerificationStatusEnum = "verified"
	VerificationStatusEnumRejected VerificationStatusEnum = "rejected"
)

func (e *VerificationStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = VerificationStatusEnum(s)
	case string:
		*e = VerificationStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for VerificationStatusEnum: %T", src)
	}
	return nil
}

type NullVerificationStatusEnum struct {
	VerificationStatusEnum VerificationStatusEnum `json:"verification_status_enum"`
	Valid                  bool                   `json:"valid"` // Valid is true if VerificationStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullVerificationStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.VerificationStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.VerificationStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullVerificationStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.VerificationStatusEnum), nil
}

type VerificationTypeEnum string

const (
	VerificationTypeEnumEmail           VerificationTypeEnum = "email"
	VerificationTypeEnumPhone           VerificationTypeEnum = "phone"
	VerificationTypeEnumNin             VerificationTypeEnum = "nin"
	VerificationTypeEnumLicense         VerificationTypeEnum = "license"
	VerificationTypeEnumBackgroundCheck VerificationTypeEnum = "background_check"
	VerificationTypeEnumPasswordReset   VerificationTypeEnum = "password_reset"
)

func (e *VerificationTypeEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = VerificationTypeEnum(s)
	case string:
		*e = VerificationTypeEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for VerificationTypeEnum: %T", src)
	}
	return nil
}

type NullVerificationTypeEnum struct {
	VerificationTypeEnum VerificationTypeEnum `json:"verification_type_enum"`
	Valid                bool                 `json:"valid"` // Valid is true if VerificationTypeEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullVerificationTypeEnum) Scan(value interface{}) error {
	if value == nil {
		ns.VerificationTypeEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.VerificationTypeEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullVerificationTypeEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.VerificationTypeEnum), nil
}

type AuditLog struct {
	ID         int64              `json:"id"`
	UserID     pgtype.Int8        `json:"user_id"`
	Action     AuditActionEnum    `json:"action"`
	EntityType string             `json:"entity_type"`
	EntityID   pgtype.Int8        `json:"entity_id"`
	OldValues  pgtype.Text        `json:"old_values"`
	NewValues  pgtype.Text        `json:"new_values"`
	IpAddress  pgtype.Text        `json:"ip_address"`
	UserAgent  pgtype.Text        `json:"user_agent"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
}

type ChatbotConversation struct {
	ID              int64              `json:"id"`
	UserID          int64              `json:"user_id"`
	SessionID       string             `json:"session_id"`
	MessageText     string             `json:"message_text"`
	ResponseText    string             `json:"response_text"`
	Intent          pgtype.Text        `json:"intent"`
	Entities        pgtype.Text        `json:"entities"`
	ConfidenceScore pgtype.Numeric     `json:"confidence_score"`
	IsEscalated     pgtype.Bool        `json:"is_escalated"`
	EscalatedTo     pgtype.Int8        `json:"escalated_to"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
}

type DisputeCase struct {
	ID                int64                 `json:"id"`
	ComplainantID     int64                 `json:"complainant_id"`
	RespondentID      int64                 `json:"respondent_id"`
	RelatedEntityType NullDisputeEntityEnum `json:"related_entity_type"`
	RelatedEntityID   pgtype.Int8           `json:"related_entity_id"`
	DisputeType       DisputeTypeEnum       `json:"dispute_type"`
	Description       string                `json:"description"`
	EvidenceFiles     pgtype.Text           `json:"evidence_files"`
	Status            NullDisputeStatusEnum `json:"status"`
	AssignedAdminID   pgtype.Int8           `json:"assigned_admin_id"`
	ResolutionNotes   pgtype.Text           `json:"resolution_notes"`
	ResolvedAt        pgtype.Timestamptz    `json:"resolved_at"`
	CreatedAt         pgtype.Timestamptz    `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz    `json:"updated_at"`
}

type InspectionAgentProfile struct {
	ID                   int64              `json:"id"`
	UserID               int64              `json:"user_id"`
	LicenseNumber        pgtype.Text        `json:"license_number"`
	Specializations      pgtype.Text        `json:"specializations"`
	ServiceAreas         pgtype.Text        `json:"service_areas"`
	HourlyRate           pgtype.Numeric     `json:"hourly_rate"`
	AvailabilitySchedule pgtype.Text        `json:"availability_schedule"`
	TotalInspections     pgtype.Int4        `json:"total_inspections"`
	AverageRating        pgtype.Numeric     `json:"average_rating"`
	CompletionRate       pgtype.Numeric     `json:"completion_rate"`
	TotalEarnings        pgtype.Numeric     `json:"total_earnings"`
	BankName             pgtype.Text        `json:"bank_name"`
	BankAccount          pgtype.Text        `json:"bank_account"`
	BankAccountName      pgtype.Text        `json:"bank_account_name"`
	IsApproved           pgtype.Bool        `json:"is_approved"`
	ApprovedAt           pgtype.Timestamp   `json:"approved_at"`
	ApprovedBy           pgtype.Int8        `json:"approved_by"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
}

type InspectionReport struct {
	ID                     int64                `json:"id"`
	InspectionRequestID    int64                `json:"inspection_request_id"`
	InspectionAgentID      int64                `json:"inspection_agent_id"`
	OverallCondition       OverallConditionEnum `json:"overall_condition"`
	StructuralCondition    pgtype.Text          `json:"structural_condition"`
	ElectricalCondition    pgtype.Text          `json:"electrical_condition"`
	PlumbingCondition      pgtype.Text          `json:"plumbing_condition"`
	SafetyAssessment       pgtype.Text          `json:"safety_assessment"`
	NeighborhoodAssessment pgtype.Text          `json:"neighborhood_assessment"`
	SpecialFindings        pgtype.Text          `json:"special_findings"`
	Recommendations        pgtype.Text          `json:"recommendations"`
	Photos                 pgtype.Text          `json:"photos"`
	Videos                 pgtype.Text          `json:"videos"`
	ChecklistData          pgtype.Text          `json:"checklist_data"`
	ReportSummary          string               `json:"report_summary"`
	IsApproved             pgtype.Bool          `json:"is_approved"`
	ApprovedAt             pgtype.Timestamptz   `json:"approved_at"`
	CreatedAt              pgtype.Timestamptz   `json:"created_at"`
	UpdatedAt              pgtype.Timestamptz   `json:"updated_at"`
}

type InspectionRequest struct {
	ID                  int64                    `json:"id"`
	PropertyID          int64                    `json:"property_id"`
	TenantID            int64                    `json:"tenant_id"`
	LandlordID          int64                    `json:"landlord_id"`
	InspectionAgentID   pgtype.Int8              `json:"inspection_agent_id"`
	InspectionType      InspectionTypeEnum       `json:"inspection_type"`
	RequestedDate       pgtype.Date              `json:"requested_date"`
	RequestedTime       pgtype.Time              `json:"requested_time"`
	SpecialRequirements pgtype.Text              `json:"special_requirements"`
	InspectionFee       pgtype.Numeric           `json:"inspection_fee"`
	Status              NullInspectionStatusEnum `json:"status"`
	PaymentStatus       NullPaymentStatusEnum    `json:"payment_status"`
	PaymentReference    pgtype.Text              `json:"payment_reference"`
	ConfirmedDate       pgtype.Date              `json:"confirmed_date"`
	ConfirmedTime       pgtype.Time              `json:"confirmed_time"`
	CompletedAt         pgtype.Timestamptz       `json:"completed_at"`
	CancellationReason  pgtype.Text              `json:"cancellation_reason"`
	CancelledAt         pgtype.Timestamptz       `json:"cancelled_at"`
	CreatedAt           pgtype.Timestamptz       `json:"created_at"`
	UpdatedAt           pgtype.Timestamptz       `json:"updated_at"`
}

type LandlordProfile struct {
	ID                   int64              `json:"id"`
	UserID               int64              `json:"user_id"`
	BusinessName         pgtype.Text        `json:"business_name"`
	BusinessRegistration pgtype.Text        `json:"business_registration"`
	TaxID                pgtype.Text        `json:"tax_id"`
	BankName             pgtype.Text        `json:"bank_name"`
	BankAccount          pgtype.Text        `json:"bank_account"`
	BankAccountName      pgtype.Text        `json:"bank_account_name"`
	GuarantorName        pgtype.Text        `json:"guarantor_name"`
	GuarantorPhone       pgtype.Text        `json:"guarantor_phone"`
	GuarantorAddress     pgtype.Text        `json:"guarantor_address"`
	TotalProperties      pgtype.Int4        `json:"total_properties"`
	AverageRating        pgtype.Numeric     `json:"average_rating"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
}

type Message struct {
	ID                  int64               `json:"id"`
	SenderID            int64               `json:"sender_id"`
	RecipientID         int64               `json:"recipient_id"`
	PropertyID          pgtype.Int8         `json:"property_id"`
	InspectionRequestID pgtype.Int8         `json:"inspection_request_id"`
	ApplicationID       pgtype.Int8         `json:"application_id"`
	MessageType         NullMessageTypeEnum `json:"message_type"`
	Content             string              `json:"content"`
	MediaUrl            pgtype.Text         `json:"media_url"`
	IsRead              pgtype.Bool         `json:"is_read"`
	ReadAt              pgtype.Timestamptz  `json:"read_at"`
	CreatedAt           pgtype.Timestamptz  `json:"created_at"`
}

type Notification struct {
	ID                int64                      `json:"id"`
	UserID            int64                      `json:"user_id"`
	NotificationType  NotificationTypeEnum       `json:"notification_type"`
	Title             string                     `json:"title"`
	Content           string                     `json:"content"`
	RelatedEntityType NullNotificationEntityEnum `json:"related_entity_type"`
	RelatedEntityID   pgtype.Int8                `json:"related_entity_id"`
	IsRead            pgtype.Bool                `json:"is_read"`
	IsPushSent        pgtype.Bool                `json:"is_push_sent"`
	IsEmailSent       pgtype.Bool                `json:"is_email_sent"`
	IsSmsSent         pgtype.Bool                `json:"is_sms_sent"`
	ReadAt            pgtype.Timestamptz         `json:"read_at"`
	CreatedAt         pgtype.Timestamptz         `json:"created_at"`
}

type Payment struct {
	ID                int64                     `json:"id"`
	PayerID           int64                     `json:"payer_id"`
	PayeeID           pgtype.Int8               `json:"payee_id"`
	PaymentType       PaymentTypeEnum           `json:"payment_type"`
	RelatedEntityType NullRelatedEntityEnum     `json:"related_entity_type"`
	RelatedEntityID   pgtype.Int8               `json:"related_entity_id"`
	Amount            pgtype.Numeric            `json:"amount"`
	Currency          pgtype.Text               `json:"currency"`
	PaymentMethod     PaymentMethodEnum         `json:"payment_method"`
	PaymentReference  string                    `json:"payment_reference"`
	GatewayReference  pgtype.Text               `json:"gateway_reference"`
	Status            NullPaymentStatusFullEnum `json:"status"`
	GatewayResponse   pgtype.Text               `json:"gateway_response"`
	ProcessedAt       pgtype.Timestamptz        `json:"processed_at"`
	RefundedAt        pgtype.Timestamptz        `json:"refunded_at"`
	RefundReason      pgtype.Text               `json:"refund_reason"`
	CreatedAt         pgtype.Timestamptz        `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz        `json:"updated_at"`
}

type Property struct {
	ID                     int64                    `json:"id"`
	LandlordID             int64                    `json:"landlord_id"`
	Title                  string                   `json:"title"`
	Description            pgtype.Text              `json:"description"`
	PropertyType           PropertyTypeEnum         `json:"property_type"`
	Address                string                   `json:"address"`
	City                   string                   `json:"city"`
	State                  string                   `json:"state"`
	Country                pgtype.Text              `json:"country"`
	Latitude               pgtype.Numeric           `json:"latitude"`
	Longitude              pgtype.Numeric           `json:"longitude"`
	Bedrooms               int32                    `json:"bedrooms"`
	Bathrooms              int32                    `json:"bathrooms"`
	RentAmount             pgtype.Numeric           `json:"rent_amount"`
	RentPeriod             NullRentPeriodEnum       `json:"rent_period"`
	SecurityDeposit        pgtype.Numeric           `json:"security_deposit"`
	AgencyFee              pgtype.Numeric           `json:"agency_fee"`
	LegalFee               pgtype.Numeric           `json:"legal_fee"`
	Amenities              pgtype.Text              `json:"amenities"`
	FurnishingStatus       NullFurnishingStatusEnum `json:"furnishing_status"`
	ParkingSpaces          pgtype.Int4              `json:"parking_spaces"`
	TotalArea              pgtype.Numeric           `json:"total_area"`
	IsVerified             pgtype.Bool              `json:"is_verified"`
	VerificationBadge      pgtype.Bool              `json:"verification_badge"`
	VerifiedAt             pgtype.Timestamp         `json:"verified_at"`
	VerifiedBy             pgtype.Int8              `json:"verified_by"`
	IsAvailable            pgtype.Bool              `json:"is_available"`
	LastConfirmedAvailable pgtype.Timestamp         `json:"last_confirmed_available"`
	ViewsCount             pgtype.Int4              `json:"views_count"`
	Status                 NullPropertyStatusEnum   `json:"status"`
	ExpiresAt              pgtype.Timestamptz       `json:"expires_at"`
	CreatedAt              pgtype.Timestamptz       `json:"created_at"`
	UpdatedAt              pgtype.Timestamptz       `json:"updated_at"`
}

type PropertyCommunityReview struct {
	ID                   int64              `json:"id"`
	PropertyID           int64              `json:"property_id"`
	UserID               int64              `json:"user_id"`
	ElectricityRating    pgtype.Int4        `json:"electricity_rating"`
	WaterRating          pgtype.Int4        `json:"water_rating"`
	SecurityRating       pgtype.Int4        `json:"security_rating"`
	NoiseLevel           pgtype.Int4        `json:"noise_level"`
	RoadCondition        pgtype.Int4        `json:"road_condition"`
	FloodingRisk         pgtype.Int4        `json:"flooding_risk"`
	InternetConnectivity pgtype.Int4        `json:"internet_connectivity"`
	ProximityToAmenities pgtype.Int4        `json:"proximity_to_amenities"`
	Comment              pgtype.Text        `json:"comment"`
	IsVerified           pgtype.Bool        `json:"is_verified"`
	HelpfulVotes         pgtype.Int4        `json:"helpful_votes"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
}

type PropertyInquiry struct {
	ID          int64                 `json:"id"`
	PropertyID  int64                 `json:"property_id"`
	TenantID    int64                 `json:"tenant_id"`
	LandlordID  int64                 `json:"landlord_id"`
	InquiryType InquiryTypeEnum       `json:"inquiry_type"`
	Message     pgtype.Text           `json:"message"`
	Status      NullInquiryStatusEnum `json:"status"`
	Response    pgtype.Text           `json:"response"`
	RespondedAt pgtype.Timestamptz    `json:"responded_at"`
	CreatedAt   pgtype.Timestamptz    `json:"created_at"`
}

type PropertyMedium struct {
	ID           int64              `json:"id"`
	PropertyID   int64              `json:"property_id"`
	MediaType    MediaTypeEnum      `json:"media_type"`
	MediaUrl     string             `json:"media_url"`
	ThumbnailUrl pgtype.Text        `json:"thumbnail_url"`
	Caption      pgtype.Text        `json:"caption"`
	DisplayOrder pgtype.Int4        `json:"display_order"`
	IsPrimary    pgtype.Bool        `json:"is_primary"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
}

type PropertySearchCache struct {
	ID           int64              `json:"id"`
	SearchHash   string             `json:"search_hash"`
	SearchParams pgtype.Text        `json:"search_params"`
	PropertyIds  pgtype.Text        `json:"property_ids"`
	ResultCount  int32              `json:"result_count"`
	ExpiresAt    time.Time          `json:"expires_at"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
}

type RentalAgreement struct {
	ID                   int64                   `json:"id"`
	ApplicationID        int64                   `json:"application_id"`
	PropertyID           int64                   `json:"property_id"`
	TenantID             int64                   `json:"tenant_id"`
	LandlordID           int64                   `json:"landlord_id"`
	AgreementDocumentUrl pgtype.Text             `json:"agreement_document_url"`
	LeaseStartDate       pgtype.Date             `json:"lease_start_date"`
	LeaseEndDate         pgtype.Date             `json:"lease_end_date"`
	MonthlyRent          pgtype.Numeric          `json:"monthly_rent"`
	SecurityDeposit      pgtype.Numeric          `json:"security_deposit"`
	TotalUpfrontPayment  pgtype.Numeric          `json:"total_upfront_payment"`
	PaymentSchedule      pgtype.Text             `json:"payment_schedule"`
	TermsAndConditions   pgtype.Text             `json:"terms_and_conditions"`
	Status               NullAgreementStatusEnum `json:"status"`
	TenantSignedAt       pgtype.Timestamptz      `json:"tenant_signed_at"`
	LandlordSignedAt     pgtype.Timestamptz      `json:"landlord_signed_at"`
	CreatedAt            pgtype.Timestamptz      `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz      `json:"updated_at"`
}

type RentalApplication struct {
	ID                   int64                     `json:"id"`
	PropertyID           int64                     `json:"property_id"`
	TenantID             int64                     `json:"tenant_id"`
	LandlordID           int64                     `json:"landlord_id"`
	ApplicationDocuments pgtype.Text               `json:"application_documents"`
	EmploymentDetails    pgtype.Text               `json:"employment_details"`
	References           pgtype.Text               `json:"references"`
	PreferredMoveInDate  pgtype.Date               `json:"preferred_move_in_date"`
	AdditionalNotes      pgtype.Text               `json:"additional_notes"`
	Status               NullApplicationStatusEnum `json:"status"`
	DecisionReason       pgtype.Text               `json:"decision_reason"`
	DecidedAt            pgtype.Timestamptz        `json:"decided_at"`
	DecidedBy            pgtype.Int8               `json:"decided_by"`
	CreatedAt            pgtype.Timestamptz        `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz        `json:"updated_at"`
}

type SavedProperty struct {
	ID         int64              `json:"id"`
	TenantID   int64              `json:"tenant_id"`
	PropertyID int64              `json:"property_id"`
	SavedAt    pgtype.Timestamptz `json:"saved_at"`
}

type SystemSetting struct {
	ID           int64               `json:"id"`
	SettingKey   string              `json:"setting_key"`
	SettingValue pgtype.Text         `json:"setting_value"`
	SettingType  NullSettingTypeEnum `json:"setting_type"`
	Description  pgtype.Text         `json:"description"`
	IsPublic     pgtype.Bool         `json:"is_public"`
	UpdatedBy    pgtype.Int8         `json:"updated_by"`
	CreatedAt    pgtype.Timestamptz  `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz  `json:"updated_at"`
}

type TenantProfile struct {
	ID                 int64              `json:"id"`
	UserID             int64              `json:"user_id"`
	PreferredLocations pgtype.Text        `json:"preferred_locations"`
	BudgetMin          pgtype.Numeric     `json:"budget_min"`
	BudgetMax          pgtype.Numeric     `json:"budget_max"`
	BedroomsMin        pgtype.Int4        `json:"bedrooms_min"`
	BedroomsMax        pgtype.Int4        `json:"bedrooms_max"`
	PreferredAmenities pgtype.Text        `json:"preferred_amenities"`
	Occupation         pgtype.Text        `json:"occupation"`
	Employer           pgtype.Text        `json:"employer"`
	MonthlyIncome      pgtype.Numeric     `json:"monthly_income"`
	PreviousAddress    pgtype.Text        `json:"previous_address"`
	References         pgtype.Text        `json:"references"`
	PetFriendly        pgtype.Bool        `json:"pet_friendly"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
}

type User struct {
	ID                int64              `json:"id"`
	Email             string             `json:"email"`
	Phone             string             `json:"phone"`
	PasswordHash      string             `json:"password_hash"`
	FirstName         string             `json:"first_name"`
	LastName          string             `json:"last_name"`
	UserType          UserTypeEnum       `json:"user_type"`
	Nin               pgtype.Text        `json:"nin"`
	IsVerified        pgtype.Bool        `json:"is_verified"`
	IsActive          pgtype.Bool        `json:"is_active"`
	ProfilePictureUrl pgtype.Text        `json:"profile_picture_url"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	LastLogin         pgtype.Timestamptz `json:"last_login"`
}

type UserRating struct {
	ID                int64                 `json:"id"`
	RaterID           int64                 `json:"rater_id"`
	RatedUserID       int64                 `json:"rated_user_id"`
	RatingType        NullRatingTypeEnum    `json:"rating_type"`
	RelatedEntityType NullRelatedEntityEnum `json:"related_entity_type"`
	RelatedEntityID   pgtype.Int8           `json:"related_entity_id"`
	Rating            int32                 `json:"rating"`
	ReviewText        pgtype.Text           `json:"review_text"`
	ResponseText      pgtype.Text           `json:"response_text"`
	IsVerified        pgtype.Bool           `json:"is_verified"`
	CreatedAt         pgtype.Timestamptz    `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz    `json:"updated_at"`
}

type UserSession struct {
	ID           int64              `json:"id"`
	UserID       int64              `json:"user_id"`
	SessionToken string             `json:"session_token"`
	DeviceInfo   pgtype.Text        `json:"device_info"`
	IpAddress    pgtype.Text        `json:"ip_address"`
	LocationData pgtype.Text        `json:"location_data"`
	ExpiresAt    time.Time          `json:"expires_at"`
	IsActive     pgtype.Bool        `json:"is_active"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
}

type UserVerification struct {
	ID                 int64                      `json:"id"`
	UserID             int64                      `json:"user_id"`
	VerificationType   VerificationTypeEnum       `json:"verification_type"`
	VerificationStatus NullVerificationStatusEnum `json:"verification_status"`
	VerificationData   []byte                     `json:"verification_data"`
	VerifiedAt         pgtype.Timestamptz         `json:"verified_at"`
	VerifiedBy         pgtype.Int8                `json:"verified_by"`
	CreatedAt          pgtype.Timestamptz         `json:"created_at"`
}
