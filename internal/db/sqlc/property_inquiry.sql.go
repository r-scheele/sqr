// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: property_inquiry.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countLandlordInquiries = `-- name: CountLandlordInquiries :one
SELECT COUNT(*) FROM property_inquiries 
WHERE landlord_id = $1
`

// Count inquiries for landlord
func (q *Queries) CountLandlordInquiries(ctx context.Context, landlordID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countLandlordInquiries, landlordID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPropertyInquiries = `-- name: CountPropertyInquiries :one
SELECT COUNT(*) FROM property_inquiries 
WHERE property_id = $1
`

// Count inquiries for property
func (q *Queries) CountPropertyInquiries(ctx context.Context, propertyID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countPropertyInquiries, propertyID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPropertyInquiriesByType = `-- name: CountPropertyInquiriesByType :one
SELECT COUNT(*) FROM property_inquiries 
WHERE property_id = $1 AND inquiry_type = $2
`

type CountPropertyInquiriesByTypeParams struct {
	PropertyID  int64           `json:"property_id"`
	InquiryType InquiryTypeEnum `json:"inquiry_type"`
}

// Count inquiries by type for property
func (q *Queries) CountPropertyInquiriesByType(ctx context.Context, arg CountPropertyInquiriesByTypeParams) (int64, error) {
	row := q.db.QueryRow(ctx, countPropertyInquiriesByType, arg.PropertyID, arg.InquiryType)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUnreadLandlordInquiries = `-- name: CountUnreadLandlordInquiries :one
SELECT COUNT(*) FROM property_inquiries 
WHERE landlord_id = $1 AND status = 'sent'
`

// Count unread inquiries for landlord
func (q *Queries) CountUnreadLandlordInquiries(ctx context.Context, landlordID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countUnreadLandlordInquiries, landlordID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPropertyInquiry = `-- name: CreatePropertyInquiry :one
INSERT INTO property_inquiries (
  property_id, tenant_id, landlord_id, inquiry_type, message
) VALUES (
  $1, $2, $3, $4, $5
) RETURNING id, property_id, tenant_id, landlord_id, inquiry_type, message, status, response, responded_at, created_at
`

type CreatePropertyInquiryParams struct {
	PropertyID  int64           `json:"property_id"`
	TenantID    int64           `json:"tenant_id"`
	LandlordID  int64           `json:"landlord_id"`
	InquiryType InquiryTypeEnum `json:"inquiry_type"`
	Message     pgtype.Text     `json:"message"`
}

// Create property inquiry
func (q *Queries) CreatePropertyInquiry(ctx context.Context, arg CreatePropertyInquiryParams) (PropertyInquiry, error) {
	row := q.db.QueryRow(ctx, createPropertyInquiry,
		arg.PropertyID,
		arg.TenantID,
		arg.LandlordID,
		arg.InquiryType,
		arg.Message,
	)
	var i PropertyInquiry
	err := row.Scan(
		&i.ID,
		&i.PropertyID,
		&i.TenantID,
		&i.LandlordID,
		&i.InquiryType,
		&i.Message,
		&i.Status,
		&i.Response,
		&i.RespondedAt,
		&i.CreatedAt,
	)
	return i, err
}

const deletePropertyInquiry = `-- name: DeletePropertyInquiry :exec
DELETE FROM property_inquiries 
WHERE id = $1
`

// Delete property inquiry
func (q *Queries) DeletePropertyInquiry(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deletePropertyInquiry, id)
	return err
}

const getLandlordInquiries = `-- name: GetLandlordInquiries :many
SELECT pi.id, pi.property_id, pi.tenant_id, pi.landlord_id, pi.inquiry_type, pi.message, pi.status, pi.response, pi.responded_at, pi.created_at, p.title as property_title,
       u.first_name as tenant_first_name, u.last_name as tenant_last_name, u.email as tenant_email
FROM property_inquiries pi
JOIN properties p ON pi.property_id = p.id
JOIN users u ON pi.tenant_id = u.id
WHERE pi.landlord_id = $1
ORDER BY pi.created_at DESC
LIMIT $2 OFFSET $3
`

type GetLandlordInquiriesParams struct {
	LandlordID int64 `json:"landlord_id"`
	Limit      int32 `json:"limit"`
	Offset     int32 `json:"offset"`
}

type GetLandlordInquiriesRow struct {
	ID              int64                 `json:"id"`
	PropertyID      int64                 `json:"property_id"`
	TenantID        int64                 `json:"tenant_id"`
	LandlordID      int64                 `json:"landlord_id"`
	InquiryType     InquiryTypeEnum       `json:"inquiry_type"`
	Message         pgtype.Text           `json:"message"`
	Status          NullInquiryStatusEnum `json:"status"`
	Response        pgtype.Text           `json:"response"`
	RespondedAt     pgtype.Timestamptz    `json:"responded_at"`
	CreatedAt       pgtype.Timestamptz    `json:"created_at"`
	PropertyTitle   string                `json:"property_title"`
	TenantFirstName string                `json:"tenant_first_name"`
	TenantLastName  string                `json:"tenant_last_name"`
	TenantEmail     string                `json:"tenant_email"`
}

// Get inquiries for landlord
func (q *Queries) GetLandlordInquiries(ctx context.Context, arg GetLandlordInquiriesParams) ([]GetLandlordInquiriesRow, error) {
	rows, err := q.db.Query(ctx, getLandlordInquiries, arg.LandlordID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetLandlordInquiriesRow{}
	for rows.Next() {
		var i GetLandlordInquiriesRow
		if err := rows.Scan(
			&i.ID,
			&i.PropertyID,
			&i.TenantID,
			&i.LandlordID,
			&i.InquiryType,
			&i.Message,
			&i.Status,
			&i.Response,
			&i.RespondedAt,
			&i.CreatedAt,
			&i.PropertyTitle,
			&i.TenantFirstName,
			&i.TenantLastName,
			&i.TenantEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLandlordInquiryStats = `-- name: GetLandlordInquiryStats :one
SELECT 
  COUNT(*) as total_inquiries,
  COUNT(CASE WHEN status = 'sent' THEN 1 END) as unread_count,
  COUNT(CASE WHEN status = 'responded' THEN 1 END) as responded_count,
  COUNT(CASE WHEN inquiry_type = 'viewing_request' THEN 1 END) as viewing_requests
FROM property_inquiries 
WHERE landlord_id = $1
`

type GetLandlordInquiryStatsRow struct {
	TotalInquiries  int64 `json:"total_inquiries"`
	UnreadCount     int64 `json:"unread_count"`
	RespondedCount  int64 `json:"responded_count"`
	ViewingRequests int64 `json:"viewing_requests"`
}

// Get inquiry statistics for landlord
func (q *Queries) GetLandlordInquiryStats(ctx context.Context, landlordID int64) (GetLandlordInquiryStatsRow, error) {
	row := q.db.QueryRow(ctx, getLandlordInquiryStats, landlordID)
	var i GetLandlordInquiryStatsRow
	err := row.Scan(
		&i.TotalInquiries,
		&i.UnreadCount,
		&i.RespondedCount,
		&i.ViewingRequests,
	)
	return i, err
}

const getPropertyInquiries = `-- name: GetPropertyInquiries :many
SELECT pi.id, pi.property_id, pi.tenant_id, pi.landlord_id, pi.inquiry_type, pi.message, pi.status, pi.response, pi.responded_at, pi.created_at, u.first_name as tenant_first_name, u.last_name as tenant_last_name, u.email as tenant_email
FROM property_inquiries pi
JOIN users u ON pi.tenant_id = u.id
WHERE pi.property_id = $1
ORDER BY pi.created_at DESC
LIMIT $2 OFFSET $3
`

type GetPropertyInquiriesParams struct {
	PropertyID int64 `json:"property_id"`
	Limit      int32 `json:"limit"`
	Offset     int32 `json:"offset"`
}

type GetPropertyInquiriesRow struct {
	ID              int64                 `json:"id"`
	PropertyID      int64                 `json:"property_id"`
	TenantID        int64                 `json:"tenant_id"`
	LandlordID      int64                 `json:"landlord_id"`
	InquiryType     InquiryTypeEnum       `json:"inquiry_type"`
	Message         pgtype.Text           `json:"message"`
	Status          NullInquiryStatusEnum `json:"status"`
	Response        pgtype.Text           `json:"response"`
	RespondedAt     pgtype.Timestamptz    `json:"responded_at"`
	CreatedAt       pgtype.Timestamptz    `json:"created_at"`
	TenantFirstName string                `json:"tenant_first_name"`
	TenantLastName  string                `json:"tenant_last_name"`
	TenantEmail     string                `json:"tenant_email"`
}

// Get inquiries for property
func (q *Queries) GetPropertyInquiries(ctx context.Context, arg GetPropertyInquiriesParams) ([]GetPropertyInquiriesRow, error) {
	rows, err := q.db.Query(ctx, getPropertyInquiries, arg.PropertyID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPropertyInquiriesRow{}
	for rows.Next() {
		var i GetPropertyInquiriesRow
		if err := rows.Scan(
			&i.ID,
			&i.PropertyID,
			&i.TenantID,
			&i.LandlordID,
			&i.InquiryType,
			&i.Message,
			&i.Status,
			&i.Response,
			&i.RespondedAt,
			&i.CreatedAt,
			&i.TenantFirstName,
			&i.TenantLastName,
			&i.TenantEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPropertyInquiryByID = `-- name: GetPropertyInquiryByID :one
SELECT id, property_id, tenant_id, landlord_id, inquiry_type, message, status, response, responded_at, created_at FROM property_inquiries 
WHERE id = $1 LIMIT 1
`

// Get property inquiry by ID
func (q *Queries) GetPropertyInquiryByID(ctx context.Context, id int64) (PropertyInquiry, error) {
	row := q.db.QueryRow(ctx, getPropertyInquiryByID, id)
	var i PropertyInquiry
	err := row.Scan(
		&i.ID,
		&i.PropertyID,
		&i.TenantID,
		&i.LandlordID,
		&i.InquiryType,
		&i.Message,
		&i.Status,
		&i.Response,
		&i.RespondedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getPropertyInquiryWithDetails = `-- name: GetPropertyInquiryWithDetails :one
SELECT pi.id, pi.property_id, pi.tenant_id, pi.landlord_id, pi.inquiry_type, pi.message, pi.status, pi.response, pi.responded_at, pi.created_at, p.title as property_title, 
       t.first_name as tenant_first_name, t.last_name as tenant_last_name, t.email as tenant_email,
       l.first_name as landlord_first_name, l.last_name as landlord_last_name, l.email as landlord_email
FROM property_inquiries pi
JOIN properties p ON pi.property_id = p.id
JOIN users t ON pi.tenant_id = t.id
JOIN users l ON pi.landlord_id = l.id
WHERE pi.id = $1 LIMIT 1
`

type GetPropertyInquiryWithDetailsRow struct {
	ID                int64                 `json:"id"`
	PropertyID        int64                 `json:"property_id"`
	TenantID          int64                 `json:"tenant_id"`
	LandlordID        int64                 `json:"landlord_id"`
	InquiryType       InquiryTypeEnum       `json:"inquiry_type"`
	Message           pgtype.Text           `json:"message"`
	Status            NullInquiryStatusEnum `json:"status"`
	Response          pgtype.Text           `json:"response"`
	RespondedAt       pgtype.Timestamptz    `json:"responded_at"`
	CreatedAt         pgtype.Timestamptz    `json:"created_at"`
	PropertyTitle     string                `json:"property_title"`
	TenantFirstName   string                `json:"tenant_first_name"`
	TenantLastName    string                `json:"tenant_last_name"`
	TenantEmail       string                `json:"tenant_email"`
	LandlordFirstName string                `json:"landlord_first_name"`
	LandlordLastName  string                `json:"landlord_last_name"`
	LandlordEmail     string                `json:"landlord_email"`
}

// Get inquiry with details
func (q *Queries) GetPropertyInquiryWithDetails(ctx context.Context, id int64) (GetPropertyInquiryWithDetailsRow, error) {
	row := q.db.QueryRow(ctx, getPropertyInquiryWithDetails, id)
	var i GetPropertyInquiryWithDetailsRow
	err := row.Scan(
		&i.ID,
		&i.PropertyID,
		&i.TenantID,
		&i.LandlordID,
		&i.InquiryType,
		&i.Message,
		&i.Status,
		&i.Response,
		&i.RespondedAt,
		&i.CreatedAt,
		&i.PropertyTitle,
		&i.TenantFirstName,
		&i.TenantLastName,
		&i.TenantEmail,
		&i.LandlordFirstName,
		&i.LandlordLastName,
		&i.LandlordEmail,
	)
	return i, err
}

const getTenantInquiries = `-- name: GetTenantInquiries :many
SELECT pi.id, pi.property_id, pi.tenant_id, pi.landlord_id, pi.inquiry_type, pi.message, pi.status, pi.response, pi.responded_at, pi.created_at, p.title as property_title,
       u.first_name as landlord_first_name, u.last_name as landlord_last_name, u.email as landlord_email
FROM property_inquiries pi
JOIN properties p ON pi.property_id = p.id
JOIN users u ON pi.landlord_id = u.id
WHERE pi.tenant_id = $1
ORDER BY pi.created_at DESC
LIMIT $2 OFFSET $3
`

type GetTenantInquiriesParams struct {
	TenantID int64 `json:"tenant_id"`
	Limit    int32 `json:"limit"`
	Offset   int32 `json:"offset"`
}

type GetTenantInquiriesRow struct {
	ID                int64                 `json:"id"`
	PropertyID        int64                 `json:"property_id"`
	TenantID          int64                 `json:"tenant_id"`
	LandlordID        int64                 `json:"landlord_id"`
	InquiryType       InquiryTypeEnum       `json:"inquiry_type"`
	Message           pgtype.Text           `json:"message"`
	Status            NullInquiryStatusEnum `json:"status"`
	Response          pgtype.Text           `json:"response"`
	RespondedAt       pgtype.Timestamptz    `json:"responded_at"`
	CreatedAt         pgtype.Timestamptz    `json:"created_at"`
	PropertyTitle     string                `json:"property_title"`
	LandlordFirstName string                `json:"landlord_first_name"`
	LandlordLastName  string                `json:"landlord_last_name"`
	LandlordEmail     string                `json:"landlord_email"`
}

// Get inquiries for tenant
func (q *Queries) GetTenantInquiries(ctx context.Context, arg GetTenantInquiriesParams) ([]GetTenantInquiriesRow, error) {
	rows, err := q.db.Query(ctx, getTenantInquiries, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTenantInquiriesRow{}
	for rows.Next() {
		var i GetTenantInquiriesRow
		if err := rows.Scan(
			&i.ID,
			&i.PropertyID,
			&i.TenantID,
			&i.LandlordID,
			&i.InquiryType,
			&i.Message,
			&i.Status,
			&i.Response,
			&i.RespondedAt,
			&i.CreatedAt,
			&i.PropertyTitle,
			&i.LandlordFirstName,
			&i.LandlordLastName,
			&i.LandlordEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnreadLandlordInquiries = `-- name: GetUnreadLandlordInquiries :many
SELECT pi.id, pi.property_id, pi.tenant_id, pi.landlord_id, pi.inquiry_type, pi.message, pi.status, pi.response, pi.responded_at, pi.created_at, p.title as property_title,
       u.first_name as tenant_first_name, u.last_name as tenant_last_name
FROM property_inquiries pi
JOIN properties p ON pi.property_id = p.id
JOIN users u ON pi.tenant_id = u.id
WHERE pi.landlord_id = $1 AND pi.status = 'sent'
ORDER BY pi.created_at ASC
LIMIT $2 OFFSET $3
`

type GetUnreadLandlordInquiriesParams struct {
	LandlordID int64 `json:"landlord_id"`
	Limit      int32 `json:"limit"`
	Offset     int32 `json:"offset"`
}

type GetUnreadLandlordInquiriesRow struct {
	ID              int64                 `json:"id"`
	PropertyID      int64                 `json:"property_id"`
	TenantID        int64                 `json:"tenant_id"`
	LandlordID      int64                 `json:"landlord_id"`
	InquiryType     InquiryTypeEnum       `json:"inquiry_type"`
	Message         pgtype.Text           `json:"message"`
	Status          NullInquiryStatusEnum `json:"status"`
	Response        pgtype.Text           `json:"response"`
	RespondedAt     pgtype.Timestamptz    `json:"responded_at"`
	CreatedAt       pgtype.Timestamptz    `json:"created_at"`
	PropertyTitle   string                `json:"property_title"`
	TenantFirstName string                `json:"tenant_first_name"`
	TenantLastName  string                `json:"tenant_last_name"`
}

// Get unread inquiries for landlord
func (q *Queries) GetUnreadLandlordInquiries(ctx context.Context, arg GetUnreadLandlordInquiriesParams) ([]GetUnreadLandlordInquiriesRow, error) {
	rows, err := q.db.Query(ctx, getUnreadLandlordInquiries, arg.LandlordID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUnreadLandlordInquiriesRow{}
	for rows.Next() {
		var i GetUnreadLandlordInquiriesRow
		if err := rows.Scan(
			&i.ID,
			&i.PropertyID,
			&i.TenantID,
			&i.LandlordID,
			&i.InquiryType,
			&i.Message,
			&i.Status,
			&i.Response,
			&i.RespondedAt,
			&i.CreatedAt,
			&i.PropertyTitle,
			&i.TenantFirstName,
			&i.TenantLastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markInquiryAsRead = `-- name: MarkInquiryAsRead :exec
UPDATE property_inquiries 
SET status = 'read'
WHERE id = $1 AND status = 'sent'
`

// Mark inquiry as read
func (q *Queries) MarkInquiryAsRead(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, markInquiryAsRead, id)
	return err
}

const respondToInquiry = `-- name: RespondToInquiry :one
UPDATE property_inquiries 
SET response = $2, status = 'responded', responded_at = NOW()
WHERE id = $1 
RETURNING id, property_id, tenant_id, landlord_id, inquiry_type, message, status, response, responded_at, created_at
`

type RespondToInquiryParams struct {
	ID       int64       `json:"id"`
	Response pgtype.Text `json:"response"`
}

// Respond to inquiry
func (q *Queries) RespondToInquiry(ctx context.Context, arg RespondToInquiryParams) (PropertyInquiry, error) {
	row := q.db.QueryRow(ctx, respondToInquiry, arg.ID, arg.Response)
	var i PropertyInquiry
	err := row.Scan(
		&i.ID,
		&i.PropertyID,
		&i.TenantID,
		&i.LandlordID,
		&i.InquiryType,
		&i.Message,
		&i.Status,
		&i.Response,
		&i.RespondedAt,
		&i.CreatedAt,
	)
	return i, err
}

const updateInquiryStatus = `-- name: UpdateInquiryStatus :one
UPDATE property_inquiries 
SET status = $2, updated_at = NOW()
WHERE id = $1 
RETURNING id, property_id, tenant_id, landlord_id, inquiry_type, message, status, response, responded_at, created_at
`

type UpdateInquiryStatusParams struct {
	ID     int64                 `json:"id"`
	Status NullInquiryStatusEnum `json:"status"`
}

// Update inquiry status
func (q *Queries) UpdateInquiryStatus(ctx context.Context, arg UpdateInquiryStatusParams) (PropertyInquiry, error) {
	row := q.db.QueryRow(ctx, updateInquiryStatus, arg.ID, arg.Status)
	var i PropertyInquiry
	err := row.Scan(
		&i.ID,
		&i.PropertyID,
		&i.TenantID,
		&i.LandlordID,
		&i.InquiryType,
		&i.Message,
		&i.Status,
		&i.Response,
		&i.RespondedAt,
		&i.CreatedAt,
	)
	return i, err
}
