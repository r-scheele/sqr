// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: property.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countAvailableProperties = `-- name: CountAvailableProperties :one
SELECT COUNT(*) FROM properties 
WHERE status = 'active' AND is_available = true
`

// Count available properties
func (q *Queries) CountAvailableProperties(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countAvailableProperties)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPropertiesByLandlord = `-- name: CountPropertiesByLandlord :one
SELECT COUNT(*) FROM properties 
WHERE landlord_id = $1
`

// Count properties by landlord
func (q *Queries) CountPropertiesByLandlord(ctx context.Context, landlordID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countPropertiesByLandlord, landlordID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createProperty = `-- name: CreateProperty :one
INSERT INTO properties (
  landlord_id, title, description, property_type, address, city, state, country,
  latitude, longitude, bedrooms, bathrooms, rent_amount, rent_period,
  security_deposit, agency_fee, legal_fee, amenities, furnishing_status,
  parking_spaces, total_area, expires_at
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22
) RETURNING id, landlord_id, title, description, property_type, address, city, state, country, latitude, longitude, bedrooms, bathrooms, rent_amount, rent_period, security_deposit, agency_fee, legal_fee, amenities, furnishing_status, parking_spaces, total_area, is_verified, verification_badge, verified_at, verified_by, is_available, last_confirmed_available, views_count, status, expires_at, created_at, updated_at
`

type CreatePropertyParams struct {
	LandlordID       int64                    `json:"landlord_id"`
	Title            string                   `json:"title"`
	Description      pgtype.Text              `json:"description"`
	PropertyType     PropertyTypeEnum         `json:"property_type"`
	Address          string                   `json:"address"`
	City             string                   `json:"city"`
	State            string                   `json:"state"`
	Country          pgtype.Text              `json:"country"`
	Latitude         pgtype.Numeric           `json:"latitude"`
	Longitude        pgtype.Numeric           `json:"longitude"`
	Bedrooms         int32                    `json:"bedrooms"`
	Bathrooms        int32                    `json:"bathrooms"`
	RentAmount       pgtype.Numeric           `json:"rent_amount"`
	RentPeriod       NullRentPeriodEnum       `json:"rent_period"`
	SecurityDeposit  pgtype.Numeric           `json:"security_deposit"`
	AgencyFee        pgtype.Numeric           `json:"agency_fee"`
	LegalFee         pgtype.Numeric           `json:"legal_fee"`
	Amenities        pgtype.Text              `json:"amenities"`
	FurnishingStatus NullFurnishingStatusEnum `json:"furnishing_status"`
	ParkingSpaces    pgtype.Int4              `json:"parking_spaces"`
	TotalArea        pgtype.Numeric           `json:"total_area"`
	ExpiresAt        pgtype.Timestamptz       `json:"expires_at"`
}

// Create a new property
func (q *Queries) CreateProperty(ctx context.Context, arg CreatePropertyParams) (Property, error) {
	row := q.db.QueryRow(ctx, createProperty,
		arg.LandlordID,
		arg.Title,
		arg.Description,
		arg.PropertyType,
		arg.Address,
		arg.City,
		arg.State,
		arg.Country,
		arg.Latitude,
		arg.Longitude,
		arg.Bedrooms,
		arg.Bathrooms,
		arg.RentAmount,
		arg.RentPeriod,
		arg.SecurityDeposit,
		arg.AgencyFee,
		arg.LegalFee,
		arg.Amenities,
		arg.FurnishingStatus,
		arg.ParkingSpaces,
		arg.TotalArea,
		arg.ExpiresAt,
	)
	var i Property
	err := row.Scan(
		&i.ID,
		&i.LandlordID,
		&i.Title,
		&i.Description,
		&i.PropertyType,
		&i.Address,
		&i.City,
		&i.State,
		&i.Country,
		&i.Latitude,
		&i.Longitude,
		&i.Bedrooms,
		&i.Bathrooms,
		&i.RentAmount,
		&i.RentPeriod,
		&i.SecurityDeposit,
		&i.AgencyFee,
		&i.LegalFee,
		&i.Amenities,
		&i.FurnishingStatus,
		&i.ParkingSpaces,
		&i.TotalArea,
		&i.IsVerified,
		&i.VerificationBadge,
		&i.VerifiedAt,
		&i.VerifiedBy,
		&i.IsAvailable,
		&i.LastConfirmedAvailable,
		&i.ViewsCount,
		&i.Status,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteProperty = `-- name: DeleteProperty :exec
UPDATE properties 
SET status = 'inactive', updated_at = NOW()
WHERE id = $1
`

// Delete property (soft delete)
func (q *Queries) DeleteProperty(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteProperty, id)
	return err
}

const getPropertyByID = `-- name: GetPropertyByID :one
SELECT id, landlord_id, title, description, property_type, address, city, state, country, latitude, longitude, bedrooms, bathrooms, rent_amount, rent_period, security_deposit, agency_fee, legal_fee, amenities, furnishing_status, parking_spaces, total_area, is_verified, verification_badge, verified_at, verified_by, is_available, last_confirmed_available, views_count, status, expires_at, created_at, updated_at FROM properties 
WHERE id = $1 LIMIT 1
`

// Get property by ID
func (q *Queries) GetPropertyByID(ctx context.Context, id int64) (Property, error) {
	row := q.db.QueryRow(ctx, getPropertyByID, id)
	var i Property
	err := row.Scan(
		&i.ID,
		&i.LandlordID,
		&i.Title,
		&i.Description,
		&i.PropertyType,
		&i.Address,
		&i.City,
		&i.State,
		&i.Country,
		&i.Latitude,
		&i.Longitude,
		&i.Bedrooms,
		&i.Bathrooms,
		&i.RentAmount,
		&i.RentPeriod,
		&i.SecurityDeposit,
		&i.AgencyFee,
		&i.LegalFee,
		&i.Amenities,
		&i.FurnishingStatus,
		&i.ParkingSpaces,
		&i.TotalArea,
		&i.IsVerified,
		&i.VerificationBadge,
		&i.VerifiedAt,
		&i.VerifiedBy,
		&i.IsAvailable,
		&i.LastConfirmedAvailable,
		&i.ViewsCount,
		&i.Status,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPropertyWithLandlord = `-- name: GetPropertyWithLandlord :one
SELECT p.id, p.landlord_id, p.title, p.description, p.property_type, p.address, p.city, p.state, p.country, p.latitude, p.longitude, p.bedrooms, p.bathrooms, p.rent_amount, p.rent_period, p.security_deposit, p.agency_fee, p.legal_fee, p.amenities, p.furnishing_status, p.parking_spaces, p.total_area, p.is_verified, p.verification_badge, p.verified_at, p.verified_by, p.is_available, p.last_confirmed_available, p.views_count, p.status, p.expires_at, p.created_at, p.updated_at, u.first_name, u.last_name, u.email, u.phone,
       lp.business_name, lp.average_rating as landlord_rating
FROM properties p
JOIN users u ON p.landlord_id = u.id
LEFT JOIN landlord_profiles lp ON u.id = lp.user_id
WHERE p.id = $1 LIMIT 1
`

type GetPropertyWithLandlordRow struct {
	ID                     int64                    `json:"id"`
	LandlordID             int64                    `json:"landlord_id"`
	Title                  string                   `json:"title"`
	Description            pgtype.Text              `json:"description"`
	PropertyType           PropertyTypeEnum         `json:"property_type"`
	Address                string                   `json:"address"`
	City                   string                   `json:"city"`
	State                  string                   `json:"state"`
	Country                pgtype.Text              `json:"country"`
	Latitude               pgtype.Numeric           `json:"latitude"`
	Longitude              pgtype.Numeric           `json:"longitude"`
	Bedrooms               int32                    `json:"bedrooms"`
	Bathrooms              int32                    `json:"bathrooms"`
	RentAmount             pgtype.Numeric           `json:"rent_amount"`
	RentPeriod             NullRentPeriodEnum       `json:"rent_period"`
	SecurityDeposit        pgtype.Numeric           `json:"security_deposit"`
	AgencyFee              pgtype.Numeric           `json:"agency_fee"`
	LegalFee               pgtype.Numeric           `json:"legal_fee"`
	Amenities              pgtype.Text              `json:"amenities"`
	FurnishingStatus       NullFurnishingStatusEnum `json:"furnishing_status"`
	ParkingSpaces          pgtype.Int4              `json:"parking_spaces"`
	TotalArea              pgtype.Numeric           `json:"total_area"`
	IsVerified             pgtype.Bool              `json:"is_verified"`
	VerificationBadge      pgtype.Bool              `json:"verification_badge"`
	VerifiedAt             pgtype.Timestamp         `json:"verified_at"`
	VerifiedBy             pgtype.Int8              `json:"verified_by"`
	IsAvailable            pgtype.Bool              `json:"is_available"`
	LastConfirmedAvailable pgtype.Timestamp         `json:"last_confirmed_available"`
	ViewsCount             pgtype.Int4              `json:"views_count"`
	Status                 NullPropertyStatusEnum   `json:"status"`
	ExpiresAt              pgtype.Timestamptz       `json:"expires_at"`
	CreatedAt              pgtype.Timestamptz       `json:"created_at"`
	UpdatedAt              pgtype.Timestamptz       `json:"updated_at"`
	FirstName              string                   `json:"first_name"`
	LastName               string                   `json:"last_name"`
	Email                  string                   `json:"email"`
	Phone                  string                   `json:"phone"`
	BusinessName           pgtype.Text              `json:"business_name"`
	LandlordRating         pgtype.Numeric           `json:"landlord_rating"`
}

// Get property with landlord details
func (q *Queries) GetPropertyWithLandlord(ctx context.Context, id int64) (GetPropertyWithLandlordRow, error) {
	row := q.db.QueryRow(ctx, getPropertyWithLandlord, id)
	var i GetPropertyWithLandlordRow
	err := row.Scan(
		&i.ID,
		&i.LandlordID,
		&i.Title,
		&i.Description,
		&i.PropertyType,
		&i.Address,
		&i.City,
		&i.State,
		&i.Country,
		&i.Latitude,
		&i.Longitude,
		&i.Bedrooms,
		&i.Bathrooms,
		&i.RentAmount,
		&i.RentPeriod,
		&i.SecurityDeposit,
		&i.AgencyFee,
		&i.LegalFee,
		&i.Amenities,
		&i.FurnishingStatus,
		&i.ParkingSpaces,
		&i.TotalArea,
		&i.IsVerified,
		&i.VerificationBadge,
		&i.VerifiedAt,
		&i.VerifiedBy,
		&i.IsAvailable,
		&i.LastConfirmedAvailable,
		&i.ViewsCount,
		&i.Status,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Phone,
		&i.BusinessName,
		&i.LandlordRating,
	)
	return i, err
}

const incrementPropertyViews = `-- name: IncrementPropertyViews :exec
UPDATE properties 
SET views_count = views_count + 1
WHERE id = $1
`

// Increment property views
func (q *Queries) IncrementPropertyViews(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, incrementPropertyViews, id)
	return err
}

const listFeaturedProperties = `-- name: ListFeaturedProperties :many
SELECT p.id, p.landlord_id, p.title, p.description, p.property_type, p.address, p.city, p.state, p.country, p.latitude, p.longitude, p.bedrooms, p.bathrooms, p.rent_amount, p.rent_period, p.security_deposit, p.agency_fee, p.legal_fee, p.amenities, p.furnishing_status, p.parking_spaces, p.total_area, p.is_verified, p.verification_badge, p.verified_at, p.verified_by, p.is_available, p.last_confirmed_available, p.views_count, p.status, p.expires_at, p.created_at, p.updated_at, u.first_name, u.last_name
FROM properties p
JOIN users u ON p.landlord_id = u.id
WHERE p.status = 'active' AND p.is_available = true AND p.verification_badge = true
ORDER BY p.views_count DESC, p.created_at DESC
LIMIT $1 OFFSET $2
`

type ListFeaturedPropertiesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListFeaturedPropertiesRow struct {
	ID                     int64                    `json:"id"`
	LandlordID             int64                    `json:"landlord_id"`
	Title                  string                   `json:"title"`
	Description            pgtype.Text              `json:"description"`
	PropertyType           PropertyTypeEnum         `json:"property_type"`
	Address                string                   `json:"address"`
	City                   string                   `json:"city"`
	State                  string                   `json:"state"`
	Country                pgtype.Text              `json:"country"`
	Latitude               pgtype.Numeric           `json:"latitude"`
	Longitude              pgtype.Numeric           `json:"longitude"`
	Bedrooms               int32                    `json:"bedrooms"`
	Bathrooms              int32                    `json:"bathrooms"`
	RentAmount             pgtype.Numeric           `json:"rent_amount"`
	RentPeriod             NullRentPeriodEnum       `json:"rent_period"`
	SecurityDeposit        pgtype.Numeric           `json:"security_deposit"`
	AgencyFee              pgtype.Numeric           `json:"agency_fee"`
	LegalFee               pgtype.Numeric           `json:"legal_fee"`
	Amenities              pgtype.Text              `json:"amenities"`
	FurnishingStatus       NullFurnishingStatusEnum `json:"furnishing_status"`
	ParkingSpaces          pgtype.Int4              `json:"parking_spaces"`
	TotalArea              pgtype.Numeric           `json:"total_area"`
	IsVerified             pgtype.Bool              `json:"is_verified"`
	VerificationBadge      pgtype.Bool              `json:"verification_badge"`
	VerifiedAt             pgtype.Timestamp         `json:"verified_at"`
	VerifiedBy             pgtype.Int8              `json:"verified_by"`
	IsAvailable            pgtype.Bool              `json:"is_available"`
	LastConfirmedAvailable pgtype.Timestamp         `json:"last_confirmed_available"`
	ViewsCount             pgtype.Int4              `json:"views_count"`
	Status                 NullPropertyStatusEnum   `json:"status"`
	ExpiresAt              pgtype.Timestamptz       `json:"expires_at"`
	CreatedAt              pgtype.Timestamptz       `json:"created_at"`
	UpdatedAt              pgtype.Timestamptz       `json:"updated_at"`
	FirstName              string                   `json:"first_name"`
	LastName               string                   `json:"last_name"`
}

// List featured properties
func (q *Queries) ListFeaturedProperties(ctx context.Context, arg ListFeaturedPropertiesParams) ([]ListFeaturedPropertiesRow, error) {
	rows, err := q.db.Query(ctx, listFeaturedProperties, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListFeaturedPropertiesRow{}
	for rows.Next() {
		var i ListFeaturedPropertiesRow
		if err := rows.Scan(
			&i.ID,
			&i.LandlordID,
			&i.Title,
			&i.Description,
			&i.PropertyType,
			&i.Address,
			&i.City,
			&i.State,
			&i.Country,
			&i.Latitude,
			&i.Longitude,
			&i.Bedrooms,
			&i.Bathrooms,
			&i.RentAmount,
			&i.RentPeriod,
			&i.SecurityDeposit,
			&i.AgencyFee,
			&i.LegalFee,
			&i.Amenities,
			&i.FurnishingStatus,
			&i.ParkingSpaces,
			&i.TotalArea,
			&i.IsVerified,
			&i.VerificationBadge,
			&i.VerifiedAt,
			&i.VerifiedBy,
			&i.IsAvailable,
			&i.LastConfirmedAvailable,
			&i.ViewsCount,
			&i.Status,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FirstName,
			&i.LastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProperties = `-- name: ListProperties :many
SELECT id, landlord_id, title, description, property_type, address, city, state, country, latitude, longitude, bedrooms, bathrooms, rent_amount, rent_period, security_deposit, agency_fee, legal_fee, amenities, furnishing_status, parking_spaces, total_area, is_verified, verification_badge, verified_at, verified_by, is_available, last_confirmed_available, views_count, status, expires_at, created_at, updated_at FROM properties 
WHERE status = 'active' AND is_available = true
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListPropertiesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

// List all properties with basic filtering
func (q *Queries) ListProperties(ctx context.Context, arg ListPropertiesParams) ([]Property, error) {
	rows, err := q.db.Query(ctx, listProperties, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Property{}
	for rows.Next() {
		var i Property
		if err := rows.Scan(
			&i.ID,
			&i.LandlordID,
			&i.Title,
			&i.Description,
			&i.PropertyType,
			&i.Address,
			&i.City,
			&i.State,
			&i.Country,
			&i.Latitude,
			&i.Longitude,
			&i.Bedrooms,
			&i.Bathrooms,
			&i.RentAmount,
			&i.RentPeriod,
			&i.SecurityDeposit,
			&i.AgencyFee,
			&i.LegalFee,
			&i.Amenities,
			&i.FurnishingStatus,
			&i.ParkingSpaces,
			&i.TotalArea,
			&i.IsVerified,
			&i.VerificationBadge,
			&i.VerifiedAt,
			&i.VerifiedBy,
			&i.IsAvailable,
			&i.LastConfirmedAvailable,
			&i.ViewsCount,
			&i.Status,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPropertiesByLandlord = `-- name: ListPropertiesByLandlord :many
SELECT id, landlord_id, title, description, property_type, address, city, state, country, latitude, longitude, bedrooms, bathrooms, rent_amount, rent_period, security_deposit, agency_fee, legal_fee, amenities, furnishing_status, parking_spaces, total_area, is_verified, verification_badge, verified_at, verified_by, is_available, last_confirmed_available, views_count, status, expires_at, created_at, updated_at FROM properties 
WHERE landlord_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListPropertiesByLandlordParams struct {
	LandlordID int64 `json:"landlord_id"`
	Limit      int32 `json:"limit"`
	Offset     int32 `json:"offset"`
}

// List properties by landlord
func (q *Queries) ListPropertiesByLandlord(ctx context.Context, arg ListPropertiesByLandlordParams) ([]Property, error) {
	rows, err := q.db.Query(ctx, listPropertiesByLandlord, arg.LandlordID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Property{}
	for rows.Next() {
		var i Property
		if err := rows.Scan(
			&i.ID,
			&i.LandlordID,
			&i.Title,
			&i.Description,
			&i.PropertyType,
			&i.Address,
			&i.City,
			&i.State,
			&i.Country,
			&i.Latitude,
			&i.Longitude,
			&i.Bedrooms,
			&i.Bathrooms,
			&i.RentAmount,
			&i.RentPeriod,
			&i.SecurityDeposit,
			&i.AgencyFee,
			&i.LegalFee,
			&i.Amenities,
			&i.FurnishingStatus,
			&i.ParkingSpaces,
			&i.TotalArea,
			&i.IsVerified,
			&i.VerificationBadge,
			&i.VerifiedAt,
			&i.VerifiedBy,
			&i.IsAvailable,
			&i.LastConfirmedAvailable,
			&i.ViewsCount,
			&i.Status,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPropertiesByLocation = `-- name: ListPropertiesByLocation :many
SELECT id, landlord_id, title, description, property_type, address, city, state, country, latitude, longitude, bedrooms, bathrooms, rent_amount, rent_period, security_deposit, agency_fee, legal_fee, amenities, furnishing_status, parking_spaces, total_area, is_verified, verification_badge, verified_at, verified_by, is_available, last_confirmed_available, views_count, status, expires_at, created_at, updated_at FROM properties 
WHERE city = $1 AND state = $2 AND status = 'active' AND is_available = true
ORDER BY rent_amount ASC
LIMIT $3 OFFSET $4
`

type ListPropertiesByLocationParams struct {
	City   string `json:"city"`
	State  string `json:"state"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

// List properties by location
func (q *Queries) ListPropertiesByLocation(ctx context.Context, arg ListPropertiesByLocationParams) ([]Property, error) {
	rows, err := q.db.Query(ctx, listPropertiesByLocation,
		arg.City,
		arg.State,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Property{}
	for rows.Next() {
		var i Property
		if err := rows.Scan(
			&i.ID,
			&i.LandlordID,
			&i.Title,
			&i.Description,
			&i.PropertyType,
			&i.Address,
			&i.City,
			&i.State,
			&i.Country,
			&i.Latitude,
			&i.Longitude,
			&i.Bedrooms,
			&i.Bathrooms,
			&i.RentAmount,
			&i.RentPeriod,
			&i.SecurityDeposit,
			&i.AgencyFee,
			&i.LegalFee,
			&i.Amenities,
			&i.FurnishingStatus,
			&i.ParkingSpaces,
			&i.TotalArea,
			&i.IsVerified,
			&i.VerificationBadge,
			&i.VerifiedAt,
			&i.VerifiedBy,
			&i.IsAvailable,
			&i.LastConfirmedAvailable,
			&i.ViewsCount,
			&i.Status,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecentProperties = `-- name: ListRecentProperties :many
SELECT p.id, p.landlord_id, p.title, p.description, p.property_type, p.address, p.city, p.state, p.country, p.latitude, p.longitude, p.bedrooms, p.bathrooms, p.rent_amount, p.rent_period, p.security_deposit, p.agency_fee, p.legal_fee, p.amenities, p.furnishing_status, p.parking_spaces, p.total_area, p.is_verified, p.verification_badge, p.verified_at, p.verified_by, p.is_available, p.last_confirmed_available, p.views_count, p.status, p.expires_at, p.created_at, p.updated_at, u.first_name, u.last_name
FROM properties p
JOIN users u ON p.landlord_id = u.id
WHERE p.status = 'active' AND p.is_available = true
ORDER BY p.created_at DESC
LIMIT $1 OFFSET $2
`

type ListRecentPropertiesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListRecentPropertiesRow struct {
	ID                     int64                    `json:"id"`
	LandlordID             int64                    `json:"landlord_id"`
	Title                  string                   `json:"title"`
	Description            pgtype.Text              `json:"description"`
	PropertyType           PropertyTypeEnum         `json:"property_type"`
	Address                string                   `json:"address"`
	City                   string                   `json:"city"`
	State                  string                   `json:"state"`
	Country                pgtype.Text              `json:"country"`
	Latitude               pgtype.Numeric           `json:"latitude"`
	Longitude              pgtype.Numeric           `json:"longitude"`
	Bedrooms               int32                    `json:"bedrooms"`
	Bathrooms              int32                    `json:"bathrooms"`
	RentAmount             pgtype.Numeric           `json:"rent_amount"`
	RentPeriod             NullRentPeriodEnum       `json:"rent_period"`
	SecurityDeposit        pgtype.Numeric           `json:"security_deposit"`
	AgencyFee              pgtype.Numeric           `json:"agency_fee"`
	LegalFee               pgtype.Numeric           `json:"legal_fee"`
	Amenities              pgtype.Text              `json:"amenities"`
	FurnishingStatus       NullFurnishingStatusEnum `json:"furnishing_status"`
	ParkingSpaces          pgtype.Int4              `json:"parking_spaces"`
	TotalArea              pgtype.Numeric           `json:"total_area"`
	IsVerified             pgtype.Bool              `json:"is_verified"`
	VerificationBadge      pgtype.Bool              `json:"verification_badge"`
	VerifiedAt             pgtype.Timestamp         `json:"verified_at"`
	VerifiedBy             pgtype.Int8              `json:"verified_by"`
	IsAvailable            pgtype.Bool              `json:"is_available"`
	LastConfirmedAvailable pgtype.Timestamp         `json:"last_confirmed_available"`
	ViewsCount             pgtype.Int4              `json:"views_count"`
	Status                 NullPropertyStatusEnum   `json:"status"`
	ExpiresAt              pgtype.Timestamptz       `json:"expires_at"`
	CreatedAt              pgtype.Timestamptz       `json:"created_at"`
	UpdatedAt              pgtype.Timestamptz       `json:"updated_at"`
	FirstName              string                   `json:"first_name"`
	LastName               string                   `json:"last_name"`
}

// List recent properties
func (q *Queries) ListRecentProperties(ctx context.Context, arg ListRecentPropertiesParams) ([]ListRecentPropertiesRow, error) {
	rows, err := q.db.Query(ctx, listRecentProperties, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRecentPropertiesRow{}
	for rows.Next() {
		var i ListRecentPropertiesRow
		if err := rows.Scan(
			&i.ID,
			&i.LandlordID,
			&i.Title,
			&i.Description,
			&i.PropertyType,
			&i.Address,
			&i.City,
			&i.State,
			&i.Country,
			&i.Latitude,
			&i.Longitude,
			&i.Bedrooms,
			&i.Bathrooms,
			&i.RentAmount,
			&i.RentPeriod,
			&i.SecurityDeposit,
			&i.AgencyFee,
			&i.LegalFee,
			&i.Amenities,
			&i.FurnishingStatus,
			&i.ParkingSpaces,
			&i.TotalArea,
			&i.IsVerified,
			&i.VerificationBadge,
			&i.VerifiedAt,
			&i.VerifiedBy,
			&i.IsAvailable,
			&i.LastConfirmedAvailable,
			&i.ViewsCount,
			&i.Status,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FirstName,
			&i.LastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchProperties = `-- name: SearchProperties :many
SELECT p.id, p.landlord_id, p.title, p.description, p.property_type, p.address, p.city, p.state, p.country, p.latitude, p.longitude, p.bedrooms, p.bathrooms, p.rent_amount, p.rent_period, p.security_deposit, p.agency_fee, p.legal_fee, p.amenities, p.furnishing_status, p.parking_spaces, p.total_area, p.is_verified, p.verification_badge, p.verified_at, p.verified_by, p.is_available, p.last_confirmed_available, p.views_count, p.status, p.expires_at, p.created_at, p.updated_at, u.first_name, u.last_name
FROM properties p
JOIN users u ON p.landlord_id = u.id
WHERE p.status = 'active' AND p.is_available = true
  AND ($1::text IS NULL OR p.city ILIKE '%' || $1 || '%')
  AND ($2::text IS NULL OR p.state ILIKE '%' || $2 || '%')
  AND ($3::property_type_enum IS NULL OR p.property_type = $3)
  AND ($4::decimal IS NULL OR p.rent_amount >= $4)
  AND ($5::decimal IS NULL OR p.rent_amount <= $5)
  AND ($6::integer IS NULL OR p.bedrooms >= $6)
  AND ($7::integer IS NULL OR p.bathrooms >= $7)
  AND ($8::furnishing_status_enum IS NULL OR p.furnishing_status = $8)
ORDER BY p.created_at DESC
LIMIT $9 OFFSET $10
`

type SearchPropertiesParams struct {
	Column1 string               `json:"column_1"`
	Column2 string               `json:"column_2"`
	Column3 PropertyTypeEnum     `json:"column_3"`
	Column4 pgtype.Numeric       `json:"column_4"`
	Column5 pgtype.Numeric       `json:"column_5"`
	Column6 int32                `json:"column_6"`
	Column7 int32                `json:"column_7"`
	Column8 FurnishingStatusEnum `json:"column_8"`
	Limit   int32                `json:"limit"`
	Offset  int32                `json:"offset"`
}

type SearchPropertiesRow struct {
	ID                     int64                    `json:"id"`
	LandlordID             int64                    `json:"landlord_id"`
	Title                  string                   `json:"title"`
	Description            pgtype.Text              `json:"description"`
	PropertyType           PropertyTypeEnum         `json:"property_type"`
	Address                string                   `json:"address"`
	City                   string                   `json:"city"`
	State                  string                   `json:"state"`
	Country                pgtype.Text              `json:"country"`
	Latitude               pgtype.Numeric           `json:"latitude"`
	Longitude              pgtype.Numeric           `json:"longitude"`
	Bedrooms               int32                    `json:"bedrooms"`
	Bathrooms              int32                    `json:"bathrooms"`
	RentAmount             pgtype.Numeric           `json:"rent_amount"`
	RentPeriod             NullRentPeriodEnum       `json:"rent_period"`
	SecurityDeposit        pgtype.Numeric           `json:"security_deposit"`
	AgencyFee              pgtype.Numeric           `json:"agency_fee"`
	LegalFee               pgtype.Numeric           `json:"legal_fee"`
	Amenities              pgtype.Text              `json:"amenities"`
	FurnishingStatus       NullFurnishingStatusEnum `json:"furnishing_status"`
	ParkingSpaces          pgtype.Int4              `json:"parking_spaces"`
	TotalArea              pgtype.Numeric           `json:"total_area"`
	IsVerified             pgtype.Bool              `json:"is_verified"`
	VerificationBadge      pgtype.Bool              `json:"verification_badge"`
	VerifiedAt             pgtype.Timestamp         `json:"verified_at"`
	VerifiedBy             pgtype.Int8              `json:"verified_by"`
	IsAvailable            pgtype.Bool              `json:"is_available"`
	LastConfirmedAvailable pgtype.Timestamp         `json:"last_confirmed_available"`
	ViewsCount             pgtype.Int4              `json:"views_count"`
	Status                 NullPropertyStatusEnum   `json:"status"`
	ExpiresAt              pgtype.Timestamptz       `json:"expires_at"`
	CreatedAt              pgtype.Timestamptz       `json:"created_at"`
	UpdatedAt              pgtype.Timestamptz       `json:"updated_at"`
	FirstName              string                   `json:"first_name"`
	LastName               string                   `json:"last_name"`
}

// Search properties with filters
func (q *Queries) SearchProperties(ctx context.Context, arg SearchPropertiesParams) ([]SearchPropertiesRow, error) {
	rows, err := q.db.Query(ctx, searchProperties,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Column7,
		arg.Column8,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchPropertiesRow{}
	for rows.Next() {
		var i SearchPropertiesRow
		if err := rows.Scan(
			&i.ID,
			&i.LandlordID,
			&i.Title,
			&i.Description,
			&i.PropertyType,
			&i.Address,
			&i.City,
			&i.State,
			&i.Country,
			&i.Latitude,
			&i.Longitude,
			&i.Bedrooms,
			&i.Bathrooms,
			&i.RentAmount,
			&i.RentPeriod,
			&i.SecurityDeposit,
			&i.AgencyFee,
			&i.LegalFee,
			&i.Amenities,
			&i.FurnishingStatus,
			&i.ParkingSpaces,
			&i.TotalArea,
			&i.IsVerified,
			&i.VerificationBadge,
			&i.VerifiedAt,
			&i.VerifiedBy,
			&i.IsAvailable,
			&i.LastConfirmedAvailable,
			&i.ViewsCount,
			&i.Status,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FirstName,
			&i.LastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProperty = `-- name: UpdateProperty :one
UPDATE properties 
SET title = $2, description = $3, property_type = $4, address = $5,
    city = $6, state = $7, latitude = $8, longitude = $9, bedrooms = $10,
    bathrooms = $11, rent_amount = $12, rent_period = $13, security_deposit = $14,
    agency_fee = $15, legal_fee = $16, amenities = $17, furnishing_status = $18,
    parking_spaces = $19, total_area = $20, updated_at = NOW()
WHERE id = $1 
RETURNING id, landlord_id, title, description, property_type, address, city, state, country, latitude, longitude, bedrooms, bathrooms, rent_amount, rent_period, security_deposit, agency_fee, legal_fee, amenities, furnishing_status, parking_spaces, total_area, is_verified, verification_badge, verified_at, verified_by, is_available, last_confirmed_available, views_count, status, expires_at, created_at, updated_at
`

type UpdatePropertyParams struct {
	ID               int64                    `json:"id"`
	Title            string                   `json:"title"`
	Description      pgtype.Text              `json:"description"`
	PropertyType     PropertyTypeEnum         `json:"property_type"`
	Address          string                   `json:"address"`
	City             string                   `json:"city"`
	State            string                   `json:"state"`
	Latitude         pgtype.Numeric           `json:"latitude"`
	Longitude        pgtype.Numeric           `json:"longitude"`
	Bedrooms         int32                    `json:"bedrooms"`
	Bathrooms        int32                    `json:"bathrooms"`
	RentAmount       pgtype.Numeric           `json:"rent_amount"`
	RentPeriod       NullRentPeriodEnum       `json:"rent_period"`
	SecurityDeposit  pgtype.Numeric           `json:"security_deposit"`
	AgencyFee        pgtype.Numeric           `json:"agency_fee"`
	LegalFee         pgtype.Numeric           `json:"legal_fee"`
	Amenities        pgtype.Text              `json:"amenities"`
	FurnishingStatus NullFurnishingStatusEnum `json:"furnishing_status"`
	ParkingSpaces    pgtype.Int4              `json:"parking_spaces"`
	TotalArea        pgtype.Numeric           `json:"total_area"`
}

// Update property
func (q *Queries) UpdateProperty(ctx context.Context, arg UpdatePropertyParams) (Property, error) {
	row := q.db.QueryRow(ctx, updateProperty,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.PropertyType,
		arg.Address,
		arg.City,
		arg.State,
		arg.Latitude,
		arg.Longitude,
		arg.Bedrooms,
		arg.Bathrooms,
		arg.RentAmount,
		arg.RentPeriod,
		arg.SecurityDeposit,
		arg.AgencyFee,
		arg.LegalFee,
		arg.Amenities,
		arg.FurnishingStatus,
		arg.ParkingSpaces,
		arg.TotalArea,
	)
	var i Property
	err := row.Scan(
		&i.ID,
		&i.LandlordID,
		&i.Title,
		&i.Description,
		&i.PropertyType,
		&i.Address,
		&i.City,
		&i.State,
		&i.Country,
		&i.Latitude,
		&i.Longitude,
		&i.Bedrooms,
		&i.Bathrooms,
		&i.RentAmount,
		&i.RentPeriod,
		&i.SecurityDeposit,
		&i.AgencyFee,
		&i.LegalFee,
		&i.Amenities,
		&i.FurnishingStatus,
		&i.ParkingSpaces,
		&i.TotalArea,
		&i.IsVerified,
		&i.VerificationBadge,
		&i.VerifiedAt,
		&i.VerifiedBy,
		&i.IsAvailable,
		&i.LastConfirmedAvailable,
		&i.ViewsCount,
		&i.Status,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePropertyAvailability = `-- name: UpdatePropertyAvailability :one
UPDATE properties 
SET is_available = $2, last_confirmed_available = CASE WHEN $2 = true THEN NOW() ELSE last_confirmed_available END,
    updated_at = NOW()
WHERE id = $1 
RETURNING id, landlord_id, title, description, property_type, address, city, state, country, latitude, longitude, bedrooms, bathrooms, rent_amount, rent_period, security_deposit, agency_fee, legal_fee, amenities, furnishing_status, parking_spaces, total_area, is_verified, verification_badge, verified_at, verified_by, is_available, last_confirmed_available, views_count, status, expires_at, created_at, updated_at
`

type UpdatePropertyAvailabilityParams struct {
	ID          int64       `json:"id"`
	IsAvailable pgtype.Bool `json:"is_available"`
}

// Update property availability
func (q *Queries) UpdatePropertyAvailability(ctx context.Context, arg UpdatePropertyAvailabilityParams) (Property, error) {
	row := q.db.QueryRow(ctx, updatePropertyAvailability, arg.ID, arg.IsAvailable)
	var i Property
	err := row.Scan(
		&i.ID,
		&i.LandlordID,
		&i.Title,
		&i.Description,
		&i.PropertyType,
		&i.Address,
		&i.City,
		&i.State,
		&i.Country,
		&i.Latitude,
		&i.Longitude,
		&i.Bedrooms,
		&i.Bathrooms,
		&i.RentAmount,
		&i.RentPeriod,
		&i.SecurityDeposit,
		&i.AgencyFee,
		&i.LegalFee,
		&i.Amenities,
		&i.FurnishingStatus,
		&i.ParkingSpaces,
		&i.TotalArea,
		&i.IsVerified,
		&i.VerificationBadge,
		&i.VerifiedAt,
		&i.VerifiedBy,
		&i.IsAvailable,
		&i.LastConfirmedAvailable,
		&i.ViewsCount,
		&i.Status,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePropertyStatus = `-- name: UpdatePropertyStatus :one
UPDATE properties 
SET status = $2, updated_at = NOW()
WHERE id = $1 
RETURNING id, landlord_id, title, description, property_type, address, city, state, country, latitude, longitude, bedrooms, bathrooms, rent_amount, rent_period, security_deposit, agency_fee, legal_fee, amenities, furnishing_status, parking_spaces, total_area, is_verified, verification_badge, verified_at, verified_by, is_available, last_confirmed_available, views_count, status, expires_at, created_at, updated_at
`

type UpdatePropertyStatusParams struct {
	ID     int64                  `json:"id"`
	Status NullPropertyStatusEnum `json:"status"`
}

// Update property status
func (q *Queries) UpdatePropertyStatus(ctx context.Context, arg UpdatePropertyStatusParams) (Property, error) {
	row := q.db.QueryRow(ctx, updatePropertyStatus, arg.ID, arg.Status)
	var i Property
	err := row.Scan(
		&i.ID,
		&i.LandlordID,
		&i.Title,
		&i.Description,
		&i.PropertyType,
		&i.Address,
		&i.City,
		&i.State,
		&i.Country,
		&i.Latitude,
		&i.Longitude,
		&i.Bedrooms,
		&i.Bathrooms,
		&i.RentAmount,
		&i.RentPeriod,
		&i.SecurityDeposit,
		&i.AgencyFee,
		&i.LegalFee,
		&i.Amenities,
		&i.FurnishingStatus,
		&i.ParkingSpaces,
		&i.TotalArea,
		&i.IsVerified,
		&i.VerificationBadge,
		&i.VerifiedAt,
		&i.VerifiedBy,
		&i.IsAvailable,
		&i.LastConfirmedAvailable,
		&i.ViewsCount,
		&i.Status,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const verifyProperty = `-- name: VerifyProperty :one
UPDATE properties 
SET is_verified = true, verification_badge = $2, verified_at = NOW(), 
    verified_by = $3, updated_at = NOW()
WHERE id = $1 
RETURNING id, landlord_id, title, description, property_type, address, city, state, country, latitude, longitude, bedrooms, bathrooms, rent_amount, rent_period, security_deposit, agency_fee, legal_fee, amenities, furnishing_status, parking_spaces, total_area, is_verified, verification_badge, verified_at, verified_by, is_available, last_confirmed_available, views_count, status, expires_at, created_at, updated_at
`

type VerifyPropertyParams struct {
	ID                int64       `json:"id"`
	VerificationBadge pgtype.Bool `json:"verification_badge"`
	VerifiedBy        pgtype.Int8 `json:"verified_by"`
}

// Verify property
func (q *Queries) VerifyProperty(ctx context.Context, arg VerifyPropertyParams) (Property, error) {
	row := q.db.QueryRow(ctx, verifyProperty, arg.ID, arg.VerificationBadge, arg.VerifiedBy)
	var i Property
	err := row.Scan(
		&i.ID,
		&i.LandlordID,
		&i.Title,
		&i.Description,
		&i.PropertyType,
		&i.Address,
		&i.City,
		&i.State,
		&i.Country,
		&i.Latitude,
		&i.Longitude,
		&i.Bedrooms,
		&i.Bathrooms,
		&i.RentAmount,
		&i.RentPeriod,
		&i.SecurityDeposit,
		&i.AgencyFee,
		&i.LegalFee,
		&i.Amenities,
		&i.FurnishingStatus,
		&i.ParkingSpaces,
		&i.TotalArea,
		&i.IsVerified,
		&i.VerificationBadge,
		&i.VerifiedAt,
		&i.VerifiedBy,
		&i.IsAvailable,
		&i.LastConfirmedAvailable,
		&i.ViewsCount,
		&i.Status,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
