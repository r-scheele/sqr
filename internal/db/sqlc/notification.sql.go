// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: notification.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countNotificationsByType = `-- name: CountNotificationsByType :one
SELECT COUNT(*) FROM notifications 
WHERE user_id = $1 AND notification_type = $2
`

type CountNotificationsByTypeParams struct {
	UserID           int64                `json:"user_id"`
	NotificationType NotificationTypeEnum `json:"notification_type"`
}

// Count notifications by type for user
func (q *Queries) CountNotificationsByType(ctx context.Context, arg CountNotificationsByTypeParams) (int64, error) {
	row := q.db.QueryRow(ctx, countNotificationsByType, arg.UserID, arg.NotificationType)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUnreadNotifications = `-- name: CountUnreadNotifications :one
SELECT COUNT(*) FROM notifications 
WHERE user_id = $1 AND is_read = false
`

// Count unread notifications for user
func (q *Queries) CountUnreadNotifications(ctx context.Context, userID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countUnreadNotifications, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUserNotifications = `-- name: CountUserNotifications :one
SELECT COUNT(*) FROM notifications 
WHERE user_id = $1
`

// Count total notifications for user
func (q *Queries) CountUserNotifications(ctx context.Context, userID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countUserNotifications, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createNotification = `-- name: CreateNotification :one
INSERT INTO notifications (
  user_id, notification_type, title, content, related_entity_type, related_entity_id
) VALUES (
  $1, $2, $3, $4, $5, $6
) RETURNING id, user_id, notification_type, title, content, related_entity_type, related_entity_id, is_read, is_push_sent, is_email_sent, is_sms_sent, read_at, created_at
`

type CreateNotificationParams struct {
	UserID            int64                      `json:"user_id"`
	NotificationType  NotificationTypeEnum       `json:"notification_type"`
	Title             string                     `json:"title"`
	Content           string                     `json:"content"`
	RelatedEntityType NullNotificationEntityEnum `json:"related_entity_type"`
	RelatedEntityID   pgtype.Int8                `json:"related_entity_id"`
}

// Create notification
func (q *Queries) CreateNotification(ctx context.Context, arg CreateNotificationParams) (Notification, error) {
	row := q.db.QueryRow(ctx, createNotification,
		arg.UserID,
		arg.NotificationType,
		arg.Title,
		arg.Content,
		arg.RelatedEntityType,
		arg.RelatedEntityID,
	)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.NotificationType,
		&i.Title,
		&i.Content,
		&i.RelatedEntityType,
		&i.RelatedEntityID,
		&i.IsRead,
		&i.IsPushSent,
		&i.IsEmailSent,
		&i.IsSmsSent,
		&i.ReadAt,
		&i.CreatedAt,
	)
	return i, err
}

const deleteAllUserNotifications = `-- name: DeleteAllUserNotifications :exec
DELETE FROM notifications 
WHERE user_id = $1
`

// Delete all user notifications
func (q *Queries) DeleteAllUserNotifications(ctx context.Context, userID int64) error {
	_, err := q.db.Exec(ctx, deleteAllUserNotifications, userID)
	return err
}

const deleteNotification = `-- name: DeleteNotification :exec
DELETE FROM notifications 
WHERE id = $1
`

// Delete notification
func (q *Queries) DeleteNotification(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteNotification, id)
	return err
}

const deleteOldNotifications = `-- name: DeleteOldNotifications :exec
DELETE FROM notifications 
WHERE created_at < $1
`

// Delete old notifications
func (q *Queries) DeleteOldNotifications(ctx context.Context, createdAt pgtype.Timestamptz) error {
	_, err := q.db.Exec(ctx, deleteOldNotifications, createdAt)
	return err
}

const getNotificationByID = `-- name: GetNotificationByID :one
SELECT id, user_id, notification_type, title, content, related_entity_type, related_entity_id, is_read, is_push_sent, is_email_sent, is_sms_sent, read_at, created_at FROM notifications 
WHERE id = $1 LIMIT 1
`

// Get notification by ID
func (q *Queries) GetNotificationByID(ctx context.Context, id int64) (Notification, error) {
	row := q.db.QueryRow(ctx, getNotificationByID, id)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.NotificationType,
		&i.Title,
		&i.Content,
		&i.RelatedEntityType,
		&i.RelatedEntityID,
		&i.IsRead,
		&i.IsPushSent,
		&i.IsEmailSent,
		&i.IsSmsSent,
		&i.ReadAt,
		&i.CreatedAt,
	)
	return i, err
}

const getNotificationsByDateRange = `-- name: GetNotificationsByDateRange :many
SELECT n.id, n.user_id, n.notification_type, n.title, n.content, n.related_entity_type, n.related_entity_id, n.is_read, n.is_push_sent, n.is_email_sent, n.is_sms_sent, n.read_at, n.created_at, u.first_name, u.last_name, u.email
FROM notifications n
JOIN users u ON n.user_id = u.id
WHERE n.created_at BETWEEN $1 AND $2
ORDER BY n.created_at DESC
LIMIT $3 OFFSET $4
`

type GetNotificationsByDateRangeParams struct {
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	CreatedAt_2 pgtype.Timestamptz `json:"created_at_2"`
	Limit       int32              `json:"limit"`
	Offset      int32              `json:"offset"`
}

type GetNotificationsByDateRangeRow struct {
	ID                int64                      `json:"id"`
	UserID            int64                      `json:"user_id"`
	NotificationType  NotificationTypeEnum       `json:"notification_type"`
	Title             string                     `json:"title"`
	Content           string                     `json:"content"`
	RelatedEntityType NullNotificationEntityEnum `json:"related_entity_type"`
	RelatedEntityID   pgtype.Int8                `json:"related_entity_id"`
	IsRead            pgtype.Bool                `json:"is_read"`
	IsPushSent        pgtype.Bool                `json:"is_push_sent"`
	IsEmailSent       pgtype.Bool                `json:"is_email_sent"`
	IsSmsSent         pgtype.Bool                `json:"is_sms_sent"`
	ReadAt            pgtype.Timestamptz         `json:"read_at"`
	CreatedAt         pgtype.Timestamptz         `json:"created_at"`
	FirstName         string                     `json:"first_name"`
	LastName          string                     `json:"last_name"`
	Email             string                     `json:"email"`
}

// Get notifications by date range
func (q *Queries) GetNotificationsByDateRange(ctx context.Context, arg GetNotificationsByDateRangeParams) ([]GetNotificationsByDateRangeRow, error) {
	rows, err := q.db.Query(ctx, getNotificationsByDateRange,
		arg.CreatedAt,
		arg.CreatedAt_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetNotificationsByDateRangeRow{}
	for rows.Next() {
		var i GetNotificationsByDateRangeRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.NotificationType,
			&i.Title,
			&i.Content,
			&i.RelatedEntityType,
			&i.RelatedEntityID,
			&i.IsRead,
			&i.IsPushSent,
			&i.IsEmailSent,
			&i.IsSmsSent,
			&i.ReadAt,
			&i.CreatedAt,
			&i.FirstName,
			&i.LastName,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNotificationsByEntity = `-- name: GetNotificationsByEntity :many
SELECT n.id, n.user_id, n.notification_type, n.title, n.content, n.related_entity_type, n.related_entity_id, n.is_read, n.is_push_sent, n.is_email_sent, n.is_sms_sent, n.read_at, n.created_at, u.first_name, u.last_name, u.email
FROM notifications n
JOIN users u ON n.user_id = u.id
WHERE n.related_entity_type = $1 AND n.related_entity_id = $2
ORDER BY n.created_at DESC
LIMIT $3 OFFSET $4
`

type GetNotificationsByEntityParams struct {
	RelatedEntityType NullNotificationEntityEnum `json:"related_entity_type"`
	RelatedEntityID   pgtype.Int8                `json:"related_entity_id"`
	Limit             int32                      `json:"limit"`
	Offset            int32                      `json:"offset"`
}

type GetNotificationsByEntityRow struct {
	ID                int64                      `json:"id"`
	UserID            int64                      `json:"user_id"`
	NotificationType  NotificationTypeEnum       `json:"notification_type"`
	Title             string                     `json:"title"`
	Content           string                     `json:"content"`
	RelatedEntityType NullNotificationEntityEnum `json:"related_entity_type"`
	RelatedEntityID   pgtype.Int8                `json:"related_entity_id"`
	IsRead            pgtype.Bool                `json:"is_read"`
	IsPushSent        pgtype.Bool                `json:"is_push_sent"`
	IsEmailSent       pgtype.Bool                `json:"is_email_sent"`
	IsSmsSent         pgtype.Bool                `json:"is_sms_sent"`
	ReadAt            pgtype.Timestamptz         `json:"read_at"`
	CreatedAt         pgtype.Timestamptz         `json:"created_at"`
	FirstName         string                     `json:"first_name"`
	LastName          string                     `json:"last_name"`
	Email             string                     `json:"email"`
}

// Get notifications by entity
func (q *Queries) GetNotificationsByEntity(ctx context.Context, arg GetNotificationsByEntityParams) ([]GetNotificationsByEntityRow, error) {
	rows, err := q.db.Query(ctx, getNotificationsByEntity,
		arg.RelatedEntityType,
		arg.RelatedEntityID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetNotificationsByEntityRow{}
	for rows.Next() {
		var i GetNotificationsByEntityRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.NotificationType,
			&i.Title,
			&i.Content,
			&i.RelatedEntityType,
			&i.RelatedEntityID,
			&i.IsRead,
			&i.IsPushSent,
			&i.IsEmailSent,
			&i.IsSmsSent,
			&i.ReadAt,
			&i.CreatedAt,
			&i.FirstName,
			&i.LastName,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNotificationsByTypeForUser = `-- name: GetNotificationsByTypeForUser :many
SELECT id, user_id, notification_type, title, content, related_entity_type, related_entity_id, is_read, is_push_sent, is_email_sent, is_sms_sent, read_at, created_at FROM notifications 
WHERE user_id = $1 AND notification_type = $2
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type GetNotificationsByTypeForUserParams struct {
	UserID           int64                `json:"user_id"`
	NotificationType NotificationTypeEnum `json:"notification_type"`
	Limit            int32                `json:"limit"`
	Offset           int32                `json:"offset"`
}

// Get notifications by type for user
func (q *Queries) GetNotificationsByTypeForUser(ctx context.Context, arg GetNotificationsByTypeForUserParams) ([]Notification, error) {
	rows, err := q.db.Query(ctx, getNotificationsByTypeForUser,
		arg.UserID,
		arg.NotificationType,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Notification{}
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.NotificationType,
			&i.Title,
			&i.Content,
			&i.RelatedEntityType,
			&i.RelatedEntityID,
			&i.IsRead,
			&i.IsPushSent,
			&i.IsEmailSent,
			&i.IsSmsSent,
			&i.ReadAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingEmailNotifications = `-- name: GetPendingEmailNotifications :many
SELECT n.id, n.user_id, n.notification_type, n.title, n.content, n.related_entity_type, n.related_entity_id, n.is_read, n.is_push_sent, n.is_email_sent, n.is_sms_sent, n.read_at, n.created_at, u.email, u.first_name, u.last_name
FROM notifications n
JOIN users u ON n.user_id = u.id
WHERE n.is_email_sent = false
ORDER BY n.created_at ASC
LIMIT $1 OFFSET $2
`

type GetPendingEmailNotificationsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetPendingEmailNotificationsRow struct {
	ID                int64                      `json:"id"`
	UserID            int64                      `json:"user_id"`
	NotificationType  NotificationTypeEnum       `json:"notification_type"`
	Title             string                     `json:"title"`
	Content           string                     `json:"content"`
	RelatedEntityType NullNotificationEntityEnum `json:"related_entity_type"`
	RelatedEntityID   pgtype.Int8                `json:"related_entity_id"`
	IsRead            pgtype.Bool                `json:"is_read"`
	IsPushSent        pgtype.Bool                `json:"is_push_sent"`
	IsEmailSent       pgtype.Bool                `json:"is_email_sent"`
	IsSmsSent         pgtype.Bool                `json:"is_sms_sent"`
	ReadAt            pgtype.Timestamptz         `json:"read_at"`
	CreatedAt         pgtype.Timestamptz         `json:"created_at"`
	Email             string                     `json:"email"`
	FirstName         string                     `json:"first_name"`
	LastName          string                     `json:"last_name"`
}

// Get pending email notifications
func (q *Queries) GetPendingEmailNotifications(ctx context.Context, arg GetPendingEmailNotificationsParams) ([]GetPendingEmailNotificationsRow, error) {
	rows, err := q.db.Query(ctx, getPendingEmailNotifications, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPendingEmailNotificationsRow{}
	for rows.Next() {
		var i GetPendingEmailNotificationsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.NotificationType,
			&i.Title,
			&i.Content,
			&i.RelatedEntityType,
			&i.RelatedEntityID,
			&i.IsRead,
			&i.IsPushSent,
			&i.IsEmailSent,
			&i.IsSmsSent,
			&i.ReadAt,
			&i.CreatedAt,
			&i.Email,
			&i.FirstName,
			&i.LastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingPushNotifications = `-- name: GetPendingPushNotifications :many
SELECT id, user_id, notification_type, title, content, related_entity_type, related_entity_id, is_read, is_push_sent, is_email_sent, is_sms_sent, read_at, created_at FROM notifications 
WHERE is_push_sent = false
ORDER BY created_at ASC
LIMIT $1 OFFSET $2
`

type GetPendingPushNotificationsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

// Get pending push notifications
func (q *Queries) GetPendingPushNotifications(ctx context.Context, arg GetPendingPushNotificationsParams) ([]Notification, error) {
	rows, err := q.db.Query(ctx, getPendingPushNotifications, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Notification{}
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.NotificationType,
			&i.Title,
			&i.Content,
			&i.RelatedEntityType,
			&i.RelatedEntityID,
			&i.IsRead,
			&i.IsPushSent,
			&i.IsEmailSent,
			&i.IsSmsSent,
			&i.ReadAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingSMSNotifications = `-- name: GetPendingSMSNotifications :many
SELECT n.id, n.user_id, n.notification_type, n.title, n.content, n.related_entity_type, n.related_entity_id, n.is_read, n.is_push_sent, n.is_email_sent, n.is_sms_sent, n.read_at, n.created_at, u.phone, u.first_name, u.last_name
FROM notifications n
JOIN users u ON n.user_id = u.id
WHERE n.is_sms_sent = false
ORDER BY n.created_at ASC
LIMIT $1 OFFSET $2
`

type GetPendingSMSNotificationsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetPendingSMSNotificationsRow struct {
	ID                int64                      `json:"id"`
	UserID            int64                      `json:"user_id"`
	NotificationType  NotificationTypeEnum       `json:"notification_type"`
	Title             string                     `json:"title"`
	Content           string                     `json:"content"`
	RelatedEntityType NullNotificationEntityEnum `json:"related_entity_type"`
	RelatedEntityID   pgtype.Int8                `json:"related_entity_id"`
	IsRead            pgtype.Bool                `json:"is_read"`
	IsPushSent        pgtype.Bool                `json:"is_push_sent"`
	IsEmailSent       pgtype.Bool                `json:"is_email_sent"`
	IsSmsSent         pgtype.Bool                `json:"is_sms_sent"`
	ReadAt            pgtype.Timestamptz         `json:"read_at"`
	CreatedAt         pgtype.Timestamptz         `json:"created_at"`
	Phone             string                     `json:"phone"`
	FirstName         string                     `json:"first_name"`
	LastName          string                     `json:"last_name"`
}

// Get pending SMS notifications
func (q *Queries) GetPendingSMSNotifications(ctx context.Context, arg GetPendingSMSNotificationsParams) ([]GetPendingSMSNotificationsRow, error) {
	rows, err := q.db.Query(ctx, getPendingSMSNotifications, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPendingSMSNotificationsRow{}
	for rows.Next() {
		var i GetPendingSMSNotificationsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.NotificationType,
			&i.Title,
			&i.Content,
			&i.RelatedEntityType,
			&i.RelatedEntityID,
			&i.IsRead,
			&i.IsPushSent,
			&i.IsEmailSent,
			&i.IsSmsSent,
			&i.ReadAt,
			&i.CreatedAt,
			&i.Phone,
			&i.FirstName,
			&i.LastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentNotifications = `-- name: GetRecentNotifications :many
SELECT n.id, n.user_id, n.notification_type, n.title, n.content, n.related_entity_type, n.related_entity_id, n.is_read, n.is_push_sent, n.is_email_sent, n.is_sms_sent, n.read_at, n.created_at, u.first_name, u.last_name, u.email
FROM notifications n
JOIN users u ON n.user_id = u.id
ORDER BY n.created_at DESC
LIMIT $1 OFFSET $2
`

type GetRecentNotificationsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetRecentNotificationsRow struct {
	ID                int64                      `json:"id"`
	UserID            int64                      `json:"user_id"`
	NotificationType  NotificationTypeEnum       `json:"notification_type"`
	Title             string                     `json:"title"`
	Content           string                     `json:"content"`
	RelatedEntityType NullNotificationEntityEnum `json:"related_entity_type"`
	RelatedEntityID   pgtype.Int8                `json:"related_entity_id"`
	IsRead            pgtype.Bool                `json:"is_read"`
	IsPushSent        pgtype.Bool                `json:"is_push_sent"`
	IsEmailSent       pgtype.Bool                `json:"is_email_sent"`
	IsSmsSent         pgtype.Bool                `json:"is_sms_sent"`
	ReadAt            pgtype.Timestamptz         `json:"read_at"`
	CreatedAt         pgtype.Timestamptz         `json:"created_at"`
	FirstName         string                     `json:"first_name"`
	LastName          string                     `json:"last_name"`
	Email             string                     `json:"email"`
}

// Get recent notifications across platform
func (q *Queries) GetRecentNotifications(ctx context.Context, arg GetRecentNotificationsParams) ([]GetRecentNotificationsRow, error) {
	rows, err := q.db.Query(ctx, getRecentNotifications, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecentNotificationsRow{}
	for rows.Next() {
		var i GetRecentNotificationsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.NotificationType,
			&i.Title,
			&i.Content,
			&i.RelatedEntityType,
			&i.RelatedEntityID,
			&i.IsRead,
			&i.IsPushSent,
			&i.IsEmailSent,
			&i.IsSmsSent,
			&i.ReadAt,
			&i.CreatedAt,
			&i.FirstName,
			&i.LastName,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnreadUserNotifications = `-- name: GetUnreadUserNotifications :many
SELECT id, user_id, notification_type, title, content, related_entity_type, related_entity_id, is_read, is_push_sent, is_email_sent, is_sms_sent, read_at, created_at FROM notifications 
WHERE user_id = $1 AND is_read = false
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetUnreadUserNotificationsParams struct {
	UserID int64 `json:"user_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

// Get unread user notifications
func (q *Queries) GetUnreadUserNotifications(ctx context.Context, arg GetUnreadUserNotificationsParams) ([]Notification, error) {
	rows, err := q.db.Query(ctx, getUnreadUserNotifications, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Notification{}
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.NotificationType,
			&i.Title,
			&i.Content,
			&i.RelatedEntityType,
			&i.RelatedEntityID,
			&i.IsRead,
			&i.IsPushSent,
			&i.IsEmailSent,
			&i.IsSmsSent,
			&i.ReadAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserNotificationStats = `-- name: GetUserNotificationStats :one
SELECT 
  COUNT(*) as total_notifications,
  COUNT(CASE WHEN is_read = false THEN 1 END) as unread_count,
  COUNT(CASE WHEN notification_type = 'inspection_scheduled' THEN 1 END) as inspection_notifications,
  COUNT(CASE WHEN notification_type = 'application_status' THEN 1 END) as application_notifications,
  COUNT(CASE WHEN notification_type = 'payment_received' THEN 1 END) as payment_notifications,
  COUNT(CASE WHEN notification_type = 'message_received' THEN 1 END) as message_notifications
FROM notifications 
WHERE user_id = $1
`

type GetUserNotificationStatsRow struct {
	TotalNotifications       int64 `json:"total_notifications"`
	UnreadCount              int64 `json:"unread_count"`
	InspectionNotifications  int64 `json:"inspection_notifications"`
	ApplicationNotifications int64 `json:"application_notifications"`
	PaymentNotifications     int64 `json:"payment_notifications"`
	MessageNotifications     int64 `json:"message_notifications"`
}

// Get notification statistics for user
func (q *Queries) GetUserNotificationStats(ctx context.Context, userID int64) (GetUserNotificationStatsRow, error) {
	row := q.db.QueryRow(ctx, getUserNotificationStats, userID)
	var i GetUserNotificationStatsRow
	err := row.Scan(
		&i.TotalNotifications,
		&i.UnreadCount,
		&i.InspectionNotifications,
		&i.ApplicationNotifications,
		&i.PaymentNotifications,
		&i.MessageNotifications,
	)
	return i, err
}

const getUserNotifications = `-- name: GetUserNotifications :many
SELECT id, user_id, notification_type, title, content, related_entity_type, related_entity_id, is_read, is_push_sent, is_email_sent, is_sms_sent, read_at, created_at FROM notifications 
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetUserNotificationsParams struct {
	UserID int64 `json:"user_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

// Get user notifications
func (q *Queries) GetUserNotifications(ctx context.Context, arg GetUserNotificationsParams) ([]Notification, error) {
	rows, err := q.db.Query(ctx, getUserNotifications, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Notification{}
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.NotificationType,
			&i.Title,
			&i.Content,
			&i.RelatedEntityType,
			&i.RelatedEntityID,
			&i.IsRead,
			&i.IsPushSent,
			&i.IsEmailSent,
			&i.IsSmsSent,
			&i.ReadAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markAllUserNotificationsAsRead = `-- name: MarkAllUserNotificationsAsRead :exec
UPDATE notifications 
SET is_read = true, read_at = NOW()
WHERE user_id = $1 AND is_read = false
`

// Mark all user notifications as read
func (q *Queries) MarkAllUserNotificationsAsRead(ctx context.Context, userID int64) error {
	_, err := q.db.Exec(ctx, markAllUserNotificationsAsRead, userID)
	return err
}

const markNotificationAsRead = `-- name: MarkNotificationAsRead :exec
UPDATE notifications 
SET is_read = true, read_at = NOW()
WHERE id = $1
`

// Mark notification as read
func (q *Queries) MarkNotificationAsRead(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, markNotificationAsRead, id)
	return err
}

const markNotificationsAsRead = `-- name: MarkNotificationsAsRead :exec
UPDATE notifications 
SET is_read = true, read_at = NOW()
WHERE id = ANY($1::bigint[])
`

// Mark multiple notifications as read
func (q *Queries) MarkNotificationsAsRead(ctx context.Context, dollar_1 []int64) error {
	_, err := q.db.Exec(ctx, markNotificationsAsRead, dollar_1)
	return err
}

const updateNotification = `-- name: UpdateNotification :one
UPDATE notifications 
SET title = $2, content = $3, updated_at = NOW()
WHERE id = $1 
RETURNING id, user_id, notification_type, title, content, related_entity_type, related_entity_id, is_read, is_push_sent, is_email_sent, is_sms_sent, read_at, created_at
`

type UpdateNotificationParams struct {
	ID      int64  `json:"id"`
	Title   string `json:"title"`
	Content string `json:"content"`
}

// Update notification
func (q *Queries) UpdateNotification(ctx context.Context, arg UpdateNotificationParams) (Notification, error) {
	row := q.db.QueryRow(ctx, updateNotification, arg.ID, arg.Title, arg.Content)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.NotificationType,
		&i.Title,
		&i.Content,
		&i.RelatedEntityType,
		&i.RelatedEntityID,
		&i.IsRead,
		&i.IsPushSent,
		&i.IsEmailSent,
		&i.IsSmsSent,
		&i.ReadAt,
		&i.CreatedAt,
	)
	return i, err
}

const updateNotificationEmailSent = `-- name: UpdateNotificationEmailSent :exec
UPDATE notifications 
SET is_email_sent = true
WHERE id = $1
`

// Update email sent status
func (q *Queries) UpdateNotificationEmailSent(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, updateNotificationEmailSent, id)
	return err
}

const updateNotificationPushSent = `-- name: UpdateNotificationPushSent :exec
UPDATE notifications 
SET is_push_sent = true
WHERE id = $1
`

// Update push sent status
func (q *Queries) UpdateNotificationPushSent(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, updateNotificationPushSent, id)
	return err
}

const updateNotificationSMSSent = `-- name: UpdateNotificationSMSSent :exec
UPDATE notifications 
SET is_sms_sent = true
WHERE id = $1
`

// Update SMS sent status
func (q *Queries) UpdateNotificationSMSSent(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, updateNotificationSMSSent, id)
	return err
}
