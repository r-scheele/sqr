// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: user_verification.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countPendingVerifications = `-- name: CountPendingVerifications :one
SELECT COUNT(*) FROM user_verifications 
WHERE verification_status = 'pending'
`

// Count pending verifications
func (q *Queries) CountPendingVerifications(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countPendingVerifications)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createUserVerification = `-- name: CreateUserVerification :one
INSERT INTO user_verifications (
  user_id, verification_type, verification_status, verification_data
) VALUES (
  $1, $2, $3, $4
) RETURNING id, user_id, verification_type, verification_status, verification_data, verified_at, verified_by, created_at
`

type CreateUserVerificationParams struct {
	UserID             int64                      `json:"user_id"`
	VerificationType   VerificationTypeEnum       `json:"verification_type"`
	VerificationStatus NullVerificationStatusEnum `json:"verification_status"`
	VerificationData   []byte                     `json:"verification_data"`
}

// Create a new user verification
func (q *Queries) CreateUserVerification(ctx context.Context, arg CreateUserVerificationParams) (UserVerification, error) {
	row := q.db.QueryRow(ctx, createUserVerification,
		arg.UserID,
		arg.VerificationType,
		arg.VerificationStatus,
		arg.VerificationData,
	)
	var i UserVerification
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.VerificationType,
		&i.VerificationStatus,
		&i.VerificationData,
		&i.VerifiedAt,
		&i.VerifiedBy,
		&i.CreatedAt,
	)
	return i, err
}

const deleteUserVerification = `-- name: DeleteUserVerification :exec
DELETE FROM user_verifications 
WHERE id = $1
`

// Delete user verification
func (q *Queries) DeleteUserVerification(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteUserVerification, id)
	return err
}

const getUserVerificationByID = `-- name: GetUserVerificationByID :one
SELECT id, user_id, verification_type, verification_status, verification_data, verified_at, verified_by, created_at FROM user_verifications 
WHERE id = $1 LIMIT 1
`

// Get user verification by ID
func (q *Queries) GetUserVerificationByID(ctx context.Context, id int64) (UserVerification, error) {
	row := q.db.QueryRow(ctx, getUserVerificationByID, id)
	var i UserVerification
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.VerificationType,
		&i.VerificationStatus,
		&i.VerificationData,
		&i.VerifiedAt,
		&i.VerifiedBy,
		&i.CreatedAt,
	)
	return i, err
}

const getUserVerificationByType = `-- name: GetUserVerificationByType :one
SELECT id, user_id, verification_type, verification_status, verification_data, verified_at, verified_by, created_at FROM user_verifications 
WHERE user_id = $1 AND verification_type = $2
ORDER BY created_at DESC
LIMIT 1
`

type GetUserVerificationByTypeParams struct {
	UserID           int64                `json:"user_id"`
	VerificationType VerificationTypeEnum `json:"verification_type"`
}

// Get user verification by type
func (q *Queries) GetUserVerificationByType(ctx context.Context, arg GetUserVerificationByTypeParams) (UserVerification, error) {
	row := q.db.QueryRow(ctx, getUserVerificationByType, arg.UserID, arg.VerificationType)
	var i UserVerification
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.VerificationType,
		&i.VerificationStatus,
		&i.VerificationData,
		&i.VerifiedAt,
		&i.VerifiedBy,
		&i.CreatedAt,
	)
	return i, err
}

const getUserVerificationsByUserID = `-- name: GetUserVerificationsByUserID :many
SELECT id, user_id, verification_type, verification_status, verification_data, verified_at, verified_by, created_at FROM user_verifications 
WHERE user_id = $1
ORDER BY created_at DESC
`

// Get user verifications by user ID
func (q *Queries) GetUserVerificationsByUserID(ctx context.Context, userID int64) ([]UserVerification, error) {
	rows, err := q.db.Query(ctx, getUserVerificationsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserVerification{}
	for rows.Next() {
		var i UserVerification
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.VerificationType,
			&i.VerificationStatus,
			&i.VerificationData,
			&i.VerifiedAt,
			&i.VerifiedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingVerifications = `-- name: ListPendingVerifications :many
SELECT uv.id, uv.user_id, uv.verification_type, uv.verification_status, uv.verification_data, uv.verified_at, uv.verified_by, uv.created_at, u.first_name, u.last_name, u.email 
FROM user_verifications uv
JOIN users u ON uv.user_id = u.id
WHERE uv.verification_status = 'pending'
ORDER BY uv.created_at ASC
LIMIT $1 OFFSET $2
`

type ListPendingVerificationsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListPendingVerificationsRow struct {
	ID                 int64                      `json:"id"`
	UserID             int64                      `json:"user_id"`
	VerificationType   VerificationTypeEnum       `json:"verification_type"`
	VerificationStatus NullVerificationStatusEnum `json:"verification_status"`
	VerificationData   []byte                     `json:"verification_data"`
	VerifiedAt         pgtype.Timestamptz         `json:"verified_at"`
	VerifiedBy         pgtype.Int8                `json:"verified_by"`
	CreatedAt          pgtype.Timestamptz         `json:"created_at"`
	FirstName          string                     `json:"first_name"`
	LastName           string                     `json:"last_name"`
	Email              string                     `json:"email"`
}

// List pending verifications
func (q *Queries) ListPendingVerifications(ctx context.Context, arg ListPendingVerificationsParams) ([]ListPendingVerificationsRow, error) {
	rows, err := q.db.Query(ctx, listPendingVerifications, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPendingVerificationsRow{}
	for rows.Next() {
		var i ListPendingVerificationsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.VerificationType,
			&i.VerificationStatus,
			&i.VerificationData,
			&i.VerifiedAt,
			&i.VerifiedBy,
			&i.CreatedAt,
			&i.FirstName,
			&i.LastName,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVerificationsByTypeAndStatus = `-- name: ListVerificationsByTypeAndStatus :many
SELECT uv.id, uv.user_id, uv.verification_type, uv.verification_status, uv.verification_data, uv.verified_at, uv.verified_by, uv.created_at, u.first_name, u.last_name, u.email 
FROM user_verifications uv
JOIN users u ON uv.user_id = u.id
WHERE uv.verification_type = $1 AND uv.verification_status = $2
ORDER BY uv.created_at DESC
LIMIT $3 OFFSET $4
`

type ListVerificationsByTypeAndStatusParams struct {
	VerificationType   VerificationTypeEnum       `json:"verification_type"`
	VerificationStatus NullVerificationStatusEnum `json:"verification_status"`
	Limit              int32                      `json:"limit"`
	Offset             int32                      `json:"offset"`
}

type ListVerificationsByTypeAndStatusRow struct {
	ID                 int64                      `json:"id"`
	UserID             int64                      `json:"user_id"`
	VerificationType   VerificationTypeEnum       `json:"verification_type"`
	VerificationStatus NullVerificationStatusEnum `json:"verification_status"`
	VerificationData   []byte                     `json:"verification_data"`
	VerifiedAt         pgtype.Timestamptz         `json:"verified_at"`
	VerifiedBy         pgtype.Int8                `json:"verified_by"`
	CreatedAt          pgtype.Timestamptz         `json:"created_at"`
	FirstName          string                     `json:"first_name"`
	LastName           string                     `json:"last_name"`
	Email              string                     `json:"email"`
}

// List verifications by type and status
func (q *Queries) ListVerificationsByTypeAndStatus(ctx context.Context, arg ListVerificationsByTypeAndStatusParams) ([]ListVerificationsByTypeAndStatusRow, error) {
	rows, err := q.db.Query(ctx, listVerificationsByTypeAndStatus,
		arg.VerificationType,
		arg.VerificationStatus,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListVerificationsByTypeAndStatusRow{}
	for rows.Next() {
		var i ListVerificationsByTypeAndStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.VerificationType,
			&i.VerificationStatus,
			&i.VerificationData,
			&i.VerifiedAt,
			&i.VerifiedBy,
			&i.CreatedAt,
			&i.FirstName,
			&i.LastName,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateVerificationData = `-- name: UpdateVerificationData :one
UPDATE user_verifications 
SET verification_data = $2
WHERE id = $1 
RETURNING id, user_id, verification_type, verification_status, verification_data, verified_at, verified_by, created_at
`

type UpdateVerificationDataParams struct {
	ID               int64  `json:"id"`
	VerificationData []byte `json:"verification_data"`
}

// Update verification data
func (q *Queries) UpdateVerificationData(ctx context.Context, arg UpdateVerificationDataParams) (UserVerification, error) {
	row := q.db.QueryRow(ctx, updateVerificationData, arg.ID, arg.VerificationData)
	var i UserVerification
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.VerificationType,
		&i.VerificationStatus,
		&i.VerificationData,
		&i.VerifiedAt,
		&i.VerifiedBy,
		&i.CreatedAt,
	)
	return i, err
}

const updateVerificationStatus = `-- name: UpdateVerificationStatus :one
UPDATE user_verifications 
SET verification_status = $2, verified_at = CASE WHEN $2 = 'verified' THEN NOW() ELSE NULL END,
    verified_by = $3
WHERE id = $1 
RETURNING id, user_id, verification_type, verification_status, verification_data, verified_at, verified_by, created_at
`

type UpdateVerificationStatusParams struct {
	ID                 int64                      `json:"id"`
	VerificationStatus NullVerificationStatusEnum `json:"verification_status"`
	VerifiedBy         pgtype.Int8                `json:"verified_by"`
}

// Update verification status
func (q *Queries) UpdateVerificationStatus(ctx context.Context, arg UpdateVerificationStatusParams) (UserVerification, error) {
	row := q.db.QueryRow(ctx, updateVerificationStatus, arg.ID, arg.VerificationStatus, arg.VerifiedBy)
	var i UserVerification
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.VerificationType,
		&i.VerificationStatus,
		&i.VerificationData,
		&i.VerifiedAt,
		&i.VerifiedBy,
		&i.CreatedAt,
	)
	return i, err
}
