// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: landlord_profile.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createLandlordProfile = `-- name: CreateLandlordProfile :one
INSERT INTO landlord_profiles (
  user_id, business_name, business_registration, tax_id, bank_name,
  bank_account, bank_account_name, guarantor_name, guarantor_phone,
  guarantor_address
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
) RETURNING id, user_id, business_name, business_registration, tax_id, bank_name, bank_account, bank_account_name, guarantor_name, guarantor_phone, guarantor_address, total_properties, average_rating, created_at, updated_at
`

type CreateLandlordProfileParams struct {
	UserID               int64       `json:"user_id"`
	BusinessName         pgtype.Text `json:"business_name"`
	BusinessRegistration pgtype.Text `json:"business_registration"`
	TaxID                pgtype.Text `json:"tax_id"`
	BankName             pgtype.Text `json:"bank_name"`
	BankAccount          pgtype.Text `json:"bank_account"`
	BankAccountName      pgtype.Text `json:"bank_account_name"`
	GuarantorName        pgtype.Text `json:"guarantor_name"`
	GuarantorPhone       pgtype.Text `json:"guarantor_phone"`
	GuarantorAddress     pgtype.Text `json:"guarantor_address"`
}

// Create a new landlord profile
func (q *Queries) CreateLandlordProfile(ctx context.Context, arg CreateLandlordProfileParams) (LandlordProfile, error) {
	row := q.db.QueryRow(ctx, createLandlordProfile,
		arg.UserID,
		arg.BusinessName,
		arg.BusinessRegistration,
		arg.TaxID,
		arg.BankName,
		arg.BankAccount,
		arg.BankAccountName,
		arg.GuarantorName,
		arg.GuarantorPhone,
		arg.GuarantorAddress,
	)
	var i LandlordProfile
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BusinessName,
		&i.BusinessRegistration,
		&i.TaxID,
		&i.BankName,
		&i.BankAccount,
		&i.BankAccountName,
		&i.GuarantorName,
		&i.GuarantorPhone,
		&i.GuarantorAddress,
		&i.TotalProperties,
		&i.AverageRating,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const decrementLandlordPropertyCount = `-- name: DecrementLandlordPropertyCount :exec
UPDATE landlord_profiles 
SET total_properties = GREATEST(total_properties - 1, 0), updated_at = NOW()
WHERE user_id = $1
`

// Decrement landlord property count
func (q *Queries) DecrementLandlordPropertyCount(ctx context.Context, userID int64) error {
	_, err := q.db.Exec(ctx, decrementLandlordPropertyCount, userID)
	return err
}

const deleteLandlordProfile = `-- name: DeleteLandlordProfile :exec
DELETE FROM landlord_profiles 
WHERE user_id = $1
`

// Delete landlord profile
func (q *Queries) DeleteLandlordProfile(ctx context.Context, userID int64) error {
	_, err := q.db.Exec(ctx, deleteLandlordProfile, userID)
	return err
}

const getLandlordProfileByID = `-- name: GetLandlordProfileByID :one
SELECT id, user_id, business_name, business_registration, tax_id, bank_name, bank_account, bank_account_name, guarantor_name, guarantor_phone, guarantor_address, total_properties, average_rating, created_at, updated_at FROM landlord_profiles 
WHERE id = $1 LIMIT 1
`

// Get landlord profile by ID
func (q *Queries) GetLandlordProfileByID(ctx context.Context, id int64) (LandlordProfile, error) {
	row := q.db.QueryRow(ctx, getLandlordProfileByID, id)
	var i LandlordProfile
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BusinessName,
		&i.BusinessRegistration,
		&i.TaxID,
		&i.BankName,
		&i.BankAccount,
		&i.BankAccountName,
		&i.GuarantorName,
		&i.GuarantorPhone,
		&i.GuarantorAddress,
		&i.TotalProperties,
		&i.AverageRating,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLandlordProfileByUserID = `-- name: GetLandlordProfileByUserID :one
SELECT id, user_id, business_name, business_registration, tax_id, bank_name, bank_account, bank_account_name, guarantor_name, guarantor_phone, guarantor_address, total_properties, average_rating, created_at, updated_at FROM landlord_profiles 
WHERE user_id = $1 LIMIT 1
`

// Get landlord profile by user ID
func (q *Queries) GetLandlordProfileByUserID(ctx context.Context, userID int64) (LandlordProfile, error) {
	row := q.db.QueryRow(ctx, getLandlordProfileByUserID, userID)
	var i LandlordProfile
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BusinessName,
		&i.BusinessRegistration,
		&i.TaxID,
		&i.BankName,
		&i.BankAccount,
		&i.BankAccountName,
		&i.GuarantorName,
		&i.GuarantorPhone,
		&i.GuarantorAddress,
		&i.TotalProperties,
		&i.AverageRating,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const incrementLandlordPropertyCount = `-- name: IncrementLandlordPropertyCount :exec
UPDATE landlord_profiles 
SET total_properties = total_properties + 1, updated_at = NOW()
WHERE user_id = $1
`

// Increment landlord property count
func (q *Queries) IncrementLandlordPropertyCount(ctx context.Context, userID int64) error {
	_, err := q.db.Exec(ctx, incrementLandlordPropertyCount, userID)
	return err
}

const listLandlordsByPropertyCount = `-- name: ListLandlordsByPropertyCount :many
SELECT lp.id, lp.user_id, lp.business_name, lp.business_registration, lp.tax_id, lp.bank_name, lp.bank_account, lp.bank_account_name, lp.guarantor_name, lp.guarantor_phone, lp.guarantor_address, lp.total_properties, lp.average_rating, lp.created_at, lp.updated_at, u.first_name, u.last_name, u.email 
FROM landlord_profiles lp
JOIN users u ON lp.user_id = u.id
WHERE u.is_active = true
ORDER BY lp.total_properties DESC, lp.average_rating DESC
LIMIT $1 OFFSET $2
`

type ListLandlordsByPropertyCountParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListLandlordsByPropertyCountRow struct {
	ID                   int64              `json:"id"`
	UserID               int64              `json:"user_id"`
	BusinessName         pgtype.Text        `json:"business_name"`
	BusinessRegistration pgtype.Text        `json:"business_registration"`
	TaxID                pgtype.Text        `json:"tax_id"`
	BankName             pgtype.Text        `json:"bank_name"`
	BankAccount          pgtype.Text        `json:"bank_account"`
	BankAccountName      pgtype.Text        `json:"bank_account_name"`
	GuarantorName        pgtype.Text        `json:"guarantor_name"`
	GuarantorPhone       pgtype.Text        `json:"guarantor_phone"`
	GuarantorAddress     pgtype.Text        `json:"guarantor_address"`
	TotalProperties      pgtype.Int4        `json:"total_properties"`
	AverageRating        pgtype.Numeric     `json:"average_rating"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
	FirstName            string             `json:"first_name"`
	LastName             string             `json:"last_name"`
	Email                string             `json:"email"`
}

// List landlords by property count
func (q *Queries) ListLandlordsByPropertyCount(ctx context.Context, arg ListLandlordsByPropertyCountParams) ([]ListLandlordsByPropertyCountRow, error) {
	rows, err := q.db.Query(ctx, listLandlordsByPropertyCount, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListLandlordsByPropertyCountRow{}
	for rows.Next() {
		var i ListLandlordsByPropertyCountRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.BusinessName,
			&i.BusinessRegistration,
			&i.TaxID,
			&i.BankName,
			&i.BankAccount,
			&i.BankAccountName,
			&i.GuarantorName,
			&i.GuarantorPhone,
			&i.GuarantorAddress,
			&i.TotalProperties,
			&i.AverageRating,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FirstName,
			&i.LastName,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTopLandlordsByRating = `-- name: ListTopLandlordsByRating :many
SELECT lp.id, lp.user_id, lp.business_name, lp.business_registration, lp.tax_id, lp.bank_name, lp.bank_account, lp.bank_account_name, lp.guarantor_name, lp.guarantor_phone, lp.guarantor_address, lp.total_properties, lp.average_rating, lp.created_at, lp.updated_at, u.first_name, u.last_name, u.email 
FROM landlord_profiles lp
JOIN users u ON lp.user_id = u.id
WHERE u.is_active = true AND lp.total_properties > 0
ORDER BY lp.average_rating DESC, lp.total_properties DESC
LIMIT $1 OFFSET $2
`

type ListTopLandlordsByRatingParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListTopLandlordsByRatingRow struct {
	ID                   int64              `json:"id"`
	UserID               int64              `json:"user_id"`
	BusinessName         pgtype.Text        `json:"business_name"`
	BusinessRegistration pgtype.Text        `json:"business_registration"`
	TaxID                pgtype.Text        `json:"tax_id"`
	BankName             pgtype.Text        `json:"bank_name"`
	BankAccount          pgtype.Text        `json:"bank_account"`
	BankAccountName      pgtype.Text        `json:"bank_account_name"`
	GuarantorName        pgtype.Text        `json:"guarantor_name"`
	GuarantorPhone       pgtype.Text        `json:"guarantor_phone"`
	GuarantorAddress     pgtype.Text        `json:"guarantor_address"`
	TotalProperties      pgtype.Int4        `json:"total_properties"`
	AverageRating        pgtype.Numeric     `json:"average_rating"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
	FirstName            string             `json:"first_name"`
	LastName             string             `json:"last_name"`
	Email                string             `json:"email"`
}

// List top landlords by rating
func (q *Queries) ListTopLandlordsByRating(ctx context.Context, arg ListTopLandlordsByRatingParams) ([]ListTopLandlordsByRatingRow, error) {
	rows, err := q.db.Query(ctx, listTopLandlordsByRating, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTopLandlordsByRatingRow{}
	for rows.Next() {
		var i ListTopLandlordsByRatingRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.BusinessName,
			&i.BusinessRegistration,
			&i.TaxID,
			&i.BankName,
			&i.BankAccount,
			&i.BankAccountName,
			&i.GuarantorName,
			&i.GuarantorPhone,
			&i.GuarantorAddress,
			&i.TotalProperties,
			&i.AverageRating,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FirstName,
			&i.LastName,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateLandlordBankingDetails = `-- name: UpdateLandlordBankingDetails :one
UPDATE landlord_profiles 
SET bank_name = $2, bank_account = $3, bank_account_name = $4, updated_at = NOW()
WHERE user_id = $1 
RETURNING id, user_id, business_name, business_registration, tax_id, bank_name, bank_account, bank_account_name, guarantor_name, guarantor_phone, guarantor_address, total_properties, average_rating, created_at, updated_at
`

type UpdateLandlordBankingDetailsParams struct {
	UserID          int64       `json:"user_id"`
	BankName        pgtype.Text `json:"bank_name"`
	BankAccount     pgtype.Text `json:"bank_account"`
	BankAccountName pgtype.Text `json:"bank_account_name"`
}

// Update landlord banking details
func (q *Queries) UpdateLandlordBankingDetails(ctx context.Context, arg UpdateLandlordBankingDetailsParams) (LandlordProfile, error) {
	row := q.db.QueryRow(ctx, updateLandlordBankingDetails,
		arg.UserID,
		arg.BankName,
		arg.BankAccount,
		arg.BankAccountName,
	)
	var i LandlordProfile
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BusinessName,
		&i.BusinessRegistration,
		&i.TaxID,
		&i.BankName,
		&i.BankAccount,
		&i.BankAccountName,
		&i.GuarantorName,
		&i.GuarantorPhone,
		&i.GuarantorAddress,
		&i.TotalProperties,
		&i.AverageRating,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateLandlordBusinessDetails = `-- name: UpdateLandlordBusinessDetails :one
UPDATE landlord_profiles 
SET business_name = $2, business_registration = $3, tax_id = $4, updated_at = NOW()
WHERE user_id = $1 
RETURNING id, user_id, business_name, business_registration, tax_id, bank_name, bank_account, bank_account_name, guarantor_name, guarantor_phone, guarantor_address, total_properties, average_rating, created_at, updated_at
`

type UpdateLandlordBusinessDetailsParams struct {
	UserID               int64       `json:"user_id"`
	BusinessName         pgtype.Text `json:"business_name"`
	BusinessRegistration pgtype.Text `json:"business_registration"`
	TaxID                pgtype.Text `json:"tax_id"`
}

// Update landlord business details
func (q *Queries) UpdateLandlordBusinessDetails(ctx context.Context, arg UpdateLandlordBusinessDetailsParams) (LandlordProfile, error) {
	row := q.db.QueryRow(ctx, updateLandlordBusinessDetails,
		arg.UserID,
		arg.BusinessName,
		arg.BusinessRegistration,
		arg.TaxID,
	)
	var i LandlordProfile
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BusinessName,
		&i.BusinessRegistration,
		&i.TaxID,
		&i.BankName,
		&i.BankAccount,
		&i.BankAccountName,
		&i.GuarantorName,
		&i.GuarantorPhone,
		&i.GuarantorAddress,
		&i.TotalProperties,
		&i.AverageRating,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateLandlordGuarantorDetails = `-- name: UpdateLandlordGuarantorDetails :one
UPDATE landlord_profiles 
SET guarantor_name = $2, guarantor_phone = $3, guarantor_address = $4, updated_at = NOW()
WHERE user_id = $1 
RETURNING id, user_id, business_name, business_registration, tax_id, bank_name, bank_account, bank_account_name, guarantor_name, guarantor_phone, guarantor_address, total_properties, average_rating, created_at, updated_at
`

type UpdateLandlordGuarantorDetailsParams struct {
	UserID           int64       `json:"user_id"`
	GuarantorName    pgtype.Text `json:"guarantor_name"`
	GuarantorPhone   pgtype.Text `json:"guarantor_phone"`
	GuarantorAddress pgtype.Text `json:"guarantor_address"`
}

// Update landlord guarantor details
func (q *Queries) UpdateLandlordGuarantorDetails(ctx context.Context, arg UpdateLandlordGuarantorDetailsParams) (LandlordProfile, error) {
	row := q.db.QueryRow(ctx, updateLandlordGuarantorDetails,
		arg.UserID,
		arg.GuarantorName,
		arg.GuarantorPhone,
		arg.GuarantorAddress,
	)
	var i LandlordProfile
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BusinessName,
		&i.BusinessRegistration,
		&i.TaxID,
		&i.BankName,
		&i.BankAccount,
		&i.BankAccountName,
		&i.GuarantorName,
		&i.GuarantorPhone,
		&i.GuarantorAddress,
		&i.TotalProperties,
		&i.AverageRating,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateLandlordProfile = `-- name: UpdateLandlordProfile :one
UPDATE landlord_profiles 
SET business_name = $2, business_registration = $3, tax_id = $4,
    bank_name = $5, bank_account = $6, bank_account_name = $7,
    guarantor_name = $8, guarantor_phone = $9, guarantor_address = $10,
    updated_at = NOW()
WHERE user_id = $1 
RETURNING id, user_id, business_name, business_registration, tax_id, bank_name, bank_account, bank_account_name, guarantor_name, guarantor_phone, guarantor_address, total_properties, average_rating, created_at, updated_at
`

type UpdateLandlordProfileParams struct {
	UserID               int64       `json:"user_id"`
	BusinessName         pgtype.Text `json:"business_name"`
	BusinessRegistration pgtype.Text `json:"business_registration"`
	TaxID                pgtype.Text `json:"tax_id"`
	BankName             pgtype.Text `json:"bank_name"`
	BankAccount          pgtype.Text `json:"bank_account"`
	BankAccountName      pgtype.Text `json:"bank_account_name"`
	GuarantorName        pgtype.Text `json:"guarantor_name"`
	GuarantorPhone       pgtype.Text `json:"guarantor_phone"`
	GuarantorAddress     pgtype.Text `json:"guarantor_address"`
}

// Update landlord profile
func (q *Queries) UpdateLandlordProfile(ctx context.Context, arg UpdateLandlordProfileParams) (LandlordProfile, error) {
	row := q.db.QueryRow(ctx, updateLandlordProfile,
		arg.UserID,
		arg.BusinessName,
		arg.BusinessRegistration,
		arg.TaxID,
		arg.BankName,
		arg.BankAccount,
		arg.BankAccountName,
		arg.GuarantorName,
		arg.GuarantorPhone,
		arg.GuarantorAddress,
	)
	var i LandlordProfile
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BusinessName,
		&i.BusinessRegistration,
		&i.TaxID,
		&i.BankName,
		&i.BankAccount,
		&i.BankAccountName,
		&i.GuarantorName,
		&i.GuarantorPhone,
		&i.GuarantorAddress,
		&i.TotalProperties,
		&i.AverageRating,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateLandlordStats = `-- name: UpdateLandlordStats :one
UPDATE landlord_profiles 
SET total_properties = $2, average_rating = $3, updated_at = NOW()
WHERE user_id = $1 
RETURNING id, user_id, business_name, business_registration, tax_id, bank_name, bank_account, bank_account_name, guarantor_name, guarantor_phone, guarantor_address, total_properties, average_rating, created_at, updated_at
`

type UpdateLandlordStatsParams struct {
	UserID          int64          `json:"user_id"`
	TotalProperties pgtype.Int4    `json:"total_properties"`
	AverageRating   pgtype.Numeric `json:"average_rating"`
}

// Update landlord stats
func (q *Queries) UpdateLandlordStats(ctx context.Context, arg UpdateLandlordStatsParams) (LandlordProfile, error) {
	row := q.db.QueryRow(ctx, updateLandlordStats, arg.UserID, arg.TotalProperties, arg.AverageRating)
	var i LandlordProfile
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BusinessName,
		&i.BusinessRegistration,
		&i.TaxID,
		&i.BankName,
		&i.BankAccount,
		&i.BankAccountName,
		&i.GuarantorName,
		&i.GuarantorPhone,
		&i.GuarantorAddress,
		&i.TotalProperties,
		&i.AverageRating,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
