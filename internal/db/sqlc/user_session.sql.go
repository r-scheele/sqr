// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: user_session.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const cleanupExpiredSessions = `-- name: CleanupExpiredSessions :exec
DELETE FROM user_sessions 
WHERE expires_at <= NOW() AND is_active = false
`

// Clean up expired sessions
func (q *Queries) CleanupExpiredSessions(ctx context.Context) error {
	_, err := q.db.Exec(ctx, cleanupExpiredSessions)
	return err
}

const cleanupOldSessions = `-- name: CleanupOldSessions :exec
DELETE FROM user_sessions 
WHERE created_at < $1
`

// Clean up old sessions
func (q *Queries) CleanupOldSessions(ctx context.Context, createdAt pgtype.Timestamptz) error {
	_, err := q.db.Exec(ctx, cleanupOldSessions, createdAt)
	return err
}

const countUserActiveSessions = `-- name: CountUserActiveSessions :one
SELECT COUNT(*) FROM user_sessions 
WHERE user_id = $1 AND is_active = true AND expires_at > NOW()
`

// Count user active sessions
func (q *Queries) CountUserActiveSessions(ctx context.Context, userID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countUserActiveSessions, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUserTotalSessions = `-- name: CountUserTotalSessions :one
SELECT COUNT(*) FROM user_sessions 
WHERE user_id = $1
`

// Count user total sessions
func (q *Queries) CountUserTotalSessions(ctx context.Context, userID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countUserTotalSessions, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createUserSession = `-- name: CreateUserSession :one
INSERT INTO user_sessions (
  user_id, session_token, device_info, ip_address, location_data, expires_at
) VALUES (
  $1, $2, $3, $4, $5, $6
) RETURNING id, user_id, session_token, device_info, ip_address, location_data, expires_at, is_active, created_at
`

type CreateUserSessionParams struct {
	UserID       int64       `json:"user_id"`
	SessionToken string      `json:"session_token"`
	DeviceInfo   pgtype.Text `json:"device_info"`
	IpAddress    pgtype.Text `json:"ip_address"`
	LocationData pgtype.Text `json:"location_data"`
	ExpiresAt    time.Time   `json:"expires_at"`
}

// Create user session
func (q *Queries) CreateUserSession(ctx context.Context, arg CreateUserSessionParams) (UserSession, error) {
	row := q.db.QueryRow(ctx, createUserSession,
		arg.UserID,
		arg.SessionToken,
		arg.DeviceInfo,
		arg.IpAddress,
		arg.LocationData,
		arg.ExpiresAt,
	)
	var i UserSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SessionToken,
		&i.DeviceInfo,
		&i.IpAddress,
		&i.LocationData,
		&i.ExpiresAt,
		&i.IsActive,
		&i.CreatedAt,
	)
	return i, err
}

const deactivateOtherUserSessions = `-- name: DeactivateOtherUserSessions :exec
UPDATE user_sessions 
SET is_active = false
WHERE user_id = $1 AND session_token != $2 AND is_active = true
`

type DeactivateOtherUserSessionsParams struct {
	UserID       int64  `json:"user_id"`
	SessionToken string `json:"session_token"`
}

// Deactivate all user sessions except current
func (q *Queries) DeactivateOtherUserSessions(ctx context.Context, arg DeactivateOtherUserSessionsParams) error {
	_, err := q.db.Exec(ctx, deactivateOtherUserSessions, arg.UserID, arg.SessionToken)
	return err
}

const deactivateSession = `-- name: DeactivateSession :exec
UPDATE user_sessions 
SET is_active = false
WHERE session_token = $1
`

// Deactivate session
func (q *Queries) DeactivateSession(ctx context.Context, sessionToken string) error {
	_, err := q.db.Exec(ctx, deactivateSession, sessionToken)
	return err
}

const deactivateUserSessions = `-- name: DeactivateUserSessions :exec
UPDATE user_sessions 
SET is_active = false
WHERE user_id = $1 AND is_active = true
`

// Deactivate user sessions
func (q *Queries) DeactivateUserSessions(ctx context.Context, userID int64) error {
	_, err := q.db.Exec(ctx, deactivateUserSessions, userID)
	return err
}

const deleteAllUserSessions = `-- name: DeleteAllUserSessions :exec
DELETE FROM user_sessions 
WHERE user_id = $1
`

// Delete all user sessions
func (q *Queries) DeleteAllUserSessions(ctx context.Context, userID int64) error {
	_, err := q.db.Exec(ctx, deleteAllUserSessions, userID)
	return err
}

const deleteUserSession = `-- name: DeleteUserSession :exec
DELETE FROM user_sessions 
WHERE id = $1
`

// Delete user session
func (q *Queries) DeleteUserSession(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteUserSession, id)
	return err
}

const getExpiredSessions = `-- name: GetExpiredSessions :many
SELECT id, user_id, session_token, device_info, ip_address, location_data, expires_at, is_active, created_at FROM user_sessions 
WHERE expires_at <= NOW() AND is_active = true
ORDER BY expires_at ASC
LIMIT $1 OFFSET $2
`

type GetExpiredSessionsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

// Get expired sessions
func (q *Queries) GetExpiredSessions(ctx context.Context, arg GetExpiredSessionsParams) ([]UserSession, error) {
	rows, err := q.db.Query(ctx, getExpiredSessions, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserSession{}
	for rows.Next() {
		var i UserSession
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SessionToken,
			&i.DeviceInfo,
			&i.IpAddress,
			&i.LocationData,
			&i.ExpiresAt,
			&i.IsActive,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSessionStatistics = `-- name: GetSessionStatistics :one
SELECT 
  COUNT(*) as total_sessions,
  COUNT(CASE WHEN is_active = true AND expires_at > NOW() THEN 1 END) as active_sessions,
  COUNT(CASE WHEN expires_at <= NOW() THEN 1 END) as expired_sessions,
  COUNT(DISTINCT user_id) as unique_users,
  COUNT(DISTINCT ip_address) as unique_ips
FROM user_sessions
`

type GetSessionStatisticsRow struct {
	TotalSessions   int64 `json:"total_sessions"`
	ActiveSessions  int64 `json:"active_sessions"`
	ExpiredSessions int64 `json:"expired_sessions"`
	UniqueUsers     int64 `json:"unique_users"`
	UniqueIps       int64 `json:"unique_ips"`
}

// Get session statistics
func (q *Queries) GetSessionStatistics(ctx context.Context) (GetSessionStatisticsRow, error) {
	row := q.db.QueryRow(ctx, getSessionStatistics)
	var i GetSessionStatisticsRow
	err := row.Scan(
		&i.TotalSessions,
		&i.ActiveSessions,
		&i.ExpiredSessions,
		&i.UniqueUsers,
		&i.UniqueIps,
	)
	return i, err
}

const getSessionWithUserDetails = `-- name: GetSessionWithUserDetails :one
SELECT us.id, us.user_id, us.session_token, us.device_info, us.ip_address, us.location_data, us.expires_at, us.is_active, us.created_at, u.first_name, u.last_name, u.email, u.user_type
FROM user_sessions us
JOIN users u ON us.user_id = u.id
WHERE us.session_token = $1 AND us.is_active = true AND us.expires_at > NOW()
LIMIT 1
`

type GetSessionWithUserDetailsRow struct {
	ID           int64              `json:"id"`
	UserID       int64              `json:"user_id"`
	SessionToken string             `json:"session_token"`
	DeviceInfo   pgtype.Text        `json:"device_info"`
	IpAddress    pgtype.Text        `json:"ip_address"`
	LocationData pgtype.Text        `json:"location_data"`
	ExpiresAt    time.Time          `json:"expires_at"`
	IsActive     pgtype.Bool        `json:"is_active"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	FirstName    string             `json:"first_name"`
	LastName     string             `json:"last_name"`
	Email        string             `json:"email"`
	UserType     UserTypeEnum       `json:"user_type"`
}

// Get session with user details
func (q *Queries) GetSessionWithUserDetails(ctx context.Context, sessionToken string) (GetSessionWithUserDetailsRow, error) {
	row := q.db.QueryRow(ctx, getSessionWithUserDetails, sessionToken)
	var i GetSessionWithUserDetailsRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SessionToken,
		&i.DeviceInfo,
		&i.IpAddress,
		&i.LocationData,
		&i.ExpiresAt,
		&i.IsActive,
		&i.CreatedAt,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.UserType,
	)
	return i, err
}

const getSessionsByIPAddress = `-- name: GetSessionsByIPAddress :many
SELECT us.id, us.user_id, us.session_token, us.device_info, us.ip_address, us.location_data, us.expires_at, us.is_active, us.created_at, u.first_name, u.last_name, u.email
FROM user_sessions us
JOIN users u ON us.user_id = u.id
WHERE us.ip_address = $1
ORDER BY us.created_at DESC
LIMIT $2 OFFSET $3
`

type GetSessionsByIPAddressParams struct {
	IpAddress pgtype.Text `json:"ip_address"`
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
}

type GetSessionsByIPAddressRow struct {
	ID           int64              `json:"id"`
	UserID       int64              `json:"user_id"`
	SessionToken string             `json:"session_token"`
	DeviceInfo   pgtype.Text        `json:"device_info"`
	IpAddress    pgtype.Text        `json:"ip_address"`
	LocationData pgtype.Text        `json:"location_data"`
	ExpiresAt    time.Time          `json:"expires_at"`
	IsActive     pgtype.Bool        `json:"is_active"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	FirstName    string             `json:"first_name"`
	LastName     string             `json:"last_name"`
	Email        string             `json:"email"`
}

// Get sessions by IP address
func (q *Queries) GetSessionsByIPAddress(ctx context.Context, arg GetSessionsByIPAddressParams) ([]GetSessionsByIPAddressRow, error) {
	rows, err := q.db.Query(ctx, getSessionsByIPAddress, arg.IpAddress, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSessionsByIPAddressRow{}
	for rows.Next() {
		var i GetSessionsByIPAddressRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SessionToken,
			&i.DeviceInfo,
			&i.IpAddress,
			&i.LocationData,
			&i.ExpiresAt,
			&i.IsActive,
			&i.CreatedAt,
			&i.FirstName,
			&i.LastName,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserActiveSessions = `-- name: GetUserActiveSessions :many
SELECT id, user_id, session_token, device_info, ip_address, location_data, expires_at, is_active, created_at FROM user_sessions 
WHERE user_id = $1 AND is_active = true AND expires_at > NOW()
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetUserActiveSessionsParams struct {
	UserID int64 `json:"user_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

// Get user active sessions
func (q *Queries) GetUserActiveSessions(ctx context.Context, arg GetUserActiveSessionsParams) ([]UserSession, error) {
	rows, err := q.db.Query(ctx, getUserActiveSessions, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserSession{}
	for rows.Next() {
		var i UserSession
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SessionToken,
			&i.DeviceInfo,
			&i.IpAddress,
			&i.LocationData,
			&i.ExpiresAt,
			&i.IsActive,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserSessionByID = `-- name: GetUserSessionByID :one
SELECT id, user_id, session_token, device_info, ip_address, location_data, expires_at, is_active, created_at FROM user_sessions 
WHERE id = $1 LIMIT 1
`

// Get user session by ID
func (q *Queries) GetUserSessionByID(ctx context.Context, id int64) (UserSession, error) {
	row := q.db.QueryRow(ctx, getUserSessionByID, id)
	var i UserSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SessionToken,
		&i.DeviceInfo,
		&i.IpAddress,
		&i.LocationData,
		&i.ExpiresAt,
		&i.IsActive,
		&i.CreatedAt,
	)
	return i, err
}

const getUserSessionByToken = `-- name: GetUserSessionByToken :one
SELECT id, user_id, session_token, device_info, ip_address, location_data, expires_at, is_active, created_at FROM user_sessions 
WHERE session_token = $1 AND is_active = true AND expires_at > NOW()
LIMIT 1
`

// Get user session by token
func (q *Queries) GetUserSessionByToken(ctx context.Context, sessionToken string) (UserSession, error) {
	row := q.db.QueryRow(ctx, getUserSessionByToken, sessionToken)
	var i UserSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SessionToken,
		&i.DeviceInfo,
		&i.IpAddress,
		&i.LocationData,
		&i.ExpiresAt,
		&i.IsActive,
		&i.CreatedAt,
	)
	return i, err
}

const getUserSessionSummary = `-- name: GetUserSessionSummary :one
SELECT 
  COUNT(*) as total_sessions,
  COUNT(CASE WHEN is_active = true AND expires_at > NOW() THEN 1 END) as active_sessions,
  MAX(created_at) as last_session_time,
  COUNT(DISTINCT ip_address) as unique_ips
FROM user_sessions 
WHERE user_id = $1
`

type GetUserSessionSummaryRow struct {
	TotalSessions   int64       `json:"total_sessions"`
	ActiveSessions  int64       `json:"active_sessions"`
	LastSessionTime interface{} `json:"last_session_time"`
	UniqueIps       int64       `json:"unique_ips"`
}

// Get user session summary
func (q *Queries) GetUserSessionSummary(ctx context.Context, userID int64) (GetUserSessionSummaryRow, error) {
	row := q.db.QueryRow(ctx, getUserSessionSummary, userID)
	var i GetUserSessionSummaryRow
	err := row.Scan(
		&i.TotalSessions,
		&i.ActiveSessions,
		&i.LastSessionTime,
		&i.UniqueIps,
	)
	return i, err
}

const getUserSessions = `-- name: GetUserSessions :many
SELECT id, user_id, session_token, device_info, ip_address, location_data, expires_at, is_active, created_at FROM user_sessions 
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetUserSessionsParams struct {
	UserID int64 `json:"user_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

// Get user sessions
func (q *Queries) GetUserSessions(ctx context.Context, arg GetUserSessionsParams) ([]UserSession, error) {
	rows, err := q.db.Query(ctx, getUserSessions, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserSession{}
	for rows.Next() {
		var i UserSession
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SessionToken,
			&i.DeviceInfo,
			&i.IpAddress,
			&i.LocationData,
			&i.ExpiresAt,
			&i.IsActive,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSessionActivity = `-- name: UpdateSessionActivity :exec
UPDATE user_sessions 
SET expires_at = $2
WHERE session_token = $1 AND is_active = true
`

type UpdateSessionActivityParams struct {
	SessionToken string    `json:"session_token"`
	ExpiresAt    time.Time `json:"expires_at"`
}

// Update session activity
func (q *Queries) UpdateSessionActivity(ctx context.Context, arg UpdateSessionActivityParams) error {
	_, err := q.db.Exec(ctx, updateSessionActivity, arg.SessionToken, arg.ExpiresAt)
	return err
}

const updateSessionLocation = `-- name: UpdateSessionLocation :exec
UPDATE user_sessions 
SET ip_address = $2, location_data = $3
WHERE session_token = $1
`

type UpdateSessionLocationParams struct {
	SessionToken string      `json:"session_token"`
	IpAddress    pgtype.Text `json:"ip_address"`
	LocationData pgtype.Text `json:"location_data"`
}

// Update session location
func (q *Queries) UpdateSessionLocation(ctx context.Context, arg UpdateSessionLocationParams) error {
	_, err := q.db.Exec(ctx, updateSessionLocation, arg.SessionToken, arg.IpAddress, arg.LocationData)
	return err
}
