// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: chatbot_conversation.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const cleanupOldConversations = `-- name: CleanupOldConversations :exec
DELETE FROM chatbot_conversations 
WHERE created_at < $1 AND is_escalated = false
`

// Clean up old conversations
func (q *Queries) CleanupOldConversations(ctx context.Context, createdAt pgtype.Timestamptz) error {
	_, err := q.db.Exec(ctx, cleanupOldConversations, createdAt)
	return err
}

const countConversationsByIntent = `-- name: CountConversationsByIntent :one
SELECT COUNT(*) FROM chatbot_conversations 
WHERE intent = $1
`

// Count conversations by intent
func (q *Queries) CountConversationsByIntent(ctx context.Context, intent pgtype.Text) (int64, error) {
	row := q.db.QueryRow(ctx, countConversationsByIntent, intent)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countConversationsBySession = `-- name: CountConversationsBySession :one
SELECT COUNT(*) FROM chatbot_conversations 
WHERE session_id = $1
`

// Count conversations by session
func (q *Queries) CountConversationsBySession(ctx context.Context, sessionID string) (int64, error) {
	row := q.db.QueryRow(ctx, countConversationsBySession, sessionID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countConversationsByUser = `-- name: CountConversationsByUser :one
SELECT COUNT(*) FROM chatbot_conversations 
WHERE user_id = $1
`

// Count conversations by user
func (q *Queries) CountConversationsByUser(ctx context.Context, userID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countConversationsByUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countEscalatedConversations = `-- name: CountEscalatedConversations :one
SELECT COUNT(*) FROM chatbot_conversations 
WHERE is_escalated = true
`

// Count escalated conversations
func (q *Queries) CountEscalatedConversations(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countEscalatedConversations)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createChatbotConversation = `-- name: CreateChatbotConversation :one
INSERT INTO chatbot_conversations (
  user_id, session_id, message_text, response_text, intent, entities, confidence_score
) VALUES (
  $1, $2, $3, $4, $5, $6, $7
) RETURNING id, user_id, session_id, message_text, response_text, intent, entities, confidence_score, is_escalated, escalated_to, created_at
`

type CreateChatbotConversationParams struct {
	UserID          int64          `json:"user_id"`
	SessionID       string         `json:"session_id"`
	MessageText     string         `json:"message_text"`
	ResponseText    string         `json:"response_text"`
	Intent          pgtype.Text    `json:"intent"`
	Entities        pgtype.Text    `json:"entities"`
	ConfidenceScore pgtype.Numeric `json:"confidence_score"`
}

// Create chatbot conversation
func (q *Queries) CreateChatbotConversation(ctx context.Context, arg CreateChatbotConversationParams) (ChatbotConversation, error) {
	row := q.db.QueryRow(ctx, createChatbotConversation,
		arg.UserID,
		arg.SessionID,
		arg.MessageText,
		arg.ResponseText,
		arg.Intent,
		arg.Entities,
		arg.ConfidenceScore,
	)
	var i ChatbotConversation
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SessionID,
		&i.MessageText,
		&i.ResponseText,
		&i.Intent,
		&i.Entities,
		&i.ConfidenceScore,
		&i.IsEscalated,
		&i.EscalatedTo,
		&i.CreatedAt,
	)
	return i, err
}

const deleteChatbotConversation = `-- name: DeleteChatbotConversation :exec
DELETE FROM chatbot_conversations 
WHERE id = $1
`

// Delete conversation
func (q *Queries) DeleteChatbotConversation(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteChatbotConversation, id)
	return err
}

const deleteConversationsBySession = `-- name: DeleteConversationsBySession :exec
DELETE FROM chatbot_conversations 
WHERE session_id = $1
`

// Delete conversations by session
func (q *Queries) DeleteConversationsBySession(ctx context.Context, sessionID string) error {
	_, err := q.db.Exec(ctx, deleteConversationsBySession, sessionID)
	return err
}

const escalateConversation = `-- name: EscalateConversation :one
UPDATE chatbot_conversations 
SET is_escalated = true, escalated_to = $2
WHERE id = $1 
RETURNING id, user_id, session_id, message_text, response_text, intent, entities, confidence_score, is_escalated, escalated_to, created_at
`

type EscalateConversationParams struct {
	ID          int64       `json:"id"`
	EscalatedTo pgtype.Int8 `json:"escalated_to"`
}

// Update conversation escalation
func (q *Queries) EscalateConversation(ctx context.Context, arg EscalateConversationParams) (ChatbotConversation, error) {
	row := q.db.QueryRow(ctx, escalateConversation, arg.ID, arg.EscalatedTo)
	var i ChatbotConversation
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SessionID,
		&i.MessageText,
		&i.ResponseText,
		&i.Intent,
		&i.Entities,
		&i.ConfidenceScore,
		&i.IsEscalated,
		&i.EscalatedTo,
		&i.CreatedAt,
	)
	return i, err
}

const getChatbotConversationByID = `-- name: GetChatbotConversationByID :one
SELECT id, user_id, session_id, message_text, response_text, intent, entities, confidence_score, is_escalated, escalated_to, created_at FROM chatbot_conversations 
WHERE id = $1 LIMIT 1
`

// Get chatbot conversation by ID
func (q *Queries) GetChatbotConversationByID(ctx context.Context, id int64) (ChatbotConversation, error) {
	row := q.db.QueryRow(ctx, getChatbotConversationByID, id)
	var i ChatbotConversation
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SessionID,
		&i.MessageText,
		&i.ResponseText,
		&i.Intent,
		&i.Entities,
		&i.ConfidenceScore,
		&i.IsEscalated,
		&i.EscalatedTo,
		&i.CreatedAt,
	)
	return i, err
}

const getChatbotStatistics = `-- name: GetChatbotStatistics :one
SELECT 
  COUNT(*) as total_conversations,
  COUNT(DISTINCT user_id) as unique_users,
  COUNT(DISTINCT session_id) as unique_sessions,
  COUNT(CASE WHEN is_escalated = true THEN 1 END) as escalated_count,
  AVG(confidence_score) as average_confidence,
  COUNT(CASE WHEN confidence_score < 0.5 THEN 1 END) as low_confidence_count
FROM chatbot_conversations 
WHERE created_at >= $1
`

type GetChatbotStatisticsRow struct {
	TotalConversations int64   `json:"total_conversations"`
	UniqueUsers        int64   `json:"unique_users"`
	UniqueSessions     int64   `json:"unique_sessions"`
	EscalatedCount     int64   `json:"escalated_count"`
	AverageConfidence  float64 `json:"average_confidence"`
	LowConfidenceCount int64   `json:"low_confidence_count"`
}

// Get chatbot statistics
func (q *Queries) GetChatbotStatistics(ctx context.Context, createdAt pgtype.Timestamptz) (GetChatbotStatisticsRow, error) {
	row := q.db.QueryRow(ctx, getChatbotStatistics, createdAt)
	var i GetChatbotStatisticsRow
	err := row.Scan(
		&i.TotalConversations,
		&i.UniqueUsers,
		&i.UniqueSessions,
		&i.EscalatedCount,
		&i.AverageConfidence,
		&i.LowConfidenceCount,
	)
	return i, err
}

const getConversationsByAgent = `-- name: GetConversationsByAgent :many
SELECT cc.id, cc.user_id, cc.session_id, cc.message_text, cc.response_text, cc.intent, cc.entities, cc.confidence_score, cc.is_escalated, cc.escalated_to, cc.created_at, u.first_name, u.last_name, u.email
FROM chatbot_conversations cc
JOIN users u ON cc.user_id = u.id
WHERE cc.escalated_to = $1
ORDER BY cc.created_at DESC
LIMIT $2 OFFSET $3
`

type GetConversationsByAgentParams struct {
	EscalatedTo pgtype.Int8 `json:"escalated_to"`
	Limit       int32       `json:"limit"`
	Offset      int32       `json:"offset"`
}

type GetConversationsByAgentRow struct {
	ID              int64              `json:"id"`
	UserID          int64              `json:"user_id"`
	SessionID       string             `json:"session_id"`
	MessageText     string             `json:"message_text"`
	ResponseText    string             `json:"response_text"`
	Intent          pgtype.Text        `json:"intent"`
	Entities        pgtype.Text        `json:"entities"`
	ConfidenceScore pgtype.Numeric     `json:"confidence_score"`
	IsEscalated     pgtype.Bool        `json:"is_escalated"`
	EscalatedTo     pgtype.Int8        `json:"escalated_to"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	FirstName       string             `json:"first_name"`
	LastName        string             `json:"last_name"`
	Email           string             `json:"email"`
}

// Get conversations by agent
func (q *Queries) GetConversationsByAgent(ctx context.Context, arg GetConversationsByAgentParams) ([]GetConversationsByAgentRow, error) {
	rows, err := q.db.Query(ctx, getConversationsByAgent, arg.EscalatedTo, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetConversationsByAgentRow{}
	for rows.Next() {
		var i GetConversationsByAgentRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SessionID,
			&i.MessageText,
			&i.ResponseText,
			&i.Intent,
			&i.Entities,
			&i.ConfidenceScore,
			&i.IsEscalated,
			&i.EscalatedTo,
			&i.CreatedAt,
			&i.FirstName,
			&i.LastName,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getConversationsByIntent = `-- name: GetConversationsByIntent :many
SELECT cc.id, cc.user_id, cc.session_id, cc.message_text, cc.response_text, cc.intent, cc.entities, cc.confidence_score, cc.is_escalated, cc.escalated_to, cc.created_at, u.first_name, u.last_name, u.email
FROM chatbot_conversations cc
JOIN users u ON cc.user_id = u.id
WHERE cc.intent = $1
ORDER BY cc.created_at DESC
LIMIT $2 OFFSET $3
`

type GetConversationsByIntentParams struct {
	Intent pgtype.Text `json:"intent"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

type GetConversationsByIntentRow struct {
	ID              int64              `json:"id"`
	UserID          int64              `json:"user_id"`
	SessionID       string             `json:"session_id"`
	MessageText     string             `json:"message_text"`
	ResponseText    string             `json:"response_text"`
	Intent          pgtype.Text        `json:"intent"`
	Entities        pgtype.Text        `json:"entities"`
	ConfidenceScore pgtype.Numeric     `json:"confidence_score"`
	IsEscalated     pgtype.Bool        `json:"is_escalated"`
	EscalatedTo     pgtype.Int8        `json:"escalated_to"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	FirstName       string             `json:"first_name"`
	LastName        string             `json:"last_name"`
	Email           string             `json:"email"`
}

// Get conversations by intent
func (q *Queries) GetConversationsByIntent(ctx context.Context, arg GetConversationsByIntentParams) ([]GetConversationsByIntentRow, error) {
	rows, err := q.db.Query(ctx, getConversationsByIntent, arg.Intent, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetConversationsByIntentRow{}
	for rows.Next() {
		var i GetConversationsByIntentRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SessionID,
			&i.MessageText,
			&i.ResponseText,
			&i.Intent,
			&i.Entities,
			&i.ConfidenceScore,
			&i.IsEscalated,
			&i.EscalatedTo,
			&i.CreatedAt,
			&i.FirstName,
			&i.LastName,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getConversationsBySession = `-- name: GetConversationsBySession :many
SELECT id, user_id, session_id, message_text, response_text, intent, entities, confidence_score, is_escalated, escalated_to, created_at FROM chatbot_conversations 
WHERE session_id = $1
ORDER BY created_at ASC
LIMIT $2 OFFSET $3
`

type GetConversationsBySessionParams struct {
	SessionID string `json:"session_id"`
	Limit     int32  `json:"limit"`
	Offset    int32  `json:"offset"`
}

// Get conversations by session
func (q *Queries) GetConversationsBySession(ctx context.Context, arg GetConversationsBySessionParams) ([]ChatbotConversation, error) {
	rows, err := q.db.Query(ctx, getConversationsBySession, arg.SessionID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ChatbotConversation{}
	for rows.Next() {
		var i ChatbotConversation
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SessionID,
			&i.MessageText,
			&i.ResponseText,
			&i.Intent,
			&i.Entities,
			&i.ConfidenceScore,
			&i.IsEscalated,
			&i.EscalatedTo,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getConversationsByUser = `-- name: GetConversationsByUser :many
SELECT id, user_id, session_id, message_text, response_text, intent, entities, confidence_score, is_escalated, escalated_to, created_at FROM chatbot_conversations 
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetConversationsByUserParams struct {
	UserID int64 `json:"user_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

// Get conversations by user
func (q *Queries) GetConversationsByUser(ctx context.Context, arg GetConversationsByUserParams) ([]ChatbotConversation, error) {
	rows, err := q.db.Query(ctx, getConversationsByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ChatbotConversation{}
	for rows.Next() {
		var i ChatbotConversation
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SessionID,
			&i.MessageText,
			&i.ResponseText,
			&i.Intent,
			&i.Entities,
			&i.ConfidenceScore,
			&i.IsEscalated,
			&i.EscalatedTo,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDailyConversationCounts = `-- name: GetDailyConversationCounts :many
SELECT 
  DATE(created_at) as conversation_date,
  COUNT(*) as conversation_count,
  COUNT(DISTINCT user_id) as unique_users,
  COUNT(CASE WHEN is_escalated = true THEN 1 END) as escalated_count
FROM chatbot_conversations 
WHERE created_at >= $1
GROUP BY DATE(created_at)
ORDER BY conversation_date DESC
LIMIT $2 OFFSET $3
`

type GetDailyConversationCountsParams struct {
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	Limit     int32              `json:"limit"`
	Offset    int32              `json:"offset"`
}

type GetDailyConversationCountsRow struct {
	ConversationDate  pgtype.Date `json:"conversation_date"`
	ConversationCount int64       `json:"conversation_count"`
	UniqueUsers       int64       `json:"unique_users"`
	EscalatedCount    int64       `json:"escalated_count"`
}

// Get daily conversation counts
func (q *Queries) GetDailyConversationCounts(ctx context.Context, arg GetDailyConversationCountsParams) ([]GetDailyConversationCountsRow, error) {
	rows, err := q.db.Query(ctx, getDailyConversationCounts, arg.CreatedAt, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDailyConversationCountsRow{}
	for rows.Next() {
		var i GetDailyConversationCountsRow
		if err := rows.Scan(
			&i.ConversationDate,
			&i.ConversationCount,
			&i.UniqueUsers,
			&i.EscalatedCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEscalatedConversations = `-- name: GetEscalatedConversations :many
SELECT cc.id, cc.user_id, cc.session_id, cc.message_text, cc.response_text, cc.intent, cc.entities, cc.confidence_score, cc.is_escalated, cc.escalated_to, cc.created_at, u.first_name, u.last_name, u.email,
       escalated_user.first_name as escalated_to_first_name, escalated_user.last_name as escalated_to_last_name
FROM chatbot_conversations cc
JOIN users u ON cc.user_id = u.id
LEFT JOIN users escalated_user ON cc.escalated_to = escalated_user.id
WHERE cc.is_escalated = true
ORDER BY cc.created_at DESC
LIMIT $1 OFFSET $2
`

type GetEscalatedConversationsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetEscalatedConversationsRow struct {
	ID                   int64              `json:"id"`
	UserID               int64              `json:"user_id"`
	SessionID            string             `json:"session_id"`
	MessageText          string             `json:"message_text"`
	ResponseText         string             `json:"response_text"`
	Intent               pgtype.Text        `json:"intent"`
	Entities             pgtype.Text        `json:"entities"`
	ConfidenceScore      pgtype.Numeric     `json:"confidence_score"`
	IsEscalated          pgtype.Bool        `json:"is_escalated"`
	EscalatedTo          pgtype.Int8        `json:"escalated_to"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	FirstName            string             `json:"first_name"`
	LastName             string             `json:"last_name"`
	Email                string             `json:"email"`
	EscalatedToFirstName pgtype.Text        `json:"escalated_to_first_name"`
	EscalatedToLastName  pgtype.Text        `json:"escalated_to_last_name"`
}

// Get escalated conversations
func (q *Queries) GetEscalatedConversations(ctx context.Context, arg GetEscalatedConversationsParams) ([]GetEscalatedConversationsRow, error) {
	rows, err := q.db.Query(ctx, getEscalatedConversations, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEscalatedConversationsRow{}
	for rows.Next() {
		var i GetEscalatedConversationsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SessionID,
			&i.MessageText,
			&i.ResponseText,
			&i.Intent,
			&i.Entities,
			&i.ConfidenceScore,
			&i.IsEscalated,
			&i.EscalatedTo,
			&i.CreatedAt,
			&i.FirstName,
			&i.LastName,
			&i.Email,
			&i.EscalatedToFirstName,
			&i.EscalatedToLastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getIntentStatistics = `-- name: GetIntentStatistics :many
SELECT 
  intent,
  COUNT(*) as conversation_count,
  AVG(confidence_score) as average_confidence,
  COUNT(CASE WHEN is_escalated = true THEN 1 END) as escalated_count
FROM chatbot_conversations 
WHERE created_at >= $1 AND intent IS NOT NULL
GROUP BY intent
ORDER BY conversation_count DESC
LIMIT $2 OFFSET $3
`

type GetIntentStatisticsParams struct {
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	Limit     int32              `json:"limit"`
	Offset    int32              `json:"offset"`
}

type GetIntentStatisticsRow struct {
	Intent            pgtype.Text `json:"intent"`
	ConversationCount int64       `json:"conversation_count"`
	AverageConfidence float64     `json:"average_confidence"`
	EscalatedCount    int64       `json:"escalated_count"`
}

// Get intent statistics
func (q *Queries) GetIntentStatistics(ctx context.Context, arg GetIntentStatisticsParams) ([]GetIntentStatisticsRow, error) {
	rows, err := q.db.Query(ctx, getIntentStatistics, arg.CreatedAt, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetIntentStatisticsRow{}
	for rows.Next() {
		var i GetIntentStatisticsRow
		if err := rows.Scan(
			&i.Intent,
			&i.ConversationCount,
			&i.AverageConfidence,
			&i.EscalatedCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLowConfidenceConversations = `-- name: GetLowConfidenceConversations :many
SELECT cc.id, cc.user_id, cc.session_id, cc.message_text, cc.response_text, cc.intent, cc.entities, cc.confidence_score, cc.is_escalated, cc.escalated_to, cc.created_at, u.first_name, u.last_name, u.email
FROM chatbot_conversations cc
JOIN users u ON cc.user_id = u.id
WHERE cc.confidence_score < $1
ORDER BY cc.confidence_score ASC, cc.created_at DESC
LIMIT $2 OFFSET $3
`

type GetLowConfidenceConversationsParams struct {
	ConfidenceScore pgtype.Numeric `json:"confidence_score"`
	Limit           int32          `json:"limit"`
	Offset          int32          `json:"offset"`
}

type GetLowConfidenceConversationsRow struct {
	ID              int64              `json:"id"`
	UserID          int64              `json:"user_id"`
	SessionID       string             `json:"session_id"`
	MessageText     string             `json:"message_text"`
	ResponseText    string             `json:"response_text"`
	Intent          pgtype.Text        `json:"intent"`
	Entities        pgtype.Text        `json:"entities"`
	ConfidenceScore pgtype.Numeric     `json:"confidence_score"`
	IsEscalated     pgtype.Bool        `json:"is_escalated"`
	EscalatedTo     pgtype.Int8        `json:"escalated_to"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	FirstName       string             `json:"first_name"`
	LastName        string             `json:"last_name"`
	Email           string             `json:"email"`
}

// Get low confidence conversations
func (q *Queries) GetLowConfidenceConversations(ctx context.Context, arg GetLowConfidenceConversationsParams) ([]GetLowConfidenceConversationsRow, error) {
	rows, err := q.db.Query(ctx, getLowConfidenceConversations, arg.ConfidenceScore, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetLowConfidenceConversationsRow{}
	for rows.Next() {
		var i GetLowConfidenceConversationsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SessionID,
			&i.MessageText,
			&i.ResponseText,
			&i.Intent,
			&i.Entities,
			&i.ConfidenceScore,
			&i.IsEscalated,
			&i.EscalatedTo,
			&i.CreatedAt,
			&i.FirstName,
			&i.LastName,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentChatbotConversations = `-- name: GetRecentChatbotConversations :many
SELECT cc.id, cc.user_id, cc.session_id, cc.message_text, cc.response_text, cc.intent, cc.entities, cc.confidence_score, cc.is_escalated, cc.escalated_to, cc.created_at, u.first_name, u.last_name, u.email
FROM chatbot_conversations cc
JOIN users u ON cc.user_id = u.id
ORDER BY cc.created_at DESC
LIMIT $1 OFFSET $2
`

type GetRecentChatbotConversationsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetRecentChatbotConversationsRow struct {
	ID              int64              `json:"id"`
	UserID          int64              `json:"user_id"`
	SessionID       string             `json:"session_id"`
	MessageText     string             `json:"message_text"`
	ResponseText    string             `json:"response_text"`
	Intent          pgtype.Text        `json:"intent"`
	Entities        pgtype.Text        `json:"entities"`
	ConfidenceScore pgtype.Numeric     `json:"confidence_score"`
	IsEscalated     pgtype.Bool        `json:"is_escalated"`
	EscalatedTo     pgtype.Int8        `json:"escalated_to"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	FirstName       string             `json:"first_name"`
	LastName        string             `json:"last_name"`
	Email           string             `json:"email"`
}

// Get recent conversations
func (q *Queries) GetRecentChatbotConversations(ctx context.Context, arg GetRecentChatbotConversationsParams) ([]GetRecentChatbotConversationsRow, error) {
	rows, err := q.db.Query(ctx, getRecentChatbotConversations, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecentChatbotConversationsRow{}
	for rows.Next() {
		var i GetRecentChatbotConversationsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SessionID,
			&i.MessageText,
			&i.ResponseText,
			&i.Intent,
			&i.Entities,
			&i.ConfidenceScore,
			&i.IsEscalated,
			&i.EscalatedTo,
			&i.CreatedAt,
			&i.FirstName,
			&i.LastName,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserChatbotSessions = `-- name: GetUserChatbotSessions :many
SELECT DISTINCT session_id, MAX(created_at) as last_message_time, COUNT(*) as message_count
FROM chatbot_conversations 
WHERE user_id = $1
GROUP BY session_id
ORDER BY last_message_time DESC
LIMIT $2 OFFSET $3
`

type GetUserChatbotSessionsParams struct {
	UserID int64 `json:"user_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetUserChatbotSessionsRow struct {
	SessionID       string      `json:"session_id"`
	LastMessageTime interface{} `json:"last_message_time"`
	MessageCount    int64       `json:"message_count"`
}

// Get user sessions
func (q *Queries) GetUserChatbotSessions(ctx context.Context, arg GetUserChatbotSessionsParams) ([]GetUserChatbotSessionsRow, error) {
	rows, err := q.db.Query(ctx, getUserChatbotSessions, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserChatbotSessionsRow{}
	for rows.Next() {
		var i GetUserChatbotSessionsRow
		if err := rows.Scan(&i.SessionID, &i.LastMessageTime, &i.MessageCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserConversationSummary = `-- name: GetUserConversationSummary :one
SELECT 
  COUNT(*) as total_conversations,
  COUNT(DISTINCT session_id) as total_sessions,
  COUNT(CASE WHEN is_escalated = true THEN 1 END) as escalated_count,
  MAX(created_at) as last_conversation_time,
  AVG(confidence_score) as average_confidence
FROM chatbot_conversations 
WHERE user_id = $1
`

type GetUserConversationSummaryRow struct {
	TotalConversations   int64       `json:"total_conversations"`
	TotalSessions        int64       `json:"total_sessions"`
	EscalatedCount       int64       `json:"escalated_count"`
	LastConversationTime interface{} `json:"last_conversation_time"`
	AverageConfidence    float64     `json:"average_confidence"`
}

// Get user conversation summary
func (q *Queries) GetUserConversationSummary(ctx context.Context, userID int64) (GetUserConversationSummaryRow, error) {
	row := q.db.QueryRow(ctx, getUserConversationSummary, userID)
	var i GetUserConversationSummaryRow
	err := row.Scan(
		&i.TotalConversations,
		&i.TotalSessions,
		&i.EscalatedCount,
		&i.LastConversationTime,
		&i.AverageConfidence,
	)
	return i, err
}

const searchChatbotConversations = `-- name: SearchChatbotConversations :many
SELECT cc.id, cc.user_id, cc.session_id, cc.message_text, cc.response_text, cc.intent, cc.entities, cc.confidence_score, cc.is_escalated, cc.escalated_to, cc.created_at, u.first_name, u.last_name, u.email
FROM chatbot_conversations cc
JOIN users u ON cc.user_id = u.id
WHERE cc.message_text ILIKE '%' || $1 || '%' OR cc.response_text ILIKE '%' || $1 || '%'
ORDER BY cc.created_at DESC
LIMIT $2 OFFSET $3
`

type SearchChatbotConversationsParams struct {
	Column1 pgtype.Text `json:"column_1"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

type SearchChatbotConversationsRow struct {
	ID              int64              `json:"id"`
	UserID          int64              `json:"user_id"`
	SessionID       string             `json:"session_id"`
	MessageText     string             `json:"message_text"`
	ResponseText    string             `json:"response_text"`
	Intent          pgtype.Text        `json:"intent"`
	Entities        pgtype.Text        `json:"entities"`
	ConfidenceScore pgtype.Numeric     `json:"confidence_score"`
	IsEscalated     pgtype.Bool        `json:"is_escalated"`
	EscalatedTo     pgtype.Int8        `json:"escalated_to"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	FirstName       string             `json:"first_name"`
	LastName        string             `json:"last_name"`
	Email           string             `json:"email"`
}

// Search conversations
func (q *Queries) SearchChatbotConversations(ctx context.Context, arg SearchChatbotConversationsParams) ([]SearchChatbotConversationsRow, error) {
	rows, err := q.db.Query(ctx, searchChatbotConversations, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchChatbotConversationsRow{}
	for rows.Next() {
		var i SearchChatbotConversationsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SessionID,
			&i.MessageText,
			&i.ResponseText,
			&i.Intent,
			&i.Entities,
			&i.ConfidenceScore,
			&i.IsEscalated,
			&i.EscalatedTo,
			&i.CreatedAt,
			&i.FirstName,
			&i.LastName,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
