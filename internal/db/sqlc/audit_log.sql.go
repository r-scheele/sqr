// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: audit_log.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const cleanupOldAuditLogs = `-- name: CleanupOldAuditLogs :exec
DELETE FROM audit_logs 
WHERE created_at < $1
`

// Clean up old audit logs
func (q *Queries) CleanupOldAuditLogs(ctx context.Context, createdAt pgtype.Timestamptz) error {
	_, err := q.db.Exec(ctx, cleanupOldAuditLogs, createdAt)
	return err
}

const countAuditLogsByAction = `-- name: CountAuditLogsByAction :one
SELECT COUNT(*) FROM audit_logs 
WHERE action = $1
`

// Count audit logs by action
func (q *Queries) CountAuditLogsByAction(ctx context.Context, action AuditActionEnum) (int64, error) {
	row := q.db.QueryRow(ctx, countAuditLogsByAction, action)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAuditLogsByDateRange = `-- name: CountAuditLogsByDateRange :one
SELECT COUNT(*) FROM audit_logs 
WHERE created_at BETWEEN $1 AND $2
`

type CountAuditLogsByDateRangeParams struct {
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	CreatedAt_2 pgtype.Timestamptz `json:"created_at_2"`
}

// Count audit logs by date range
func (q *Queries) CountAuditLogsByDateRange(ctx context.Context, arg CountAuditLogsByDateRangeParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAuditLogsByDateRange, arg.CreatedAt, arg.CreatedAt_2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAuditLogsByEntity = `-- name: CountAuditLogsByEntity :one
SELECT COUNT(*) FROM audit_logs 
WHERE entity_type = $1 AND entity_id = $2
`

type CountAuditLogsByEntityParams struct {
	EntityType string      `json:"entity_type"`
	EntityID   pgtype.Int8 `json:"entity_id"`
}

// Count audit logs by entity
func (q *Queries) CountAuditLogsByEntity(ctx context.Context, arg CountAuditLogsByEntityParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAuditLogsByEntity, arg.EntityType, arg.EntityID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAuditLogsByUser = `-- name: CountAuditLogsByUser :one
SELECT COUNT(*) FROM audit_logs 
WHERE user_id = $1
`

// Count audit logs by user
func (q *Queries) CountAuditLogsByUser(ctx context.Context, userID pgtype.Int8) (int64, error) {
	row := q.db.QueryRow(ctx, countAuditLogsByUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAuditLog = `-- name: CreateAuditLog :one
INSERT INTO audit_logs (
  user_id, action, entity_type, entity_id, old_values, new_values, ip_address, user_agent
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING id, user_id, action, entity_type, entity_id, old_values, new_values, ip_address, user_agent, created_at
`

type CreateAuditLogParams struct {
	UserID     pgtype.Int8     `json:"user_id"`
	Action     AuditActionEnum `json:"action"`
	EntityType string          `json:"entity_type"`
	EntityID   pgtype.Int8     `json:"entity_id"`
	OldValues  pgtype.Text     `json:"old_values"`
	NewValues  pgtype.Text     `json:"new_values"`
	IpAddress  pgtype.Text     `json:"ip_address"`
	UserAgent  pgtype.Text     `json:"user_agent"`
}

// Create audit log
func (q *Queries) CreateAuditLog(ctx context.Context, arg CreateAuditLogParams) (AuditLog, error) {
	row := q.db.QueryRow(ctx, createAuditLog,
		arg.UserID,
		arg.Action,
		arg.EntityType,
		arg.EntityID,
		arg.OldValues,
		arg.NewValues,
		arg.IpAddress,
		arg.UserAgent,
	)
	var i AuditLog
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Action,
		&i.EntityType,
		&i.EntityID,
		&i.OldValues,
		&i.NewValues,
		&i.IpAddress,
		&i.UserAgent,
		&i.CreatedAt,
	)
	return i, err
}

const deleteAuditLog = `-- name: DeleteAuditLog :exec
DELETE FROM audit_logs 
WHERE id = $1
`

// Delete audit log
func (q *Queries) DeleteAuditLog(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteAuditLog, id)
	return err
}

const deleteAuditLogsByUser = `-- name: DeleteAuditLogsByUser :exec
DELETE FROM audit_logs 
WHERE user_id = $1
`

// Delete audit logs by user
func (q *Queries) DeleteAuditLogsByUser(ctx context.Context, userID pgtype.Int8) error {
	_, err := q.db.Exec(ctx, deleteAuditLogsByUser, userID)
	return err
}

const getAuditLogByID = `-- name: GetAuditLogByID :one
SELECT id, user_id, action, entity_type, entity_id, old_values, new_values, ip_address, user_agent, created_at FROM audit_logs 
WHERE id = $1 LIMIT 1
`

// Get audit log by ID
func (q *Queries) GetAuditLogByID(ctx context.Context, id int64) (AuditLog, error) {
	row := q.db.QueryRow(ctx, getAuditLogByID, id)
	var i AuditLog
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Action,
		&i.EntityType,
		&i.EntityID,
		&i.OldValues,
		&i.NewValues,
		&i.IpAddress,
		&i.UserAgent,
		&i.CreatedAt,
	)
	return i, err
}

const getAuditLogWithUserDetails = `-- name: GetAuditLogWithUserDetails :one
SELECT al.id, al.user_id, al.action, al.entity_type, al.entity_id, al.old_values, al.new_values, al.ip_address, al.user_agent, al.created_at, u.first_name, u.last_name, u.email, u.user_type
FROM audit_logs al
LEFT JOIN users u ON al.user_id = u.id
WHERE al.id = $1 LIMIT 1
`

type GetAuditLogWithUserDetailsRow struct {
	ID         int64              `json:"id"`
	UserID     pgtype.Int8        `json:"user_id"`
	Action     AuditActionEnum    `json:"action"`
	EntityType string             `json:"entity_type"`
	EntityID   pgtype.Int8        `json:"entity_id"`
	OldValues  pgtype.Text        `json:"old_values"`
	NewValues  pgtype.Text        `json:"new_values"`
	IpAddress  pgtype.Text        `json:"ip_address"`
	UserAgent  pgtype.Text        `json:"user_agent"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	FirstName  pgtype.Text        `json:"first_name"`
	LastName   pgtype.Text        `json:"last_name"`
	Email      pgtype.Text        `json:"email"`
	UserType   NullUserTypeEnum   `json:"user_type"`
}

// Get audit log with user details
func (q *Queries) GetAuditLogWithUserDetails(ctx context.Context, id int64) (GetAuditLogWithUserDetailsRow, error) {
	row := q.db.QueryRow(ctx, getAuditLogWithUserDetails, id)
	var i GetAuditLogWithUserDetailsRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Action,
		&i.EntityType,
		&i.EntityID,
		&i.OldValues,
		&i.NewValues,
		&i.IpAddress,
		&i.UserAgent,
		&i.CreatedAt,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.UserType,
	)
	return i, err
}

const getAuditLogsByAction = `-- name: GetAuditLogsByAction :many
SELECT al.id, al.user_id, al.action, al.entity_type, al.entity_id, al.old_values, al.new_values, al.ip_address, al.user_agent, al.created_at, u.first_name, u.last_name, u.email
FROM audit_logs al
LEFT JOIN users u ON al.user_id = u.id
WHERE al.action = $1
ORDER BY al.created_at DESC
LIMIT $2 OFFSET $3
`

type GetAuditLogsByActionParams struct {
	Action AuditActionEnum `json:"action"`
	Limit  int32           `json:"limit"`
	Offset int32           `json:"offset"`
}

type GetAuditLogsByActionRow struct {
	ID         int64              `json:"id"`
	UserID     pgtype.Int8        `json:"user_id"`
	Action     AuditActionEnum    `json:"action"`
	EntityType string             `json:"entity_type"`
	EntityID   pgtype.Int8        `json:"entity_id"`
	OldValues  pgtype.Text        `json:"old_values"`
	NewValues  pgtype.Text        `json:"new_values"`
	IpAddress  pgtype.Text        `json:"ip_address"`
	UserAgent  pgtype.Text        `json:"user_agent"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	FirstName  pgtype.Text        `json:"first_name"`
	LastName   pgtype.Text        `json:"last_name"`
	Email      pgtype.Text        `json:"email"`
}

// Get audit logs by action
func (q *Queries) GetAuditLogsByAction(ctx context.Context, arg GetAuditLogsByActionParams) ([]GetAuditLogsByActionRow, error) {
	rows, err := q.db.Query(ctx, getAuditLogsByAction, arg.Action, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAuditLogsByActionRow{}
	for rows.Next() {
		var i GetAuditLogsByActionRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Action,
			&i.EntityType,
			&i.EntityID,
			&i.OldValues,
			&i.NewValues,
			&i.IpAddress,
			&i.UserAgent,
			&i.CreatedAt,
			&i.FirstName,
			&i.LastName,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAuditLogsByDateRange = `-- name: GetAuditLogsByDateRange :many
SELECT al.id, al.user_id, al.action, al.entity_type, al.entity_id, al.old_values, al.new_values, al.ip_address, al.user_agent, al.created_at, u.first_name, u.last_name, u.email
FROM audit_logs al
LEFT JOIN users u ON al.user_id = u.id
WHERE al.created_at BETWEEN $1 AND $2
ORDER BY al.created_at DESC
LIMIT $3 OFFSET $4
`

type GetAuditLogsByDateRangeParams struct {
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	CreatedAt_2 pgtype.Timestamptz `json:"created_at_2"`
	Limit       int32              `json:"limit"`
	Offset      int32              `json:"offset"`
}

type GetAuditLogsByDateRangeRow struct {
	ID         int64              `json:"id"`
	UserID     pgtype.Int8        `json:"user_id"`
	Action     AuditActionEnum    `json:"action"`
	EntityType string             `json:"entity_type"`
	EntityID   pgtype.Int8        `json:"entity_id"`
	OldValues  pgtype.Text        `json:"old_values"`
	NewValues  pgtype.Text        `json:"new_values"`
	IpAddress  pgtype.Text        `json:"ip_address"`
	UserAgent  pgtype.Text        `json:"user_agent"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	FirstName  pgtype.Text        `json:"first_name"`
	LastName   pgtype.Text        `json:"last_name"`
	Email      pgtype.Text        `json:"email"`
}

// Get audit logs by date range
func (q *Queries) GetAuditLogsByDateRange(ctx context.Context, arg GetAuditLogsByDateRangeParams) ([]GetAuditLogsByDateRangeRow, error) {
	rows, err := q.db.Query(ctx, getAuditLogsByDateRange,
		arg.CreatedAt,
		arg.CreatedAt_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAuditLogsByDateRangeRow{}
	for rows.Next() {
		var i GetAuditLogsByDateRangeRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Action,
			&i.EntityType,
			&i.EntityID,
			&i.OldValues,
			&i.NewValues,
			&i.IpAddress,
			&i.UserAgent,
			&i.CreatedAt,
			&i.FirstName,
			&i.LastName,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAuditLogsByEntity = `-- name: GetAuditLogsByEntity :many
SELECT al.id, al.user_id, al.action, al.entity_type, al.entity_id, al.old_values, al.new_values, al.ip_address, al.user_agent, al.created_at, u.first_name, u.last_name, u.email
FROM audit_logs al
LEFT JOIN users u ON al.user_id = u.id
WHERE al.entity_type = $1 AND al.entity_id = $2
ORDER BY al.created_at DESC
LIMIT $3 OFFSET $4
`

type GetAuditLogsByEntityParams struct {
	EntityType string      `json:"entity_type"`
	EntityID   pgtype.Int8 `json:"entity_id"`
	Limit      int32       `json:"limit"`
	Offset     int32       `json:"offset"`
}

type GetAuditLogsByEntityRow struct {
	ID         int64              `json:"id"`
	UserID     pgtype.Int8        `json:"user_id"`
	Action     AuditActionEnum    `json:"action"`
	EntityType string             `json:"entity_type"`
	EntityID   pgtype.Int8        `json:"entity_id"`
	OldValues  pgtype.Text        `json:"old_values"`
	NewValues  pgtype.Text        `json:"new_values"`
	IpAddress  pgtype.Text        `json:"ip_address"`
	UserAgent  pgtype.Text        `json:"user_agent"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	FirstName  pgtype.Text        `json:"first_name"`
	LastName   pgtype.Text        `json:"last_name"`
	Email      pgtype.Text        `json:"email"`
}

// Get audit logs by entity
func (q *Queries) GetAuditLogsByEntity(ctx context.Context, arg GetAuditLogsByEntityParams) ([]GetAuditLogsByEntityRow, error) {
	rows, err := q.db.Query(ctx, getAuditLogsByEntity,
		arg.EntityType,
		arg.EntityID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAuditLogsByEntityRow{}
	for rows.Next() {
		var i GetAuditLogsByEntityRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Action,
			&i.EntityType,
			&i.EntityID,
			&i.OldValues,
			&i.NewValues,
			&i.IpAddress,
			&i.UserAgent,
			&i.CreatedAt,
			&i.FirstName,
			&i.LastName,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAuditLogsByEntityType = `-- name: GetAuditLogsByEntityType :many
SELECT al.id, al.user_id, al.action, al.entity_type, al.entity_id, al.old_values, al.new_values, al.ip_address, al.user_agent, al.created_at, u.first_name, u.last_name, u.email
FROM audit_logs al
LEFT JOIN users u ON al.user_id = u.id
WHERE al.entity_type = $1
ORDER BY al.created_at DESC
LIMIT $2 OFFSET $3
`

type GetAuditLogsByEntityTypeParams struct {
	EntityType string `json:"entity_type"`
	Limit      int32  `json:"limit"`
	Offset     int32  `json:"offset"`
}

type GetAuditLogsByEntityTypeRow struct {
	ID         int64              `json:"id"`
	UserID     pgtype.Int8        `json:"user_id"`
	Action     AuditActionEnum    `json:"action"`
	EntityType string             `json:"entity_type"`
	EntityID   pgtype.Int8        `json:"entity_id"`
	OldValues  pgtype.Text        `json:"old_values"`
	NewValues  pgtype.Text        `json:"new_values"`
	IpAddress  pgtype.Text        `json:"ip_address"`
	UserAgent  pgtype.Text        `json:"user_agent"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	FirstName  pgtype.Text        `json:"first_name"`
	LastName   pgtype.Text        `json:"last_name"`
	Email      pgtype.Text        `json:"email"`
}

// Get audit logs by entity type
func (q *Queries) GetAuditLogsByEntityType(ctx context.Context, arg GetAuditLogsByEntityTypeParams) ([]GetAuditLogsByEntityTypeRow, error) {
	rows, err := q.db.Query(ctx, getAuditLogsByEntityType, arg.EntityType, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAuditLogsByEntityTypeRow{}
	for rows.Next() {
		var i GetAuditLogsByEntityTypeRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Action,
			&i.EntityType,
			&i.EntityID,
			&i.OldValues,
			&i.NewValues,
			&i.IpAddress,
			&i.UserAgent,
			&i.CreatedAt,
			&i.FirstName,
			&i.LastName,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAuditLogsByIPAddress = `-- name: GetAuditLogsByIPAddress :many
SELECT al.id, al.user_id, al.action, al.entity_type, al.entity_id, al.old_values, al.new_values, al.ip_address, al.user_agent, al.created_at, u.first_name, u.last_name, u.email
FROM audit_logs al
LEFT JOIN users u ON al.user_id = u.id
WHERE al.ip_address = $1
ORDER BY al.created_at DESC
LIMIT $2 OFFSET $3
`

type GetAuditLogsByIPAddressParams struct {
	IpAddress pgtype.Text `json:"ip_address"`
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
}

type GetAuditLogsByIPAddressRow struct {
	ID         int64              `json:"id"`
	UserID     pgtype.Int8        `json:"user_id"`
	Action     AuditActionEnum    `json:"action"`
	EntityType string             `json:"entity_type"`
	EntityID   pgtype.Int8        `json:"entity_id"`
	OldValues  pgtype.Text        `json:"old_values"`
	NewValues  pgtype.Text        `json:"new_values"`
	IpAddress  pgtype.Text        `json:"ip_address"`
	UserAgent  pgtype.Text        `json:"user_agent"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	FirstName  pgtype.Text        `json:"first_name"`
	LastName   pgtype.Text        `json:"last_name"`
	Email      pgtype.Text        `json:"email"`
}

// Get audit logs by IP address
func (q *Queries) GetAuditLogsByIPAddress(ctx context.Context, arg GetAuditLogsByIPAddressParams) ([]GetAuditLogsByIPAddressRow, error) {
	rows, err := q.db.Query(ctx, getAuditLogsByIPAddress, arg.IpAddress, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAuditLogsByIPAddressRow{}
	for rows.Next() {
		var i GetAuditLogsByIPAddressRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Action,
			&i.EntityType,
			&i.EntityID,
			&i.OldValues,
			&i.NewValues,
			&i.IpAddress,
			&i.UserAgent,
			&i.CreatedAt,
			&i.FirstName,
			&i.LastName,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAuditLogsByUser = `-- name: GetAuditLogsByUser :many
SELECT id, user_id, action, entity_type, entity_id, old_values, new_values, ip_address, user_agent, created_at FROM audit_logs 
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetAuditLogsByUserParams struct {
	UserID pgtype.Int8 `json:"user_id"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

// Get audit logs by user
func (q *Queries) GetAuditLogsByUser(ctx context.Context, arg GetAuditLogsByUserParams) ([]AuditLog, error) {
	rows, err := q.db.Query(ctx, getAuditLogsByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AuditLog{}
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Action,
			&i.EntityType,
			&i.EntityID,
			&i.OldValues,
			&i.NewValues,
			&i.IpAddress,
			&i.UserAgent,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAuditStatistics = `-- name: GetAuditStatistics :one
SELECT 
  COUNT(*) as total_logs,
  COUNT(CASE WHEN action = 'create' THEN 1 END) as create_actions,
  COUNT(CASE WHEN action = 'update' THEN 1 END) as update_actions,
  COUNT(CASE WHEN action = 'delete' THEN 1 END) as delete_actions,
  COUNT(CASE WHEN action = 'login' THEN 1 END) as login_actions,
  COUNT(CASE WHEN action = 'payment' THEN 1 END) as payment_actions,
  COUNT(DISTINCT user_id) as unique_users,
  COUNT(DISTINCT ip_address) as unique_ips
FROM audit_logs 
WHERE created_at >= $1
`

type GetAuditStatisticsRow struct {
	TotalLogs      int64 `json:"total_logs"`
	CreateActions  int64 `json:"create_actions"`
	UpdateActions  int64 `json:"update_actions"`
	DeleteActions  int64 `json:"delete_actions"`
	LoginActions   int64 `json:"login_actions"`
	PaymentActions int64 `json:"payment_actions"`
	UniqueUsers    int64 `json:"unique_users"`
	UniqueIps      int64 `json:"unique_ips"`
}

// Get audit statistics
func (q *Queries) GetAuditStatistics(ctx context.Context, createdAt pgtype.Timestamptz) (GetAuditStatisticsRow, error) {
	row := q.db.QueryRow(ctx, getAuditStatistics, createdAt)
	var i GetAuditStatisticsRow
	err := row.Scan(
		&i.TotalLogs,
		&i.CreateActions,
		&i.UpdateActions,
		&i.DeleteActions,
		&i.LoginActions,
		&i.PaymentActions,
		&i.UniqueUsers,
		&i.UniqueIps,
	)
	return i, err
}

const getFailedLoginAttempts = `-- name: GetFailedLoginAttempts :many
SELECT id, user_id, action, entity_type, entity_id, old_values, new_values, ip_address, user_agent, created_at FROM audit_logs 
WHERE action = 'login' AND entity_type = 'failed_login'
  AND ($1::varchar IS NULL OR ip_address = $1)
  AND created_at >= $2
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type GetFailedLoginAttemptsParams struct {
	Column1   string             `json:"column_1"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	Limit     int32              `json:"limit"`
	Offset    int32              `json:"offset"`
}

// Get failed login attempts
func (q *Queries) GetFailedLoginAttempts(ctx context.Context, arg GetFailedLoginAttemptsParams) ([]AuditLog, error) {
	rows, err := q.db.Query(ctx, getFailedLoginAttempts,
		arg.Column1,
		arg.CreatedAt,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AuditLog{}
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Action,
			&i.EntityType,
			&i.EntityID,
			&i.OldValues,
			&i.NewValues,
			&i.IpAddress,
			&i.UserAgent,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaymentAuditLogs = `-- name: GetPaymentAuditLogs :many
SELECT al.id, al.user_id, al.action, al.entity_type, al.entity_id, al.old_values, al.new_values, al.ip_address, al.user_agent, al.created_at, u.first_name, u.last_name, u.email
FROM audit_logs al
LEFT JOIN users u ON al.user_id = u.id
WHERE al.action = 'payment'
ORDER BY al.created_at DESC
LIMIT $1 OFFSET $2
`

type GetPaymentAuditLogsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetPaymentAuditLogsRow struct {
	ID         int64              `json:"id"`
	UserID     pgtype.Int8        `json:"user_id"`
	Action     AuditActionEnum    `json:"action"`
	EntityType string             `json:"entity_type"`
	EntityID   pgtype.Int8        `json:"entity_id"`
	OldValues  pgtype.Text        `json:"old_values"`
	NewValues  pgtype.Text        `json:"new_values"`
	IpAddress  pgtype.Text        `json:"ip_address"`
	UserAgent  pgtype.Text        `json:"user_agent"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	FirstName  pgtype.Text        `json:"first_name"`
	LastName   pgtype.Text        `json:"last_name"`
	Email      pgtype.Text        `json:"email"`
}

// Get payment audit logs
func (q *Queries) GetPaymentAuditLogs(ctx context.Context, arg GetPaymentAuditLogsParams) ([]GetPaymentAuditLogsRow, error) {
	rows, err := q.db.Query(ctx, getPaymentAuditLogs, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPaymentAuditLogsRow{}
	for rows.Next() {
		var i GetPaymentAuditLogsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Action,
			&i.EntityType,
			&i.EntityID,
			&i.OldValues,
			&i.NewValues,
			&i.IpAddress,
			&i.UserAgent,
			&i.CreatedAt,
			&i.FirstName,
			&i.LastName,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentAuditLogs = `-- name: GetRecentAuditLogs :many
SELECT al.id, al.user_id, al.action, al.entity_type, al.entity_id, al.old_values, al.new_values, al.ip_address, al.user_agent, al.created_at, u.first_name, u.last_name, u.email
FROM audit_logs al
LEFT JOIN users u ON al.user_id = u.id
ORDER BY al.created_at DESC
LIMIT $1 OFFSET $2
`

type GetRecentAuditLogsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetRecentAuditLogsRow struct {
	ID         int64              `json:"id"`
	UserID     pgtype.Int8        `json:"user_id"`
	Action     AuditActionEnum    `json:"action"`
	EntityType string             `json:"entity_type"`
	EntityID   pgtype.Int8        `json:"entity_id"`
	OldValues  pgtype.Text        `json:"old_values"`
	NewValues  pgtype.Text        `json:"new_values"`
	IpAddress  pgtype.Text        `json:"ip_address"`
	UserAgent  pgtype.Text        `json:"user_agent"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	FirstName  pgtype.Text        `json:"first_name"`
	LastName   pgtype.Text        `json:"last_name"`
	Email      pgtype.Text        `json:"email"`
}

// Get recent audit logs
func (q *Queries) GetRecentAuditLogs(ctx context.Context, arg GetRecentAuditLogsParams) ([]GetRecentAuditLogsRow, error) {
	rows, err := q.db.Query(ctx, getRecentAuditLogs, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecentAuditLogsRow{}
	for rows.Next() {
		var i GetRecentAuditLogsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Action,
			&i.EntityType,
			&i.EntityID,
			&i.OldValues,
			&i.NewValues,
			&i.IpAddress,
			&i.UserAgent,
			&i.CreatedAt,
			&i.FirstName,
			&i.LastName,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserActivitySummary = `-- name: GetUserActivitySummary :one
SELECT 
  COUNT(*) as total_activities,
  COUNT(CASE WHEN action = 'login' THEN 1 END) as login_count,
  COUNT(CASE WHEN action = 'create' THEN 1 END) as create_count,
  COUNT(CASE WHEN action = 'update' THEN 1 END) as update_count,
  COUNT(CASE WHEN action = 'delete' THEN 1 END) as delete_count,
  MAX(created_at) as last_activity,
  COUNT(DISTINCT ip_address) as unique_ips
FROM audit_logs 
WHERE user_id = $1 AND created_at >= $2
`

type GetUserActivitySummaryParams struct {
	UserID    pgtype.Int8        `json:"user_id"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

type GetUserActivitySummaryRow struct {
	TotalActivities int64       `json:"total_activities"`
	LoginCount      int64       `json:"login_count"`
	CreateCount     int64       `json:"create_count"`
	UpdateCount     int64       `json:"update_count"`
	DeleteCount     int64       `json:"delete_count"`
	LastActivity    interface{} `json:"last_activity"`
	UniqueIps       int64       `json:"unique_ips"`
}

// Get user activity summary
func (q *Queries) GetUserActivitySummary(ctx context.Context, arg GetUserActivitySummaryParams) (GetUserActivitySummaryRow, error) {
	row := q.db.QueryRow(ctx, getUserActivitySummary, arg.UserID, arg.CreatedAt)
	var i GetUserActivitySummaryRow
	err := row.Scan(
		&i.TotalActivities,
		&i.LoginCount,
		&i.CreateCount,
		&i.UpdateCount,
		&i.DeleteCount,
		&i.LastActivity,
		&i.UniqueIps,
	)
	return i, err
}

const getUserLoginLogs = `-- name: GetUserLoginLogs :many
SELECT al.id, al.user_id, al.action, al.entity_type, al.entity_id, al.old_values, al.new_values, al.ip_address, al.user_agent, al.created_at, u.first_name, u.last_name, u.email
FROM audit_logs al
JOIN users u ON al.user_id = u.id
WHERE al.action = 'login'
ORDER BY al.created_at DESC
LIMIT $1 OFFSET $2
`

type GetUserLoginLogsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetUserLoginLogsRow struct {
	ID         int64              `json:"id"`
	UserID     pgtype.Int8        `json:"user_id"`
	Action     AuditActionEnum    `json:"action"`
	EntityType string             `json:"entity_type"`
	EntityID   pgtype.Int8        `json:"entity_id"`
	OldValues  pgtype.Text        `json:"old_values"`
	NewValues  pgtype.Text        `json:"new_values"`
	IpAddress  pgtype.Text        `json:"ip_address"`
	UserAgent  pgtype.Text        `json:"user_agent"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	FirstName  string             `json:"first_name"`
	LastName   string             `json:"last_name"`
	Email      string             `json:"email"`
}

// Get user login logs
func (q *Queries) GetUserLoginLogs(ctx context.Context, arg GetUserLoginLogsParams) ([]GetUserLoginLogsRow, error) {
	rows, err := q.db.Query(ctx, getUserLoginLogs, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserLoginLogsRow{}
	for rows.Next() {
		var i GetUserLoginLogsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Action,
			&i.EntityType,
			&i.EntityID,
			&i.OldValues,
			&i.NewValues,
			&i.IpAddress,
			&i.UserAgent,
			&i.CreatedAt,
			&i.FirstName,
			&i.LastName,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVerificationAuditLogs = `-- name: GetVerificationAuditLogs :many
SELECT al.id, al.user_id, al.action, al.entity_type, al.entity_id, al.old_values, al.new_values, al.ip_address, al.user_agent, al.created_at, u.first_name, u.last_name, u.email
FROM audit_logs al
LEFT JOIN users u ON al.user_id = u.id
WHERE al.action = 'verification'
ORDER BY al.created_at DESC
LIMIT $1 OFFSET $2
`

type GetVerificationAuditLogsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetVerificationAuditLogsRow struct {
	ID         int64              `json:"id"`
	UserID     pgtype.Int8        `json:"user_id"`
	Action     AuditActionEnum    `json:"action"`
	EntityType string             `json:"entity_type"`
	EntityID   pgtype.Int8        `json:"entity_id"`
	OldValues  pgtype.Text        `json:"old_values"`
	NewValues  pgtype.Text        `json:"new_values"`
	IpAddress  pgtype.Text        `json:"ip_address"`
	UserAgent  pgtype.Text        `json:"user_agent"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	FirstName  pgtype.Text        `json:"first_name"`
	LastName   pgtype.Text        `json:"last_name"`
	Email      pgtype.Text        `json:"email"`
}

// Get verification audit logs
func (q *Queries) GetVerificationAuditLogs(ctx context.Context, arg GetVerificationAuditLogsParams) ([]GetVerificationAuditLogsRow, error) {
	rows, err := q.db.Query(ctx, getVerificationAuditLogs, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetVerificationAuditLogsRow{}
	for rows.Next() {
		var i GetVerificationAuditLogsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Action,
			&i.EntityType,
			&i.EntityID,
			&i.OldValues,
			&i.NewValues,
			&i.IpAddress,
			&i.UserAgent,
			&i.CreatedAt,
			&i.FirstName,
			&i.LastName,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
