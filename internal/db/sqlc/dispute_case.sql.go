// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: dispute_case.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addDisputeEvidence = `-- name: AddDisputeEvidence :one
UPDATE dispute_cases 
SET evidence_files = $2, updated_at = NOW()
WHERE id = $1 
RETURNING id, complainant_id, respondent_id, related_entity_type, related_entity_id, dispute_type, description, evidence_files, status, assigned_admin_id, resolution_notes, resolved_at, created_at, updated_at
`

type AddDisputeEvidenceParams struct {
	ID            int64       `json:"id"`
	EvidenceFiles pgtype.Text `json:"evidence_files"`
}

// Add evidence to dispute
func (q *Queries) AddDisputeEvidence(ctx context.Context, arg AddDisputeEvidenceParams) (DisputeCase, error) {
	row := q.db.QueryRow(ctx, addDisputeEvidence, arg.ID, arg.EvidenceFiles)
	var i DisputeCase
	err := row.Scan(
		&i.ID,
		&i.ComplainantID,
		&i.RespondentID,
		&i.RelatedEntityType,
		&i.RelatedEntityID,
		&i.DisputeType,
		&i.Description,
		&i.EvidenceFiles,
		&i.Status,
		&i.AssignedAdminID,
		&i.ResolutionNotes,
		&i.ResolvedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const assignAdminToDispute = `-- name: AssignAdminToDispute :one
UPDATE dispute_cases 
SET assigned_admin_id = $2, status = 'investigating', updated_at = NOW()
WHERE id = $1 
RETURNING id, complainant_id, respondent_id, related_entity_type, related_entity_id, dispute_type, description, evidence_files, status, assigned_admin_id, resolution_notes, resolved_at, created_at, updated_at
`

type AssignAdminToDisputeParams struct {
	ID              int64       `json:"id"`
	AssignedAdminID pgtype.Int8 `json:"assigned_admin_id"`
}

// Assign admin to dispute
func (q *Queries) AssignAdminToDispute(ctx context.Context, arg AssignAdminToDisputeParams) (DisputeCase, error) {
	row := q.db.QueryRow(ctx, assignAdminToDispute, arg.ID, arg.AssignedAdminID)
	var i DisputeCase
	err := row.Scan(
		&i.ID,
		&i.ComplainantID,
		&i.RespondentID,
		&i.RelatedEntityType,
		&i.RelatedEntityID,
		&i.DisputeType,
		&i.Description,
		&i.EvidenceFiles,
		&i.Status,
		&i.AssignedAdminID,
		&i.ResolutionNotes,
		&i.ResolvedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const closeDispute = `-- name: CloseDispute :one
UPDATE dispute_cases 
SET status = 'closed', resolution_notes = $2, resolved_at = NOW(), updated_at = NOW()
WHERE id = $1 
RETURNING id, complainant_id, respondent_id, related_entity_type, related_entity_id, dispute_type, description, evidence_files, status, assigned_admin_id, resolution_notes, resolved_at, created_at, updated_at
`

type CloseDisputeParams struct {
	ID              int64       `json:"id"`
	ResolutionNotes pgtype.Text `json:"resolution_notes"`
}

// Close dispute
func (q *Queries) CloseDispute(ctx context.Context, arg CloseDisputeParams) (DisputeCase, error) {
	row := q.db.QueryRow(ctx, closeDispute, arg.ID, arg.ResolutionNotes)
	var i DisputeCase
	err := row.Scan(
		&i.ID,
		&i.ComplainantID,
		&i.RespondentID,
		&i.RelatedEntityType,
		&i.RelatedEntityID,
		&i.DisputeType,
		&i.Description,
		&i.EvidenceFiles,
		&i.Status,
		&i.AssignedAdminID,
		&i.ResolutionNotes,
		&i.ResolvedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const countDisputesAssignedToAdmin = `-- name: CountDisputesAssignedToAdmin :one
SELECT COUNT(*) FROM dispute_cases 
WHERE assigned_admin_id = $1
`

// Count disputes assigned to admin
func (q *Queries) CountDisputesAssignedToAdmin(ctx context.Context, assignedAdminID pgtype.Int8) (int64, error) {
	row := q.db.QueryRow(ctx, countDisputesAssignedToAdmin, assignedAdminID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countDisputesByStatus = `-- name: CountDisputesByStatus :one
SELECT COUNT(*) FROM dispute_cases 
WHERE status = $1
`

// Count disputes by status
func (q *Queries) CountDisputesByStatus(ctx context.Context, status NullDisputeStatusEnum) (int64, error) {
	row := q.db.QueryRow(ctx, countDisputesByStatus, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countDisputesForComplainant = `-- name: CountDisputesForComplainant :one
SELECT COUNT(*) FROM dispute_cases 
WHERE complainant_id = $1
`

// Count disputes for user (as complainant)
func (q *Queries) CountDisputesForComplainant(ctx context.Context, complainantID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countDisputesForComplainant, complainantID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countDisputesForRespondent = `-- name: CountDisputesForRespondent :one
SELECT COUNT(*) FROM dispute_cases 
WHERE respondent_id = $1
`

// Count disputes for user (as respondent)
func (q *Queries) CountDisputesForRespondent(ctx context.Context, respondentID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countDisputesForRespondent, respondentID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createDisputeCase = `-- name: CreateDisputeCase :one
INSERT INTO dispute_cases (
  complainant_id, respondent_id, related_entity_type, related_entity_id,
  dispute_type, description, evidence_files
) VALUES (
  $1, $2, $3, $4, $5, $6, $7
) RETURNING id, complainant_id, respondent_id, related_entity_type, related_entity_id, dispute_type, description, evidence_files, status, assigned_admin_id, resolution_notes, resolved_at, created_at, updated_at
`

type CreateDisputeCaseParams struct {
	ComplainantID     int64                 `json:"complainant_id"`
	RespondentID      int64                 `json:"respondent_id"`
	RelatedEntityType NullDisputeEntityEnum `json:"related_entity_type"`
	RelatedEntityID   pgtype.Int8           `json:"related_entity_id"`
	DisputeType       DisputeTypeEnum       `json:"dispute_type"`
	Description       string                `json:"description"`
	EvidenceFiles     pgtype.Text           `json:"evidence_files"`
}

// Create dispute case
func (q *Queries) CreateDisputeCase(ctx context.Context, arg CreateDisputeCaseParams) (DisputeCase, error) {
	row := q.db.QueryRow(ctx, createDisputeCase,
		arg.ComplainantID,
		arg.RespondentID,
		arg.RelatedEntityType,
		arg.RelatedEntityID,
		arg.DisputeType,
		arg.Description,
		arg.EvidenceFiles,
	)
	var i DisputeCase
	err := row.Scan(
		&i.ID,
		&i.ComplainantID,
		&i.RespondentID,
		&i.RelatedEntityType,
		&i.RelatedEntityID,
		&i.DisputeType,
		&i.Description,
		&i.EvidenceFiles,
		&i.Status,
		&i.AssignedAdminID,
		&i.ResolutionNotes,
		&i.ResolvedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteDisputeCase = `-- name: DeleteDisputeCase :exec
DELETE FROM dispute_cases 
WHERE id = $1
`

// Delete dispute case
func (q *Queries) DeleteDisputeCase(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteDisputeCase, id)
	return err
}

const getAdminDisputeWorkload = `-- name: GetAdminDisputeWorkload :one
SELECT 
  COUNT(*) as total_assigned,
  COUNT(CASE WHEN status = 'investigating' THEN 1 END) as active_cases,
  COUNT(CASE WHEN status = 'resolved' THEN 1 END) as resolved_cases,
  AVG(EXTRACT(EPOCH FROM (COALESCE(resolved_at, NOW()) - created_at))/86400) as avg_handling_days
FROM dispute_cases 
WHERE assigned_admin_id = $1
`

type GetAdminDisputeWorkloadRow struct {
	TotalAssigned   int64   `json:"total_assigned"`
	ActiveCases     int64   `json:"active_cases"`
	ResolvedCases   int64   `json:"resolved_cases"`
	AvgHandlingDays float64 `json:"avg_handling_days"`
}

// Get admin dispute workload
func (q *Queries) GetAdminDisputeWorkload(ctx context.Context, assignedAdminID pgtype.Int8) (GetAdminDisputeWorkloadRow, error) {
	row := q.db.QueryRow(ctx, getAdminDisputeWorkload, assignedAdminID)
	var i GetAdminDisputeWorkloadRow
	err := row.Scan(
		&i.TotalAssigned,
		&i.ActiveCases,
		&i.ResolvedCases,
		&i.AvgHandlingDays,
	)
	return i, err
}

const getDisputeCaseByID = `-- name: GetDisputeCaseByID :one
SELECT id, complainant_id, respondent_id, related_entity_type, related_entity_id, dispute_type, description, evidence_files, status, assigned_admin_id, resolution_notes, resolved_at, created_at, updated_at FROM dispute_cases 
WHERE id = $1 LIMIT 1
`

// Get dispute case by ID
func (q *Queries) GetDisputeCaseByID(ctx context.Context, id int64) (DisputeCase, error) {
	row := q.db.QueryRow(ctx, getDisputeCaseByID, id)
	var i DisputeCase
	err := row.Scan(
		&i.ID,
		&i.ComplainantID,
		&i.RespondentID,
		&i.RelatedEntityType,
		&i.RelatedEntityID,
		&i.DisputeType,
		&i.Description,
		&i.EvidenceFiles,
		&i.Status,
		&i.AssignedAdminID,
		&i.ResolutionNotes,
		&i.ResolvedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDisputeCaseWithDetails = `-- name: GetDisputeCaseWithDetails :one
SELECT dc.id, dc.complainant_id, dc.respondent_id, dc.related_entity_type, dc.related_entity_id, dc.dispute_type, dc.description, dc.evidence_files, dc.status, dc.assigned_admin_id, dc.resolution_notes, dc.resolved_at, dc.created_at, dc.updated_at, 
       c.first_name as complainant_first_name, c.last_name as complainant_last_name, c.email as complainant_email,
       r.first_name as respondent_first_name, r.last_name as respondent_last_name, r.email as respondent_email,
       a.first_name as admin_first_name, a.last_name as admin_last_name, a.email as admin_email
FROM dispute_cases dc
JOIN users c ON dc.complainant_id = c.id
JOIN users r ON dc.respondent_id = r.id
LEFT JOIN users a ON dc.assigned_admin_id = a.id
WHERE dc.id = $1 LIMIT 1
`

type GetDisputeCaseWithDetailsRow struct {
	ID                   int64                 `json:"id"`
	ComplainantID        int64                 `json:"complainant_id"`
	RespondentID         int64                 `json:"respondent_id"`
	RelatedEntityType    NullDisputeEntityEnum `json:"related_entity_type"`
	RelatedEntityID      pgtype.Int8           `json:"related_entity_id"`
	DisputeType          DisputeTypeEnum       `json:"dispute_type"`
	Description          string                `json:"description"`
	EvidenceFiles        pgtype.Text           `json:"evidence_files"`
	Status               NullDisputeStatusEnum `json:"status"`
	AssignedAdminID      pgtype.Int8           `json:"assigned_admin_id"`
	ResolutionNotes      pgtype.Text           `json:"resolution_notes"`
	ResolvedAt           pgtype.Timestamptz    `json:"resolved_at"`
	CreatedAt            pgtype.Timestamptz    `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz    `json:"updated_at"`
	ComplainantFirstName string                `json:"complainant_first_name"`
	ComplainantLastName  string                `json:"complainant_last_name"`
	ComplainantEmail     string                `json:"complainant_email"`
	RespondentFirstName  string                `json:"respondent_first_name"`
	RespondentLastName   string                `json:"respondent_last_name"`
	RespondentEmail      string                `json:"respondent_email"`
	AdminFirstName       pgtype.Text           `json:"admin_first_name"`
	AdminLastName        pgtype.Text           `json:"admin_last_name"`
	AdminEmail           pgtype.Text           `json:"admin_email"`
}

// Get dispute case with details
func (q *Queries) GetDisputeCaseWithDetails(ctx context.Context, id int64) (GetDisputeCaseWithDetailsRow, error) {
	row := q.db.QueryRow(ctx, getDisputeCaseWithDetails, id)
	var i GetDisputeCaseWithDetailsRow
	err := row.Scan(
		&i.ID,
		&i.ComplainantID,
		&i.RespondentID,
		&i.RelatedEntityType,
		&i.RelatedEntityID,
		&i.DisputeType,
		&i.Description,
		&i.EvidenceFiles,
		&i.Status,
		&i.AssignedAdminID,
		&i.ResolutionNotes,
		&i.ResolvedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ComplainantFirstName,
		&i.ComplainantLastName,
		&i.ComplainantEmail,
		&i.RespondentFirstName,
		&i.RespondentLastName,
		&i.RespondentEmail,
		&i.AdminFirstName,
		&i.AdminLastName,
		&i.AdminEmail,
	)
	return i, err
}

const getDisputeStatistics = `-- name: GetDisputeStatistics :one
SELECT 
  COUNT(*) as total_disputes,
  COUNT(CASE WHEN status = 'open' THEN 1 END) as open_disputes,
  COUNT(CASE WHEN status = 'investigating' THEN 1 END) as investigating_disputes,
  COUNT(CASE WHEN status = 'resolved' THEN 1 END) as resolved_disputes,
  COUNT(CASE WHEN status = 'closed' THEN 1 END) as closed_disputes,
  COUNT(CASE WHEN dispute_type = 'payment' THEN 1 END) as payment_disputes,
  COUNT(CASE WHEN dispute_type = 'property_condition' THEN 1 END) as property_disputes,
  AVG(EXTRACT(EPOCH FROM (resolved_at - created_at))/86400) as avg_resolution_days
FROM dispute_cases 
WHERE created_at >= $1
`

type GetDisputeStatisticsRow struct {
	TotalDisputes         int64   `json:"total_disputes"`
	OpenDisputes          int64   `json:"open_disputes"`
	InvestigatingDisputes int64   `json:"investigating_disputes"`
	ResolvedDisputes      int64   `json:"resolved_disputes"`
	ClosedDisputes        int64   `json:"closed_disputes"`
	PaymentDisputes       int64   `json:"payment_disputes"`
	PropertyDisputes      int64   `json:"property_disputes"`
	AvgResolutionDays     float64 `json:"avg_resolution_days"`
}

// Get dispute statistics
func (q *Queries) GetDisputeStatistics(ctx context.Context, createdAt pgtype.Timestamptz) (GetDisputeStatisticsRow, error) {
	row := q.db.QueryRow(ctx, getDisputeStatistics, createdAt)
	var i GetDisputeStatisticsRow
	err := row.Scan(
		&i.TotalDisputes,
		&i.OpenDisputes,
		&i.InvestigatingDisputes,
		&i.ResolvedDisputes,
		&i.ClosedDisputes,
		&i.PaymentDisputes,
		&i.PropertyDisputes,
		&i.AvgResolutionDays,
	)
	return i, err
}

const getDisputesAssignedToAdmin = `-- name: GetDisputesAssignedToAdmin :many
SELECT dc.id, dc.complainant_id, dc.respondent_id, dc.related_entity_type, dc.related_entity_id, dc.dispute_type, dc.description, dc.evidence_files, dc.status, dc.assigned_admin_id, dc.resolution_notes, dc.resolved_at, dc.created_at, dc.updated_at, 
       c.first_name as complainant_first_name, c.last_name as complainant_last_name, c.email as complainant_email,
       r.first_name as respondent_first_name, r.last_name as respondent_last_name, r.email as respondent_email
FROM dispute_cases dc
JOIN users c ON dc.complainant_id = c.id
JOIN users r ON dc.respondent_id = r.id
WHERE dc.assigned_admin_id = $1
ORDER BY dc.created_at ASC
LIMIT $2 OFFSET $3
`

type GetDisputesAssignedToAdminParams struct {
	AssignedAdminID pgtype.Int8 `json:"assigned_admin_id"`
	Limit           int32       `json:"limit"`
	Offset          int32       `json:"offset"`
}

type GetDisputesAssignedToAdminRow struct {
	ID                   int64                 `json:"id"`
	ComplainantID        int64                 `json:"complainant_id"`
	RespondentID         int64                 `json:"respondent_id"`
	RelatedEntityType    NullDisputeEntityEnum `json:"related_entity_type"`
	RelatedEntityID      pgtype.Int8           `json:"related_entity_id"`
	DisputeType          DisputeTypeEnum       `json:"dispute_type"`
	Description          string                `json:"description"`
	EvidenceFiles        pgtype.Text           `json:"evidence_files"`
	Status               NullDisputeStatusEnum `json:"status"`
	AssignedAdminID      pgtype.Int8           `json:"assigned_admin_id"`
	ResolutionNotes      pgtype.Text           `json:"resolution_notes"`
	ResolvedAt           pgtype.Timestamptz    `json:"resolved_at"`
	CreatedAt            pgtype.Timestamptz    `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz    `json:"updated_at"`
	ComplainantFirstName string                `json:"complainant_first_name"`
	ComplainantLastName  string                `json:"complainant_last_name"`
	ComplainantEmail     string                `json:"complainant_email"`
	RespondentFirstName  string                `json:"respondent_first_name"`
	RespondentLastName   string                `json:"respondent_last_name"`
	RespondentEmail      string                `json:"respondent_email"`
}

// Get disputes assigned to admin
func (q *Queries) GetDisputesAssignedToAdmin(ctx context.Context, arg GetDisputesAssignedToAdminParams) ([]GetDisputesAssignedToAdminRow, error) {
	rows, err := q.db.Query(ctx, getDisputesAssignedToAdmin, arg.AssignedAdminID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDisputesAssignedToAdminRow{}
	for rows.Next() {
		var i GetDisputesAssignedToAdminRow
		if err := rows.Scan(
			&i.ID,
			&i.ComplainantID,
			&i.RespondentID,
			&i.RelatedEntityType,
			&i.RelatedEntityID,
			&i.DisputeType,
			&i.Description,
			&i.EvidenceFiles,
			&i.Status,
			&i.AssignedAdminID,
			&i.ResolutionNotes,
			&i.ResolvedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ComplainantFirstName,
			&i.ComplainantLastName,
			&i.ComplainantEmail,
			&i.RespondentFirstName,
			&i.RespondentLastName,
			&i.RespondentEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDisputesByEntity = `-- name: GetDisputesByEntity :many
SELECT dc.id, dc.complainant_id, dc.respondent_id, dc.related_entity_type, dc.related_entity_id, dc.dispute_type, dc.description, dc.evidence_files, dc.status, dc.assigned_admin_id, dc.resolution_notes, dc.resolved_at, dc.created_at, dc.updated_at, 
       c.first_name as complainant_first_name, c.last_name as complainant_last_name,
       r.first_name as respondent_first_name, r.last_name as respondent_last_name
FROM dispute_cases dc
JOIN users c ON dc.complainant_id = c.id
JOIN users r ON dc.respondent_id = r.id
WHERE dc.related_entity_type = $1 AND dc.related_entity_id = $2
ORDER BY dc.created_at DESC
LIMIT $3 OFFSET $4
`

type GetDisputesByEntityParams struct {
	RelatedEntityType NullDisputeEntityEnum `json:"related_entity_type"`
	RelatedEntityID   pgtype.Int8           `json:"related_entity_id"`
	Limit             int32                 `json:"limit"`
	Offset            int32                 `json:"offset"`
}

type GetDisputesByEntityRow struct {
	ID                   int64                 `json:"id"`
	ComplainantID        int64                 `json:"complainant_id"`
	RespondentID         int64                 `json:"respondent_id"`
	RelatedEntityType    NullDisputeEntityEnum `json:"related_entity_type"`
	RelatedEntityID      pgtype.Int8           `json:"related_entity_id"`
	DisputeType          DisputeTypeEnum       `json:"dispute_type"`
	Description          string                `json:"description"`
	EvidenceFiles        pgtype.Text           `json:"evidence_files"`
	Status               NullDisputeStatusEnum `json:"status"`
	AssignedAdminID      pgtype.Int8           `json:"assigned_admin_id"`
	ResolutionNotes      pgtype.Text           `json:"resolution_notes"`
	ResolvedAt           pgtype.Timestamptz    `json:"resolved_at"`
	CreatedAt            pgtype.Timestamptz    `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz    `json:"updated_at"`
	ComplainantFirstName string                `json:"complainant_first_name"`
	ComplainantLastName  string                `json:"complainant_last_name"`
	RespondentFirstName  string                `json:"respondent_first_name"`
	RespondentLastName   string                `json:"respondent_last_name"`
}

// Get disputes by entity
func (q *Queries) GetDisputesByEntity(ctx context.Context, arg GetDisputesByEntityParams) ([]GetDisputesByEntityRow, error) {
	rows, err := q.db.Query(ctx, getDisputesByEntity,
		arg.RelatedEntityType,
		arg.RelatedEntityID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDisputesByEntityRow{}
	for rows.Next() {
		var i GetDisputesByEntityRow
		if err := rows.Scan(
			&i.ID,
			&i.ComplainantID,
			&i.RespondentID,
			&i.RelatedEntityType,
			&i.RelatedEntityID,
			&i.DisputeType,
			&i.Description,
			&i.EvidenceFiles,
			&i.Status,
			&i.AssignedAdminID,
			&i.ResolutionNotes,
			&i.ResolvedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ComplainantFirstName,
			&i.ComplainantLastName,
			&i.RespondentFirstName,
			&i.RespondentLastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDisputesByStatus = `-- name: GetDisputesByStatus :many
SELECT dc.id, dc.complainant_id, dc.respondent_id, dc.related_entity_type, dc.related_entity_id, dc.dispute_type, dc.description, dc.evidence_files, dc.status, dc.assigned_admin_id, dc.resolution_notes, dc.resolved_at, dc.created_at, dc.updated_at, 
       c.first_name as complainant_first_name, c.last_name as complainant_last_name,
       r.first_name as respondent_first_name, r.last_name as respondent_last_name,
       a.first_name as admin_first_name, a.last_name as admin_last_name
FROM dispute_cases dc
JOIN users c ON dc.complainant_id = c.id
JOIN users r ON dc.respondent_id = r.id
LEFT JOIN users a ON dc.assigned_admin_id = a.id
WHERE dc.status = $1
ORDER BY dc.created_at ASC
LIMIT $2 OFFSET $3
`

type GetDisputesByStatusParams struct {
	Status NullDisputeStatusEnum `json:"status"`
	Limit  int32                 `json:"limit"`
	Offset int32                 `json:"offset"`
}

type GetDisputesByStatusRow struct {
	ID                   int64                 `json:"id"`
	ComplainantID        int64                 `json:"complainant_id"`
	RespondentID         int64                 `json:"respondent_id"`
	RelatedEntityType    NullDisputeEntityEnum `json:"related_entity_type"`
	RelatedEntityID      pgtype.Int8           `json:"related_entity_id"`
	DisputeType          DisputeTypeEnum       `json:"dispute_type"`
	Description          string                `json:"description"`
	EvidenceFiles        pgtype.Text           `json:"evidence_files"`
	Status               NullDisputeStatusEnum `json:"status"`
	AssignedAdminID      pgtype.Int8           `json:"assigned_admin_id"`
	ResolutionNotes      pgtype.Text           `json:"resolution_notes"`
	ResolvedAt           pgtype.Timestamptz    `json:"resolved_at"`
	CreatedAt            pgtype.Timestamptz    `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz    `json:"updated_at"`
	ComplainantFirstName string                `json:"complainant_first_name"`
	ComplainantLastName  string                `json:"complainant_last_name"`
	RespondentFirstName  string                `json:"respondent_first_name"`
	RespondentLastName   string                `json:"respondent_last_name"`
	AdminFirstName       pgtype.Text           `json:"admin_first_name"`
	AdminLastName        pgtype.Text           `json:"admin_last_name"`
}

// Get disputes by status
func (q *Queries) GetDisputesByStatus(ctx context.Context, arg GetDisputesByStatusParams) ([]GetDisputesByStatusRow, error) {
	rows, err := q.db.Query(ctx, getDisputesByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDisputesByStatusRow{}
	for rows.Next() {
		var i GetDisputesByStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.ComplainantID,
			&i.RespondentID,
			&i.RelatedEntityType,
			&i.RelatedEntityID,
			&i.DisputeType,
			&i.Description,
			&i.EvidenceFiles,
			&i.Status,
			&i.AssignedAdminID,
			&i.ResolutionNotes,
			&i.ResolvedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ComplainantFirstName,
			&i.ComplainantLastName,
			&i.RespondentFirstName,
			&i.RespondentLastName,
			&i.AdminFirstName,
			&i.AdminLastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDisputesByType = `-- name: GetDisputesByType :many
SELECT dc.id, dc.complainant_id, dc.respondent_id, dc.related_entity_type, dc.related_entity_id, dc.dispute_type, dc.description, dc.evidence_files, dc.status, dc.assigned_admin_id, dc.resolution_notes, dc.resolved_at, dc.created_at, dc.updated_at, 
       c.first_name as complainant_first_name, c.last_name as complainant_last_name,
       r.first_name as respondent_first_name, r.last_name as respondent_last_name
FROM dispute_cases dc
JOIN users c ON dc.complainant_id = c.id
JOIN users r ON dc.respondent_id = r.id
WHERE dc.dispute_type = $1
ORDER BY dc.created_at DESC
LIMIT $2 OFFSET $3
`

type GetDisputesByTypeParams struct {
	DisputeType DisputeTypeEnum `json:"dispute_type"`
	Limit       int32           `json:"limit"`
	Offset      int32           `json:"offset"`
}

type GetDisputesByTypeRow struct {
	ID                   int64                 `json:"id"`
	ComplainantID        int64                 `json:"complainant_id"`
	RespondentID         int64                 `json:"respondent_id"`
	RelatedEntityType    NullDisputeEntityEnum `json:"related_entity_type"`
	RelatedEntityID      pgtype.Int8           `json:"related_entity_id"`
	DisputeType          DisputeTypeEnum       `json:"dispute_type"`
	Description          string                `json:"description"`
	EvidenceFiles        pgtype.Text           `json:"evidence_files"`
	Status               NullDisputeStatusEnum `json:"status"`
	AssignedAdminID      pgtype.Int8           `json:"assigned_admin_id"`
	ResolutionNotes      pgtype.Text           `json:"resolution_notes"`
	ResolvedAt           pgtype.Timestamptz    `json:"resolved_at"`
	CreatedAt            pgtype.Timestamptz    `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz    `json:"updated_at"`
	ComplainantFirstName string                `json:"complainant_first_name"`
	ComplainantLastName  string                `json:"complainant_last_name"`
	RespondentFirstName  string                `json:"respondent_first_name"`
	RespondentLastName   string                `json:"respondent_last_name"`
}

// Get disputes by type
func (q *Queries) GetDisputesByType(ctx context.Context, arg GetDisputesByTypeParams) ([]GetDisputesByTypeRow, error) {
	rows, err := q.db.Query(ctx, getDisputesByType, arg.DisputeType, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDisputesByTypeRow{}
	for rows.Next() {
		var i GetDisputesByTypeRow
		if err := rows.Scan(
			&i.ID,
			&i.ComplainantID,
			&i.RespondentID,
			&i.RelatedEntityType,
			&i.RelatedEntityID,
			&i.DisputeType,
			&i.Description,
			&i.EvidenceFiles,
			&i.Status,
			&i.AssignedAdminID,
			&i.ResolutionNotes,
			&i.ResolvedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ComplainantFirstName,
			&i.ComplainantLastName,
			&i.RespondentFirstName,
			&i.RespondentLastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDisputesForComplainant = `-- name: GetDisputesForComplainant :many
SELECT dc.id, dc.complainant_id, dc.respondent_id, dc.related_entity_type, dc.related_entity_id, dc.dispute_type, dc.description, dc.evidence_files, dc.status, dc.assigned_admin_id, dc.resolution_notes, dc.resolved_at, dc.created_at, dc.updated_at, 
       r.first_name as respondent_first_name, r.last_name as respondent_last_name,
       a.first_name as admin_first_name, a.last_name as admin_last_name
FROM dispute_cases dc
JOIN users r ON dc.respondent_id = r.id
LEFT JOIN users a ON dc.assigned_admin_id = a.id
WHERE dc.complainant_id = $1
ORDER BY dc.created_at DESC
LIMIT $2 OFFSET $3
`

type GetDisputesForComplainantParams struct {
	ComplainantID int64 `json:"complainant_id"`
	Limit         int32 `json:"limit"`
	Offset        int32 `json:"offset"`
}

type GetDisputesForComplainantRow struct {
	ID                  int64                 `json:"id"`
	ComplainantID       int64                 `json:"complainant_id"`
	RespondentID        int64                 `json:"respondent_id"`
	RelatedEntityType   NullDisputeEntityEnum `json:"related_entity_type"`
	RelatedEntityID     pgtype.Int8           `json:"related_entity_id"`
	DisputeType         DisputeTypeEnum       `json:"dispute_type"`
	Description         string                `json:"description"`
	EvidenceFiles       pgtype.Text           `json:"evidence_files"`
	Status              NullDisputeStatusEnum `json:"status"`
	AssignedAdminID     pgtype.Int8           `json:"assigned_admin_id"`
	ResolutionNotes     pgtype.Text           `json:"resolution_notes"`
	ResolvedAt          pgtype.Timestamptz    `json:"resolved_at"`
	CreatedAt           pgtype.Timestamptz    `json:"created_at"`
	UpdatedAt           pgtype.Timestamptz    `json:"updated_at"`
	RespondentFirstName string                `json:"respondent_first_name"`
	RespondentLastName  string                `json:"respondent_last_name"`
	AdminFirstName      pgtype.Text           `json:"admin_first_name"`
	AdminLastName       pgtype.Text           `json:"admin_last_name"`
}

// Get disputes for complainant
func (q *Queries) GetDisputesForComplainant(ctx context.Context, arg GetDisputesForComplainantParams) ([]GetDisputesForComplainantRow, error) {
	rows, err := q.db.Query(ctx, getDisputesForComplainant, arg.ComplainantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDisputesForComplainantRow{}
	for rows.Next() {
		var i GetDisputesForComplainantRow
		if err := rows.Scan(
			&i.ID,
			&i.ComplainantID,
			&i.RespondentID,
			&i.RelatedEntityType,
			&i.RelatedEntityID,
			&i.DisputeType,
			&i.Description,
			&i.EvidenceFiles,
			&i.Status,
			&i.AssignedAdminID,
			&i.ResolutionNotes,
			&i.ResolvedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RespondentFirstName,
			&i.RespondentLastName,
			&i.AdminFirstName,
			&i.AdminLastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDisputesForRespondent = `-- name: GetDisputesForRespondent :many
SELECT dc.id, dc.complainant_id, dc.respondent_id, dc.related_entity_type, dc.related_entity_id, dc.dispute_type, dc.description, dc.evidence_files, dc.status, dc.assigned_admin_id, dc.resolution_notes, dc.resolved_at, dc.created_at, dc.updated_at, 
       c.first_name as complainant_first_name, c.last_name as complainant_last_name,
       a.first_name as admin_first_name, a.last_name as admin_last_name
FROM dispute_cases dc
JOIN users c ON dc.complainant_id = c.id
LEFT JOIN users a ON dc.assigned_admin_id = a.id
WHERE dc.respondent_id = $1
ORDER BY dc.created_at DESC
LIMIT $2 OFFSET $3
`

type GetDisputesForRespondentParams struct {
	RespondentID int64 `json:"respondent_id"`
	Limit        int32 `json:"limit"`
	Offset       int32 `json:"offset"`
}

type GetDisputesForRespondentRow struct {
	ID                   int64                 `json:"id"`
	ComplainantID        int64                 `json:"complainant_id"`
	RespondentID         int64                 `json:"respondent_id"`
	RelatedEntityType    NullDisputeEntityEnum `json:"related_entity_type"`
	RelatedEntityID      pgtype.Int8           `json:"related_entity_id"`
	DisputeType          DisputeTypeEnum       `json:"dispute_type"`
	Description          string                `json:"description"`
	EvidenceFiles        pgtype.Text           `json:"evidence_files"`
	Status               NullDisputeStatusEnum `json:"status"`
	AssignedAdminID      pgtype.Int8           `json:"assigned_admin_id"`
	ResolutionNotes      pgtype.Text           `json:"resolution_notes"`
	ResolvedAt           pgtype.Timestamptz    `json:"resolved_at"`
	CreatedAt            pgtype.Timestamptz    `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz    `json:"updated_at"`
	ComplainantFirstName string                `json:"complainant_first_name"`
	ComplainantLastName  string                `json:"complainant_last_name"`
	AdminFirstName       pgtype.Text           `json:"admin_first_name"`
	AdminLastName        pgtype.Text           `json:"admin_last_name"`
}

// Get disputes for respondent
func (q *Queries) GetDisputesForRespondent(ctx context.Context, arg GetDisputesForRespondentParams) ([]GetDisputesForRespondentRow, error) {
	rows, err := q.db.Query(ctx, getDisputesForRespondent, arg.RespondentID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDisputesForRespondentRow{}
	for rows.Next() {
		var i GetDisputesForRespondentRow
		if err := rows.Scan(
			&i.ID,
			&i.ComplainantID,
			&i.RespondentID,
			&i.RelatedEntityType,
			&i.RelatedEntityID,
			&i.DisputeType,
			&i.Description,
			&i.EvidenceFiles,
			&i.Status,
			&i.AssignedAdminID,
			&i.ResolutionNotes,
			&i.ResolvedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ComplainantFirstName,
			&i.ComplainantLastName,
			&i.AdminFirstName,
			&i.AdminLastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOpenDisputes = `-- name: GetOpenDisputes :many
SELECT dc.id, dc.complainant_id, dc.respondent_id, dc.related_entity_type, dc.related_entity_id, dc.dispute_type, dc.description, dc.evidence_files, dc.status, dc.assigned_admin_id, dc.resolution_notes, dc.resolved_at, dc.created_at, dc.updated_at, 
       c.first_name as complainant_first_name, c.last_name as complainant_last_name, c.email as complainant_email,
       r.first_name as respondent_first_name, r.last_name as respondent_last_name, r.email as respondent_email
FROM dispute_cases dc
JOIN users c ON dc.complainant_id = c.id
JOIN users r ON dc.respondent_id = r.id
WHERE dc.status = 'open'
ORDER BY dc.created_at ASC
LIMIT $1 OFFSET $2
`

type GetOpenDisputesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetOpenDisputesRow struct {
	ID                   int64                 `json:"id"`
	ComplainantID        int64                 `json:"complainant_id"`
	RespondentID         int64                 `json:"respondent_id"`
	RelatedEntityType    NullDisputeEntityEnum `json:"related_entity_type"`
	RelatedEntityID      pgtype.Int8           `json:"related_entity_id"`
	DisputeType          DisputeTypeEnum       `json:"dispute_type"`
	Description          string                `json:"description"`
	EvidenceFiles        pgtype.Text           `json:"evidence_files"`
	Status               NullDisputeStatusEnum `json:"status"`
	AssignedAdminID      pgtype.Int8           `json:"assigned_admin_id"`
	ResolutionNotes      pgtype.Text           `json:"resolution_notes"`
	ResolvedAt           pgtype.Timestamptz    `json:"resolved_at"`
	CreatedAt            pgtype.Timestamptz    `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz    `json:"updated_at"`
	ComplainantFirstName string                `json:"complainant_first_name"`
	ComplainantLastName  string                `json:"complainant_last_name"`
	ComplainantEmail     string                `json:"complainant_email"`
	RespondentFirstName  string                `json:"respondent_first_name"`
	RespondentLastName   string                `json:"respondent_last_name"`
	RespondentEmail      string                `json:"respondent_email"`
}

// Get open disputes
func (q *Queries) GetOpenDisputes(ctx context.Context, arg GetOpenDisputesParams) ([]GetOpenDisputesRow, error) {
	rows, err := q.db.Query(ctx, getOpenDisputes, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOpenDisputesRow{}
	for rows.Next() {
		var i GetOpenDisputesRow
		if err := rows.Scan(
			&i.ID,
			&i.ComplainantID,
			&i.RespondentID,
			&i.RelatedEntityType,
			&i.RelatedEntityID,
			&i.DisputeType,
			&i.Description,
			&i.EvidenceFiles,
			&i.Status,
			&i.AssignedAdminID,
			&i.ResolutionNotes,
			&i.ResolvedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ComplainantFirstName,
			&i.ComplainantLastName,
			&i.ComplainantEmail,
			&i.RespondentFirstName,
			&i.RespondentLastName,
			&i.RespondentEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnassignedDisputes = `-- name: GetUnassignedDisputes :many
SELECT dc.id, dc.complainant_id, dc.respondent_id, dc.related_entity_type, dc.related_entity_id, dc.dispute_type, dc.description, dc.evidence_files, dc.status, dc.assigned_admin_id, dc.resolution_notes, dc.resolved_at, dc.created_at, dc.updated_at, 
       c.first_name as complainant_first_name, c.last_name as complainant_last_name, c.email as complainant_email,
       r.first_name as respondent_first_name, r.last_name as respondent_last_name, r.email as respondent_email
FROM dispute_cases dc
JOIN users c ON dc.complainant_id = c.id
JOIN users r ON dc.respondent_id = r.id
WHERE dc.assigned_admin_id IS NULL AND dc.status = 'open'
ORDER BY dc.created_at ASC
LIMIT $1 OFFSET $2
`

type GetUnassignedDisputesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetUnassignedDisputesRow struct {
	ID                   int64                 `json:"id"`
	ComplainantID        int64                 `json:"complainant_id"`
	RespondentID         int64                 `json:"respondent_id"`
	RelatedEntityType    NullDisputeEntityEnum `json:"related_entity_type"`
	RelatedEntityID      pgtype.Int8           `json:"related_entity_id"`
	DisputeType          DisputeTypeEnum       `json:"dispute_type"`
	Description          string                `json:"description"`
	EvidenceFiles        pgtype.Text           `json:"evidence_files"`
	Status               NullDisputeStatusEnum `json:"status"`
	AssignedAdminID      pgtype.Int8           `json:"assigned_admin_id"`
	ResolutionNotes      pgtype.Text           `json:"resolution_notes"`
	ResolvedAt           pgtype.Timestamptz    `json:"resolved_at"`
	CreatedAt            pgtype.Timestamptz    `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz    `json:"updated_at"`
	ComplainantFirstName string                `json:"complainant_first_name"`
	ComplainantLastName  string                `json:"complainant_last_name"`
	ComplainantEmail     string                `json:"complainant_email"`
	RespondentFirstName  string                `json:"respondent_first_name"`
	RespondentLastName   string                `json:"respondent_last_name"`
	RespondentEmail      string                `json:"respondent_email"`
}

// Get unassigned disputes
func (q *Queries) GetUnassignedDisputes(ctx context.Context, arg GetUnassignedDisputesParams) ([]GetUnassignedDisputesRow, error) {
	rows, err := q.db.Query(ctx, getUnassignedDisputes, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUnassignedDisputesRow{}
	for rows.Next() {
		var i GetUnassignedDisputesRow
		if err := rows.Scan(
			&i.ID,
			&i.ComplainantID,
			&i.RespondentID,
			&i.RelatedEntityType,
			&i.RelatedEntityID,
			&i.DisputeType,
			&i.Description,
			&i.EvidenceFiles,
			&i.Status,
			&i.AssignedAdminID,
			&i.ResolutionNotes,
			&i.ResolvedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ComplainantFirstName,
			&i.ComplainantLastName,
			&i.ComplainantEmail,
			&i.RespondentFirstName,
			&i.RespondentLastName,
			&i.RespondentEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resolveDispute = `-- name: ResolveDispute :one
UPDATE dispute_cases 
SET status = 'resolved', resolution_notes = $2, resolved_at = NOW(), updated_at = NOW()
WHERE id = $1 
RETURNING id, complainant_id, respondent_id, related_entity_type, related_entity_id, dispute_type, description, evidence_files, status, assigned_admin_id, resolution_notes, resolved_at, created_at, updated_at
`

type ResolveDisputeParams struct {
	ID              int64       `json:"id"`
	ResolutionNotes pgtype.Text `json:"resolution_notes"`
}

// Resolve dispute
func (q *Queries) ResolveDispute(ctx context.Context, arg ResolveDisputeParams) (DisputeCase, error) {
	row := q.db.QueryRow(ctx, resolveDispute, arg.ID, arg.ResolutionNotes)
	var i DisputeCase
	err := row.Scan(
		&i.ID,
		&i.ComplainantID,
		&i.RespondentID,
		&i.RelatedEntityType,
		&i.RelatedEntityID,
		&i.DisputeType,
		&i.Description,
		&i.EvidenceFiles,
		&i.Status,
		&i.AssignedAdminID,
		&i.ResolutionNotes,
		&i.ResolvedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateDisputeCase = `-- name: UpdateDisputeCase :one
UPDATE dispute_cases 
SET description = $2, evidence_files = $3, updated_at = NOW()
WHERE id = $1 
RETURNING id, complainant_id, respondent_id, related_entity_type, related_entity_id, dispute_type, description, evidence_files, status, assigned_admin_id, resolution_notes, resolved_at, created_at, updated_at
`

type UpdateDisputeCaseParams struct {
	ID            int64       `json:"id"`
	Description   string      `json:"description"`
	EvidenceFiles pgtype.Text `json:"evidence_files"`
}

// Update dispute case
func (q *Queries) UpdateDisputeCase(ctx context.Context, arg UpdateDisputeCaseParams) (DisputeCase, error) {
	row := q.db.QueryRow(ctx, updateDisputeCase, arg.ID, arg.Description, arg.EvidenceFiles)
	var i DisputeCase
	err := row.Scan(
		&i.ID,
		&i.ComplainantID,
		&i.RespondentID,
		&i.RelatedEntityType,
		&i.RelatedEntityID,
		&i.DisputeType,
		&i.Description,
		&i.EvidenceFiles,
		&i.Status,
		&i.AssignedAdminID,
		&i.ResolutionNotes,
		&i.ResolvedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateDisputeStatus = `-- name: UpdateDisputeStatus :one
UPDATE dispute_cases 
SET status = $2, updated_at = NOW()
WHERE id = $1 
RETURNING id, complainant_id, respondent_id, related_entity_type, related_entity_id, dispute_type, description, evidence_files, status, assigned_admin_id, resolution_notes, resolved_at, created_at, updated_at
`

type UpdateDisputeStatusParams struct {
	ID     int64                 `json:"id"`
	Status NullDisputeStatusEnum `json:"status"`
}

// Update dispute status
func (q *Queries) UpdateDisputeStatus(ctx context.Context, arg UpdateDisputeStatusParams) (DisputeCase, error) {
	row := q.db.QueryRow(ctx, updateDisputeStatus, arg.ID, arg.Status)
	var i DisputeCase
	err := row.Scan(
		&i.ID,
		&i.ComplainantID,
		&i.RespondentID,
		&i.RelatedEntityType,
		&i.RelatedEntityID,
		&i.DisputeType,
		&i.Description,
		&i.EvidenceFiles,
		&i.Status,
		&i.AssignedAdminID,
		&i.ResolutionNotes,
		&i.ResolvedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
