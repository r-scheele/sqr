// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: rental_application.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const approveRentalApplication = `-- name: ApproveRentalApplication :one
UPDATE rental_applications 
SET status = 'approved', decided_at = NOW(), decided_by = $2, updated_at = NOW()
WHERE id = $1 
RETURNING id, property_id, tenant_id, landlord_id, application_documents, employment_details, "references", preferred_move_in_date, additional_notes, status, decision_reason, decided_at, decided_by, created_at, updated_at
`

type ApproveRentalApplicationParams struct {
	ID        int64       `json:"id"`
	DecidedBy pgtype.Int8 `json:"decided_by"`
}

// Approve rental application
func (q *Queries) ApproveRentalApplication(ctx context.Context, arg ApproveRentalApplicationParams) (RentalApplication, error) {
	row := q.db.QueryRow(ctx, approveRentalApplication, arg.ID, arg.DecidedBy)
	var i RentalApplication
	err := row.Scan(
		&i.ID,
		&i.PropertyID,
		&i.TenantID,
		&i.LandlordID,
		&i.ApplicationDocuments,
		&i.EmploymentDetails,
		&i.References,
		&i.PreferredMoveInDate,
		&i.AdditionalNotes,
		&i.Status,
		&i.DecisionReason,
		&i.DecidedAt,
		&i.DecidedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const checkTenantApplicationForProperty = `-- name: CheckTenantApplicationForProperty :one
SELECT EXISTS(
  SELECT 1 FROM rental_applications 
  WHERE tenant_id = $1 AND property_id = $2 AND status NOT IN ('rejected', 'withdrawn')
)
`

type CheckTenantApplicationForPropertyParams struct {
	TenantID   int64 `json:"tenant_id"`
	PropertyID int64 `json:"property_id"`
}

// Check if tenant has application for property
func (q *Queries) CheckTenantApplicationForProperty(ctx context.Context, arg CheckTenantApplicationForPropertyParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkTenantApplicationForProperty, arg.TenantID, arg.PropertyID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const countLandlordRentalApplications = `-- name: CountLandlordRentalApplications :one
SELECT COUNT(*) FROM rental_applications 
WHERE landlord_id = $1
`

// Count landlord's rental applications
func (q *Queries) CountLandlordRentalApplications(ctx context.Context, landlordID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countLandlordRentalApplications, landlordID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPropertyRentalApplications = `-- name: CountPropertyRentalApplications :one
SELECT COUNT(*) FROM rental_applications 
WHERE property_id = $1
`

// Count property rental applications
func (q *Queries) CountPropertyRentalApplications(ctx context.Context, propertyID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countPropertyRentalApplications, propertyID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countRentalApplicationsByStatus = `-- name: CountRentalApplicationsByStatus :one
SELECT COUNT(*) FROM rental_applications 
WHERE status = $1
`

// Count rental applications by status
func (q *Queries) CountRentalApplicationsByStatus(ctx context.Context, status NullApplicationStatusEnum) (int64, error) {
	row := q.db.QueryRow(ctx, countRentalApplicationsByStatus, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countTenantRentalApplications = `-- name: CountTenantRentalApplications :one
SELECT COUNT(*) FROM rental_applications 
WHERE tenant_id = $1
`

// Count tenant's rental applications
func (q *Queries) CountTenantRentalApplications(ctx context.Context, tenantID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countTenantRentalApplications, tenantID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createRentalApplication = `-- name: CreateRentalApplication :one
INSERT INTO rental_applications (
  property_id, tenant_id, landlord_id, application_documents, employment_details,
  "references", preferred_move_in_date, additional_notes
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING id, property_id, tenant_id, landlord_id, application_documents, employment_details, "references", preferred_move_in_date, additional_notes, status, decision_reason, decided_at, decided_by, created_at, updated_at
`

type CreateRentalApplicationParams struct {
	PropertyID           int64       `json:"property_id"`
	TenantID             int64       `json:"tenant_id"`
	LandlordID           int64       `json:"landlord_id"`
	ApplicationDocuments pgtype.Text `json:"application_documents"`
	EmploymentDetails    pgtype.Text `json:"employment_details"`
	References           pgtype.Text `json:"references"`
	PreferredMoveInDate  pgtype.Date `json:"preferred_move_in_date"`
	AdditionalNotes      pgtype.Text `json:"additional_notes"`
}

// Create rental application
func (q *Queries) CreateRentalApplication(ctx context.Context, arg CreateRentalApplicationParams) (RentalApplication, error) {
	row := q.db.QueryRow(ctx, createRentalApplication,
		arg.PropertyID,
		arg.TenantID,
		arg.LandlordID,
		arg.ApplicationDocuments,
		arg.EmploymentDetails,
		arg.References,
		arg.PreferredMoveInDate,
		arg.AdditionalNotes,
	)
	var i RentalApplication
	err := row.Scan(
		&i.ID,
		&i.PropertyID,
		&i.TenantID,
		&i.LandlordID,
		&i.ApplicationDocuments,
		&i.EmploymentDetails,
		&i.References,
		&i.PreferredMoveInDate,
		&i.AdditionalNotes,
		&i.Status,
		&i.DecisionReason,
		&i.DecidedAt,
		&i.DecidedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteRentalApplication = `-- name: DeleteRentalApplication :exec
DELETE FROM rental_applications 
WHERE id = $1
`

// Delete rental application
func (q *Queries) DeleteRentalApplication(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteRentalApplication, id)
	return err
}

const getLandlordApplicationStats = `-- name: GetLandlordApplicationStats :one
SELECT 
  COUNT(*) as total_applications,
  COUNT(CASE WHEN status = 'submitted' THEN 1 END) as pending_review,
  COUNT(CASE WHEN status = 'approved' THEN 1 END) as approved_count,
  COUNT(CASE WHEN status = 'rejected' THEN 1 END) as rejected_count
FROM rental_applications 
WHERE landlord_id = $1
`

type GetLandlordApplicationStatsRow struct {
	TotalApplications int64 `json:"total_applications"`
	PendingReview     int64 `json:"pending_review"`
	ApprovedCount     int64 `json:"approved_count"`
	RejectedCount     int64 `json:"rejected_count"`
}

// Get application statistics for landlord
func (q *Queries) GetLandlordApplicationStats(ctx context.Context, landlordID int64) (GetLandlordApplicationStatsRow, error) {
	row := q.db.QueryRow(ctx, getLandlordApplicationStats, landlordID)
	var i GetLandlordApplicationStatsRow
	err := row.Scan(
		&i.TotalApplications,
		&i.PendingReview,
		&i.ApprovedCount,
		&i.RejectedCount,
	)
	return i, err
}

const getLandlordRentalApplications = `-- name: GetLandlordRentalApplications :many
SELECT ra.id, ra.property_id, ra.tenant_id, ra.landlord_id, ra.application_documents, ra.employment_details, ra."references", ra.preferred_move_in_date, ra.additional_notes, ra.status, ra.decision_reason, ra.decided_at, ra.decided_by, ra.created_at, ra.updated_at, p.title as property_title,
       t.first_name as tenant_first_name, t.last_name as tenant_last_name, t.email as tenant_email,
       tp.occupation, tp.monthly_income
FROM rental_applications ra
JOIN properties p ON ra.property_id = p.id
JOIN users t ON ra.tenant_id = t.id
LEFT JOIN tenant_profiles tp ON t.id = tp.user_id
WHERE ra.landlord_id = $1
ORDER BY ra.created_at DESC
LIMIT $2 OFFSET $3
`

type GetLandlordRentalApplicationsParams struct {
	LandlordID int64 `json:"landlord_id"`
	Limit      int32 `json:"limit"`
	Offset     int32 `json:"offset"`
}

type GetLandlordRentalApplicationsRow struct {
	ID                   int64                     `json:"id"`
	PropertyID           int64                     `json:"property_id"`
	TenantID             int64                     `json:"tenant_id"`
	LandlordID           int64                     `json:"landlord_id"`
	ApplicationDocuments pgtype.Text               `json:"application_documents"`
	EmploymentDetails    pgtype.Text               `json:"employment_details"`
	References           pgtype.Text               `json:"references"`
	PreferredMoveInDate  pgtype.Date               `json:"preferred_move_in_date"`
	AdditionalNotes      pgtype.Text               `json:"additional_notes"`
	Status               NullApplicationStatusEnum `json:"status"`
	DecisionReason       pgtype.Text               `json:"decision_reason"`
	DecidedAt            pgtype.Timestamptz        `json:"decided_at"`
	DecidedBy            pgtype.Int8               `json:"decided_by"`
	CreatedAt            pgtype.Timestamptz        `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz        `json:"updated_at"`
	PropertyTitle        string                    `json:"property_title"`
	TenantFirstName      string                    `json:"tenant_first_name"`
	TenantLastName       string                    `json:"tenant_last_name"`
	TenantEmail          string                    `json:"tenant_email"`
	Occupation           pgtype.Text               `json:"occupation"`
	MonthlyIncome        pgtype.Numeric            `json:"monthly_income"`
}

// Get landlord's rental applications
func (q *Queries) GetLandlordRentalApplications(ctx context.Context, arg GetLandlordRentalApplicationsParams) ([]GetLandlordRentalApplicationsRow, error) {
	rows, err := q.db.Query(ctx, getLandlordRentalApplications, arg.LandlordID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetLandlordRentalApplicationsRow{}
	for rows.Next() {
		var i GetLandlordRentalApplicationsRow
		if err := rows.Scan(
			&i.ID,
			&i.PropertyID,
			&i.TenantID,
			&i.LandlordID,
			&i.ApplicationDocuments,
			&i.EmploymentDetails,
			&i.References,
			&i.PreferredMoveInDate,
			&i.AdditionalNotes,
			&i.Status,
			&i.DecisionReason,
			&i.DecidedAt,
			&i.DecidedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PropertyTitle,
			&i.TenantFirstName,
			&i.TenantLastName,
			&i.TenantEmail,
			&i.Occupation,
			&i.MonthlyIncome,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingApplicationsForLandlord = `-- name: GetPendingApplicationsForLandlord :many
SELECT ra.id, ra.property_id, ra.tenant_id, ra.landlord_id, ra.application_documents, ra.employment_details, ra."references", ra.preferred_move_in_date, ra.additional_notes, ra.status, ra.decision_reason, ra.decided_at, ra.decided_by, ra.created_at, ra.updated_at, p.title as property_title,
       t.first_name as tenant_first_name, t.last_name as tenant_last_name, t.email as tenant_email,
       tp.occupation, tp.monthly_income
FROM rental_applications ra
JOIN properties p ON ra.property_id = p.id
JOIN users t ON ra.tenant_id = t.id
LEFT JOIN tenant_profiles tp ON t.id = tp.user_id
WHERE ra.landlord_id = $1 AND ra.status IN ('submitted', 'under_review')
ORDER BY ra.created_at ASC
LIMIT $2 OFFSET $3
`

type GetPendingApplicationsForLandlordParams struct {
	LandlordID int64 `json:"landlord_id"`
	Limit      int32 `json:"limit"`
	Offset     int32 `json:"offset"`
}

type GetPendingApplicationsForLandlordRow struct {
	ID                   int64                     `json:"id"`
	PropertyID           int64                     `json:"property_id"`
	TenantID             int64                     `json:"tenant_id"`
	LandlordID           int64                     `json:"landlord_id"`
	ApplicationDocuments pgtype.Text               `json:"application_documents"`
	EmploymentDetails    pgtype.Text               `json:"employment_details"`
	References           pgtype.Text               `json:"references"`
	PreferredMoveInDate  pgtype.Date               `json:"preferred_move_in_date"`
	AdditionalNotes      pgtype.Text               `json:"additional_notes"`
	Status               NullApplicationStatusEnum `json:"status"`
	DecisionReason       pgtype.Text               `json:"decision_reason"`
	DecidedAt            pgtype.Timestamptz        `json:"decided_at"`
	DecidedBy            pgtype.Int8               `json:"decided_by"`
	CreatedAt            pgtype.Timestamptz        `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz        `json:"updated_at"`
	PropertyTitle        string                    `json:"property_title"`
	TenantFirstName      string                    `json:"tenant_first_name"`
	TenantLastName       string                    `json:"tenant_last_name"`
	TenantEmail          string                    `json:"tenant_email"`
	Occupation           pgtype.Text               `json:"occupation"`
	MonthlyIncome        pgtype.Numeric            `json:"monthly_income"`
}

// Get pending applications for landlord
func (q *Queries) GetPendingApplicationsForLandlord(ctx context.Context, arg GetPendingApplicationsForLandlordParams) ([]GetPendingApplicationsForLandlordRow, error) {
	rows, err := q.db.Query(ctx, getPendingApplicationsForLandlord, arg.LandlordID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPendingApplicationsForLandlordRow{}
	for rows.Next() {
		var i GetPendingApplicationsForLandlordRow
		if err := rows.Scan(
			&i.ID,
			&i.PropertyID,
			&i.TenantID,
			&i.LandlordID,
			&i.ApplicationDocuments,
			&i.EmploymentDetails,
			&i.References,
			&i.PreferredMoveInDate,
			&i.AdditionalNotes,
			&i.Status,
			&i.DecisionReason,
			&i.DecidedAt,
			&i.DecidedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PropertyTitle,
			&i.TenantFirstName,
			&i.TenantLastName,
			&i.TenantEmail,
			&i.Occupation,
			&i.MonthlyIncome,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPropertyRentalApplications = `-- name: GetPropertyRentalApplications :many
SELECT ra.id, ra.property_id, ra.tenant_id, ra.landlord_id, ra.application_documents, ra.employment_details, ra."references", ra.preferred_move_in_date, ra.additional_notes, ra.status, ra.decision_reason, ra.decided_at, ra.decided_by, ra.created_at, ra.updated_at, t.first_name as tenant_first_name, t.last_name as tenant_last_name, t.email as tenant_email,
       tp.occupation, tp.employer, tp.monthly_income
FROM rental_applications ra
JOIN users t ON ra.tenant_id = t.id
LEFT JOIN tenant_profiles tp ON t.id = tp.user_id
WHERE ra.property_id = $1
ORDER BY ra.created_at DESC
LIMIT $2 OFFSET $3
`

type GetPropertyRentalApplicationsParams struct {
	PropertyID int64 `json:"property_id"`
	Limit      int32 `json:"limit"`
	Offset     int32 `json:"offset"`
}

type GetPropertyRentalApplicationsRow struct {
	ID                   int64                     `json:"id"`
	PropertyID           int64                     `json:"property_id"`
	TenantID             int64                     `json:"tenant_id"`
	LandlordID           int64                     `json:"landlord_id"`
	ApplicationDocuments pgtype.Text               `json:"application_documents"`
	EmploymentDetails    pgtype.Text               `json:"employment_details"`
	References           pgtype.Text               `json:"references"`
	PreferredMoveInDate  pgtype.Date               `json:"preferred_move_in_date"`
	AdditionalNotes      pgtype.Text               `json:"additional_notes"`
	Status               NullApplicationStatusEnum `json:"status"`
	DecisionReason       pgtype.Text               `json:"decision_reason"`
	DecidedAt            pgtype.Timestamptz        `json:"decided_at"`
	DecidedBy            pgtype.Int8               `json:"decided_by"`
	CreatedAt            pgtype.Timestamptz        `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz        `json:"updated_at"`
	TenantFirstName      string                    `json:"tenant_first_name"`
	TenantLastName       string                    `json:"tenant_last_name"`
	TenantEmail          string                    `json:"tenant_email"`
	Occupation           pgtype.Text               `json:"occupation"`
	Employer             pgtype.Text               `json:"employer"`
	MonthlyIncome        pgtype.Numeric            `json:"monthly_income"`
}

// Get applications for property
func (q *Queries) GetPropertyRentalApplications(ctx context.Context, arg GetPropertyRentalApplicationsParams) ([]GetPropertyRentalApplicationsRow, error) {
	rows, err := q.db.Query(ctx, getPropertyRentalApplications, arg.PropertyID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPropertyRentalApplicationsRow{}
	for rows.Next() {
		var i GetPropertyRentalApplicationsRow
		if err := rows.Scan(
			&i.ID,
			&i.PropertyID,
			&i.TenantID,
			&i.LandlordID,
			&i.ApplicationDocuments,
			&i.EmploymentDetails,
			&i.References,
			&i.PreferredMoveInDate,
			&i.AdditionalNotes,
			&i.Status,
			&i.DecisionReason,
			&i.DecidedAt,
			&i.DecidedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TenantFirstName,
			&i.TenantLastName,
			&i.TenantEmail,
			&i.Occupation,
			&i.Employer,
			&i.MonthlyIncome,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRentalApplicationByID = `-- name: GetRentalApplicationByID :one
SELECT id, property_id, tenant_id, landlord_id, application_documents, employment_details, "references", preferred_move_in_date, additional_notes, status, decision_reason, decided_at, decided_by, created_at, updated_at FROM rental_applications 
WHERE id = $1 LIMIT 1
`

// Get rental application by ID
func (q *Queries) GetRentalApplicationByID(ctx context.Context, id int64) (RentalApplication, error) {
	row := q.db.QueryRow(ctx, getRentalApplicationByID, id)
	var i RentalApplication
	err := row.Scan(
		&i.ID,
		&i.PropertyID,
		&i.TenantID,
		&i.LandlordID,
		&i.ApplicationDocuments,
		&i.EmploymentDetails,
		&i.References,
		&i.PreferredMoveInDate,
		&i.AdditionalNotes,
		&i.Status,
		&i.DecisionReason,
		&i.DecidedAt,
		&i.DecidedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRentalApplicationWithDetails = `-- name: GetRentalApplicationWithDetails :one
SELECT ra.id, ra.property_id, ra.tenant_id, ra.landlord_id, ra.application_documents, ra.employment_details, ra."references", ra.preferred_move_in_date, ra.additional_notes, ra.status, ra.decision_reason, ra.decided_at, ra.decided_by, ra.created_at, ra.updated_at, p.title as property_title, p.rent_amount, p.address as property_address,
       t.first_name as tenant_first_name, t.last_name as tenant_last_name, t.email as tenant_email, t.phone as tenant_phone,
       l.first_name as landlord_first_name, l.last_name as landlord_last_name, l.email as landlord_email,
       tp.occupation, tp.employer, tp.monthly_income,
       decided_by_user.first_name as decided_by_first_name, decided_by_user.last_name as decided_by_last_name
FROM rental_applications ra
JOIN properties p ON ra.property_id = p.id
JOIN users t ON ra.tenant_id = t.id
JOIN users l ON ra.landlord_id = l.id
LEFT JOIN tenant_profiles tp ON t.id = tp.user_id
LEFT JOIN users decided_by_user ON ra.decided_by = decided_by_user.id
WHERE ra.id = $1 LIMIT 1
`

type GetRentalApplicationWithDetailsRow struct {
	ID                   int64                     `json:"id"`
	PropertyID           int64                     `json:"property_id"`
	TenantID             int64                     `json:"tenant_id"`
	LandlordID           int64                     `json:"landlord_id"`
	ApplicationDocuments pgtype.Text               `json:"application_documents"`
	EmploymentDetails    pgtype.Text               `json:"employment_details"`
	References           pgtype.Text               `json:"references"`
	PreferredMoveInDate  pgtype.Date               `json:"preferred_move_in_date"`
	AdditionalNotes      pgtype.Text               `json:"additional_notes"`
	Status               NullApplicationStatusEnum `json:"status"`
	DecisionReason       pgtype.Text               `json:"decision_reason"`
	DecidedAt            pgtype.Timestamptz        `json:"decided_at"`
	DecidedBy            pgtype.Int8               `json:"decided_by"`
	CreatedAt            pgtype.Timestamptz        `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz        `json:"updated_at"`
	PropertyTitle        string                    `json:"property_title"`
	RentAmount           pgtype.Numeric            `json:"rent_amount"`
	PropertyAddress      string                    `json:"property_address"`
	TenantFirstName      string                    `json:"tenant_first_name"`
	TenantLastName       string                    `json:"tenant_last_name"`
	TenantEmail          string                    `json:"tenant_email"`
	TenantPhone          string                    `json:"tenant_phone"`
	LandlordFirstName    string                    `json:"landlord_first_name"`
	LandlordLastName     string                    `json:"landlord_last_name"`
	LandlordEmail        string                    `json:"landlord_email"`
	Occupation           pgtype.Text               `json:"occupation"`
	Employer             pgtype.Text               `json:"employer"`
	MonthlyIncome        pgtype.Numeric            `json:"monthly_income"`
	DecidedByFirstName   pgtype.Text               `json:"decided_by_first_name"`
	DecidedByLastName    pgtype.Text               `json:"decided_by_last_name"`
}

// Get rental application with details
func (q *Queries) GetRentalApplicationWithDetails(ctx context.Context, id int64) (GetRentalApplicationWithDetailsRow, error) {
	row := q.db.QueryRow(ctx, getRentalApplicationWithDetails, id)
	var i GetRentalApplicationWithDetailsRow
	err := row.Scan(
		&i.ID,
		&i.PropertyID,
		&i.TenantID,
		&i.LandlordID,
		&i.ApplicationDocuments,
		&i.EmploymentDetails,
		&i.References,
		&i.PreferredMoveInDate,
		&i.AdditionalNotes,
		&i.Status,
		&i.DecisionReason,
		&i.DecidedAt,
		&i.DecidedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PropertyTitle,
		&i.RentAmount,
		&i.PropertyAddress,
		&i.TenantFirstName,
		&i.TenantLastName,
		&i.TenantEmail,
		&i.TenantPhone,
		&i.LandlordFirstName,
		&i.LandlordLastName,
		&i.LandlordEmail,
		&i.Occupation,
		&i.Employer,
		&i.MonthlyIncome,
		&i.DecidedByFirstName,
		&i.DecidedByLastName,
	)
	return i, err
}

const getTenantRentalApplications = `-- name: GetTenantRentalApplications :many
SELECT ra.id, ra.property_id, ra.tenant_id, ra.landlord_id, ra.application_documents, ra.employment_details, ra."references", ra.preferred_move_in_date, ra.additional_notes, ra.status, ra.decision_reason, ra.decided_at, ra.decided_by, ra.created_at, ra.updated_at, p.title as property_title, p.rent_amount, p.address as property_address,
       l.first_name as landlord_first_name, l.last_name as landlord_last_name
FROM rental_applications ra
JOIN properties p ON ra.property_id = p.id
JOIN users l ON ra.landlord_id = l.id
WHERE ra.tenant_id = $1
ORDER BY ra.created_at DESC
LIMIT $2 OFFSET $3
`

type GetTenantRentalApplicationsParams struct {
	TenantID int64 `json:"tenant_id"`
	Limit    int32 `json:"limit"`
	Offset   int32 `json:"offset"`
}

type GetTenantRentalApplicationsRow struct {
	ID                   int64                     `json:"id"`
	PropertyID           int64                     `json:"property_id"`
	TenantID             int64                     `json:"tenant_id"`
	LandlordID           int64                     `json:"landlord_id"`
	ApplicationDocuments pgtype.Text               `json:"application_documents"`
	EmploymentDetails    pgtype.Text               `json:"employment_details"`
	References           pgtype.Text               `json:"references"`
	PreferredMoveInDate  pgtype.Date               `json:"preferred_move_in_date"`
	AdditionalNotes      pgtype.Text               `json:"additional_notes"`
	Status               NullApplicationStatusEnum `json:"status"`
	DecisionReason       pgtype.Text               `json:"decision_reason"`
	DecidedAt            pgtype.Timestamptz        `json:"decided_at"`
	DecidedBy            pgtype.Int8               `json:"decided_by"`
	CreatedAt            pgtype.Timestamptz        `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz        `json:"updated_at"`
	PropertyTitle        string                    `json:"property_title"`
	RentAmount           pgtype.Numeric            `json:"rent_amount"`
	PropertyAddress      string                    `json:"property_address"`
	LandlordFirstName    string                    `json:"landlord_first_name"`
	LandlordLastName     string                    `json:"landlord_last_name"`
}

// Get tenant's rental applications
func (q *Queries) GetTenantRentalApplications(ctx context.Context, arg GetTenantRentalApplicationsParams) ([]GetTenantRentalApplicationsRow, error) {
	rows, err := q.db.Query(ctx, getTenantRentalApplications, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTenantRentalApplicationsRow{}
	for rows.Next() {
		var i GetTenantRentalApplicationsRow
		if err := rows.Scan(
			&i.ID,
			&i.PropertyID,
			&i.TenantID,
			&i.LandlordID,
			&i.ApplicationDocuments,
			&i.EmploymentDetails,
			&i.References,
			&i.PreferredMoveInDate,
			&i.AdditionalNotes,
			&i.Status,
			&i.DecisionReason,
			&i.DecidedAt,
			&i.DecidedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PropertyTitle,
			&i.RentAmount,
			&i.PropertyAddress,
			&i.LandlordFirstName,
			&i.LandlordLastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const rejectRentalApplication = `-- name: RejectRentalApplication :one
UPDATE rental_applications 
SET status = 'rejected', decision_reason = $2, decided_at = NOW(), decided_by = $3, updated_at = NOW()
WHERE id = $1 
RETURNING id, property_id, tenant_id, landlord_id, application_documents, employment_details, "references", preferred_move_in_date, additional_notes, status, decision_reason, decided_at, decided_by, created_at, updated_at
`

type RejectRentalApplicationParams struct {
	ID             int64       `json:"id"`
	DecisionReason pgtype.Text `json:"decision_reason"`
	DecidedBy      pgtype.Int8 `json:"decided_by"`
}

// Reject rental application
func (q *Queries) RejectRentalApplication(ctx context.Context, arg RejectRentalApplicationParams) (RentalApplication, error) {
	row := q.db.QueryRow(ctx, rejectRentalApplication, arg.ID, arg.DecisionReason, arg.DecidedBy)
	var i RentalApplication
	err := row.Scan(
		&i.ID,
		&i.PropertyID,
		&i.TenantID,
		&i.LandlordID,
		&i.ApplicationDocuments,
		&i.EmploymentDetails,
		&i.References,
		&i.PreferredMoveInDate,
		&i.AdditionalNotes,
		&i.Status,
		&i.DecisionReason,
		&i.DecidedAt,
		&i.DecidedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateApplicationDocuments = `-- name: UpdateApplicationDocuments :one
UPDATE rental_applications 
SET application_documents = $2, updated_at = NOW()
WHERE id = $1 
RETURNING id, property_id, tenant_id, landlord_id, application_documents, employment_details, "references", preferred_move_in_date, additional_notes, status, decision_reason, decided_at, decided_by, created_at, updated_at
`

type UpdateApplicationDocumentsParams struct {
	ID                   int64       `json:"id"`
	ApplicationDocuments pgtype.Text `json:"application_documents"`
}

// Update application documents
func (q *Queries) UpdateApplicationDocuments(ctx context.Context, arg UpdateApplicationDocumentsParams) (RentalApplication, error) {
	row := q.db.QueryRow(ctx, updateApplicationDocuments, arg.ID, arg.ApplicationDocuments)
	var i RentalApplication
	err := row.Scan(
		&i.ID,
		&i.PropertyID,
		&i.TenantID,
		&i.LandlordID,
		&i.ApplicationDocuments,
		&i.EmploymentDetails,
		&i.References,
		&i.PreferredMoveInDate,
		&i.AdditionalNotes,
		&i.Status,
		&i.DecisionReason,
		&i.DecidedAt,
		&i.DecidedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateApplicationEmploymentDetails = `-- name: UpdateApplicationEmploymentDetails :one
UPDATE rental_applications 
SET employment_details = $2, updated_at = NOW()
WHERE id = $1 
RETURNING id, property_id, tenant_id, landlord_id, application_documents, employment_details, "references", preferred_move_in_date, additional_notes, status, decision_reason, decided_at, decided_by, created_at, updated_at
`

type UpdateApplicationEmploymentDetailsParams struct {
	ID                int64       `json:"id"`
	EmploymentDetails pgtype.Text `json:"employment_details"`
}

// Update employment details
func (q *Queries) UpdateApplicationEmploymentDetails(ctx context.Context, arg UpdateApplicationEmploymentDetailsParams) (RentalApplication, error) {
	row := q.db.QueryRow(ctx, updateApplicationEmploymentDetails, arg.ID, arg.EmploymentDetails)
	var i RentalApplication
	err := row.Scan(
		&i.ID,
		&i.PropertyID,
		&i.TenantID,
		&i.LandlordID,
		&i.ApplicationDocuments,
		&i.EmploymentDetails,
		&i.References,
		&i.PreferredMoveInDate,
		&i.AdditionalNotes,
		&i.Status,
		&i.DecisionReason,
		&i.DecidedAt,
		&i.DecidedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateApplicationReferences = `-- name: UpdateApplicationReferences :one
UPDATE rental_applications 
SET "references" = $2, updated_at = NOW()
WHERE id = $1 
RETURNING id, property_id, tenant_id, landlord_id, application_documents, employment_details, "references", preferred_move_in_date, additional_notes, status, decision_reason, decided_at, decided_by, created_at, updated_at
`

type UpdateApplicationReferencesParams struct {
	ID         int64       `json:"id"`
	References pgtype.Text `json:"references"`
}

// Update application references
func (q *Queries) UpdateApplicationReferences(ctx context.Context, arg UpdateApplicationReferencesParams) (RentalApplication, error) {
	row := q.db.QueryRow(ctx, updateApplicationReferences, arg.ID, arg.References)
	var i RentalApplication
	err := row.Scan(
		&i.ID,
		&i.PropertyID,
		&i.TenantID,
		&i.LandlordID,
		&i.ApplicationDocuments,
		&i.EmploymentDetails,
		&i.References,
		&i.PreferredMoveInDate,
		&i.AdditionalNotes,
		&i.Status,
		&i.DecisionReason,
		&i.DecidedAt,
		&i.DecidedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateRentalApplicationStatus = `-- name: UpdateRentalApplicationStatus :one
UPDATE rental_applications 
SET status = $2, decision_reason = $3, decided_at = NOW(), decided_by = $4, updated_at = NOW()
WHERE id = $1 
RETURNING id, property_id, tenant_id, landlord_id, application_documents, employment_details, "references", preferred_move_in_date, additional_notes, status, decision_reason, decided_at, decided_by, created_at, updated_at
`

type UpdateRentalApplicationStatusParams struct {
	ID             int64                     `json:"id"`
	Status         NullApplicationStatusEnum `json:"status"`
	DecisionReason pgtype.Text               `json:"decision_reason"`
	DecidedBy      pgtype.Int8               `json:"decided_by"`
}

// Update rental application status
func (q *Queries) UpdateRentalApplicationStatus(ctx context.Context, arg UpdateRentalApplicationStatusParams) (RentalApplication, error) {
	row := q.db.QueryRow(ctx, updateRentalApplicationStatus,
		arg.ID,
		arg.Status,
		arg.DecisionReason,
		arg.DecidedBy,
	)
	var i RentalApplication
	err := row.Scan(
		&i.ID,
		&i.PropertyID,
		&i.TenantID,
		&i.LandlordID,
		&i.ApplicationDocuments,
		&i.EmploymentDetails,
		&i.References,
		&i.PreferredMoveInDate,
		&i.AdditionalNotes,
		&i.Status,
		&i.DecisionReason,
		&i.DecidedAt,
		&i.DecidedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const withdrawRentalApplication = `-- name: WithdrawRentalApplication :one
UPDATE rental_applications 
SET status = 'withdrawn', updated_at = NOW()
WHERE id = $1 
RETURNING id, property_id, tenant_id, landlord_id, application_documents, employment_details, "references", preferred_move_in_date, additional_notes, status, decision_reason, decided_at, decided_by, created_at, updated_at
`

// Withdraw rental application
func (q *Queries) WithdrawRentalApplication(ctx context.Context, id int64) (RentalApplication, error) {
	row := q.db.QueryRow(ctx, withdrawRentalApplication, id)
	var i RentalApplication
	err := row.Scan(
		&i.ID,
		&i.PropertyID,
		&i.TenantID,
		&i.LandlordID,
		&i.ApplicationDocuments,
		&i.EmploymentDetails,
		&i.References,
		&i.PreferredMoveInDate,
		&i.AdditionalNotes,
		&i.Status,
		&i.DecisionReason,
		&i.DecidedAt,
		&i.DecidedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
