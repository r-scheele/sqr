// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: user_rating.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addResponseToRating = `-- name: AddResponseToRating :one
UPDATE user_ratings 
SET response_text = $2, updated_at = NOW()
WHERE id = $1 
RETURNING id, rater_id, rated_user_id, rating_type, related_entity_type, related_entity_id, rating, review_text, response_text, is_verified, created_at, updated_at
`

type AddResponseToRatingParams struct {
	ID           int64       `json:"id"`
	ResponseText pgtype.Text `json:"response_text"`
}

// Add response to rating
func (q *Queries) AddResponseToRating(ctx context.Context, arg AddResponseToRatingParams) (UserRating, error) {
	row := q.db.QueryRow(ctx, addResponseToRating, arg.ID, arg.ResponseText)
	var i UserRating
	err := row.Scan(
		&i.ID,
		&i.RaterID,
		&i.RatedUserID,
		&i.RatingType,
		&i.RelatedEntityType,
		&i.RelatedEntityID,
		&i.Rating,
		&i.ReviewText,
		&i.ResponseText,
		&i.IsVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const checkRatingExists = `-- name: CheckRatingExists :one
SELECT EXISTS(
  SELECT 1 FROM user_ratings 
  WHERE rater_id = $1 AND rated_user_id = $2 
    AND related_entity_type = $3 AND related_entity_id = $4
)
`

type CheckRatingExistsParams struct {
	RaterID           int64                 `json:"rater_id"`
	RatedUserID       int64                 `json:"rated_user_id"`
	RelatedEntityType NullRelatedEntityEnum `json:"related_entity_type"`
	RelatedEntityID   pgtype.Int8           `json:"related_entity_id"`
}

// Check if rating exists
func (q *Queries) CheckRatingExists(ctx context.Context, arg CheckRatingExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkRatingExists,
		arg.RaterID,
		arg.RatedUserID,
		arg.RelatedEntityType,
		arg.RelatedEntityID,
	)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const countRatingsForUser = `-- name: CountRatingsForUser :one
SELECT COUNT(*) FROM user_ratings 
WHERE rated_user_id = $1
`

// Count ratings for user
func (q *Queries) CountRatingsForUser(ctx context.Context, ratedUserID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countRatingsForUser, ratedUserID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countVerifiedRatingsForUser = `-- name: CountVerifiedRatingsForUser :one
SELECT COUNT(*) FROM user_ratings 
WHERE rated_user_id = $1 AND is_verified = true
`

// Count verified ratings for user
func (q *Queries) CountVerifiedRatingsForUser(ctx context.Context, ratedUserID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countVerifiedRatingsForUser, ratedUserID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createUserRating = `-- name: CreateUserRating :one
INSERT INTO user_ratings (
  rater_id, rated_user_id, rating_type, related_entity_type, related_entity_id,
  rating, review_text
) VALUES (
  $1, $2, $3, $4, $5, $6, $7
) RETURNING id, rater_id, rated_user_id, rating_type, related_entity_type, related_entity_id, rating, review_text, response_text, is_verified, created_at, updated_at
`

type CreateUserRatingParams struct {
	RaterID           int64                 `json:"rater_id"`
	RatedUserID       int64                 `json:"rated_user_id"`
	RatingType        NullRatingTypeEnum    `json:"rating_type"`
	RelatedEntityType NullRelatedEntityEnum `json:"related_entity_type"`
	RelatedEntityID   pgtype.Int8           `json:"related_entity_id"`
	Rating            int32                 `json:"rating"`
	ReviewText        pgtype.Text           `json:"review_text"`
}

// Create user rating
func (q *Queries) CreateUserRating(ctx context.Context, arg CreateUserRatingParams) (UserRating, error) {
	row := q.db.QueryRow(ctx, createUserRating,
		arg.RaterID,
		arg.RatedUserID,
		arg.RatingType,
		arg.RelatedEntityType,
		arg.RelatedEntityID,
		arg.Rating,
		arg.ReviewText,
	)
	var i UserRating
	err := row.Scan(
		&i.ID,
		&i.RaterID,
		&i.RatedUserID,
		&i.RatingType,
		&i.RelatedEntityType,
		&i.RelatedEntityID,
		&i.Rating,
		&i.ReviewText,
		&i.ResponseText,
		&i.IsVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteUserRating = `-- name: DeleteUserRating :exec
DELETE FROM user_ratings 
WHERE id = $1
`

// Delete user rating
func (q *Queries) DeleteUserRating(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteUserRating, id)
	return err
}

const getAgentRatings = `-- name: GetAgentRatings :many
SELECT ur.id, ur.rater_id, ur.rated_user_id, ur.rating_type, ur.related_entity_type, ur.related_entity_id, ur.rating, ur.review_text, ur.response_text, ur.is_verified, ur.created_at, ur.updated_at, 
       rater.first_name as rater_first_name, rater.last_name as rater_last_name
FROM user_ratings ur
JOIN users rater ON ur.rater_id = rater.id
JOIN users rated ON ur.rated_user_id = rated.id
WHERE rated.user_type = 'inspection_agent' AND ur.rating_type = 'tenant_to_agent'
ORDER BY ur.created_at DESC
LIMIT $1 OFFSET $2
`

type GetAgentRatingsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetAgentRatingsRow struct {
	ID                int64                 `json:"id"`
	RaterID           int64                 `json:"rater_id"`
	RatedUserID       int64                 `json:"rated_user_id"`
	RatingType        NullRatingTypeEnum    `json:"rating_type"`
	RelatedEntityType NullRelatedEntityEnum `json:"related_entity_type"`
	RelatedEntityID   pgtype.Int8           `json:"related_entity_id"`
	Rating            int32                 `json:"rating"`
	ReviewText        pgtype.Text           `json:"review_text"`
	ResponseText      pgtype.Text           `json:"response_text"`
	IsVerified        pgtype.Bool           `json:"is_verified"`
	CreatedAt         pgtype.Timestamptz    `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz    `json:"updated_at"`
	RaterFirstName    string                `json:"rater_first_name"`
	RaterLastName     string                `json:"rater_last_name"`
}

// Get agent ratings
func (q *Queries) GetAgentRatings(ctx context.Context, arg GetAgentRatingsParams) ([]GetAgentRatingsRow, error) {
	rows, err := q.db.Query(ctx, getAgentRatings, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAgentRatingsRow{}
	for rows.Next() {
		var i GetAgentRatingsRow
		if err := rows.Scan(
			&i.ID,
			&i.RaterID,
			&i.RatedUserID,
			&i.RatingType,
			&i.RelatedEntityType,
			&i.RelatedEntityID,
			&i.Rating,
			&i.ReviewText,
			&i.ResponseText,
			&i.IsVerified,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RaterFirstName,
			&i.RaterLastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLandlordRatings = `-- name: GetLandlordRatings :many
SELECT ur.id, ur.rater_id, ur.rated_user_id, ur.rating_type, ur.related_entity_type, ur.related_entity_id, ur.rating, ur.review_text, ur.response_text, ur.is_verified, ur.created_at, ur.updated_at, 
       rater.first_name as rater_first_name, rater.last_name as rater_last_name
FROM user_ratings ur
JOIN users rater ON ur.rater_id = rater.id
JOIN users rated ON ur.rated_user_id = rated.id
WHERE rated.user_type = 'landlord' AND ur.rating_type = 'tenant_to_landlord'
ORDER BY ur.created_at DESC
LIMIT $1 OFFSET $2
`

type GetLandlordRatingsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetLandlordRatingsRow struct {
	ID                int64                 `json:"id"`
	RaterID           int64                 `json:"rater_id"`
	RatedUserID       int64                 `json:"rated_user_id"`
	RatingType        NullRatingTypeEnum    `json:"rating_type"`
	RelatedEntityType NullRelatedEntityEnum `json:"related_entity_type"`
	RelatedEntityID   pgtype.Int8           `json:"related_entity_id"`
	Rating            int32                 `json:"rating"`
	ReviewText        pgtype.Text           `json:"review_text"`
	ResponseText      pgtype.Text           `json:"response_text"`
	IsVerified        pgtype.Bool           `json:"is_verified"`
	CreatedAt         pgtype.Timestamptz    `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz    `json:"updated_at"`
	RaterFirstName    string                `json:"rater_first_name"`
	RaterLastName     string                `json:"rater_last_name"`
}

// Get landlord ratings
func (q *Queries) GetLandlordRatings(ctx context.Context, arg GetLandlordRatingsParams) ([]GetLandlordRatingsRow, error) {
	rows, err := q.db.Query(ctx, getLandlordRatings, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetLandlordRatingsRow{}
	for rows.Next() {
		var i GetLandlordRatingsRow
		if err := rows.Scan(
			&i.ID,
			&i.RaterID,
			&i.RatedUserID,
			&i.RatingType,
			&i.RelatedEntityType,
			&i.RelatedEntityID,
			&i.Rating,
			&i.ReviewText,
			&i.ResponseText,
			&i.IsVerified,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RaterFirstName,
			&i.RaterLastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRatingForEntity = `-- name: GetRatingForEntity :one
SELECT ur.id, ur.rater_id, ur.rated_user_id, ur.rating_type, ur.related_entity_type, ur.related_entity_id, ur.rating, ur.review_text, ur.response_text, ur.is_verified, ur.created_at, ur.updated_at, 
       rater.first_name as rater_first_name, rater.last_name as rater_last_name,
       rated.first_name as rated_first_name, rated.last_name as rated_last_name
FROM user_ratings ur
JOIN users rater ON ur.rater_id = rater.id
JOIN users rated ON ur.rated_user_id = rated.id
WHERE ur.rater_id = $1 AND ur.rated_user_id = $2 
  AND ur.related_entity_type = $3 AND ur.related_entity_id = $4
LIMIT 1
`

type GetRatingForEntityParams struct {
	RaterID           int64                 `json:"rater_id"`
	RatedUserID       int64                 `json:"rated_user_id"`
	RelatedEntityType NullRelatedEntityEnum `json:"related_entity_type"`
	RelatedEntityID   pgtype.Int8           `json:"related_entity_id"`
}

type GetRatingForEntityRow struct {
	ID                int64                 `json:"id"`
	RaterID           int64                 `json:"rater_id"`
	RatedUserID       int64                 `json:"rated_user_id"`
	RatingType        NullRatingTypeEnum    `json:"rating_type"`
	RelatedEntityType NullRelatedEntityEnum `json:"related_entity_type"`
	RelatedEntityID   pgtype.Int8           `json:"related_entity_id"`
	Rating            int32                 `json:"rating"`
	ReviewText        pgtype.Text           `json:"review_text"`
	ResponseText      pgtype.Text           `json:"response_text"`
	IsVerified        pgtype.Bool           `json:"is_verified"`
	CreatedAt         pgtype.Timestamptz    `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz    `json:"updated_at"`
	RaterFirstName    string                `json:"rater_first_name"`
	RaterLastName     string                `json:"rater_last_name"`
	RatedFirstName    string                `json:"rated_first_name"`
	RatedLastName     string                `json:"rated_last_name"`
}

// Get rating for entity
func (q *Queries) GetRatingForEntity(ctx context.Context, arg GetRatingForEntityParams) (GetRatingForEntityRow, error) {
	row := q.db.QueryRow(ctx, getRatingForEntity,
		arg.RaterID,
		arg.RatedUserID,
		arg.RelatedEntityType,
		arg.RelatedEntityID,
	)
	var i GetRatingForEntityRow
	err := row.Scan(
		&i.ID,
		&i.RaterID,
		&i.RatedUserID,
		&i.RatingType,
		&i.RelatedEntityType,
		&i.RelatedEntityID,
		&i.Rating,
		&i.ReviewText,
		&i.ResponseText,
		&i.IsVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RaterFirstName,
		&i.RaterLastName,
		&i.RatedFirstName,
		&i.RatedLastName,
	)
	return i, err
}

const getRatingsByTypeForUser = `-- name: GetRatingsByTypeForUser :many
SELECT ur.id, ur.rater_id, ur.rated_user_id, ur.rating_type, ur.related_entity_type, ur.related_entity_id, ur.rating, ur.review_text, ur.response_text, ur.is_verified, ur.created_at, ur.updated_at, 
       rater.first_name as rater_first_name, rater.last_name as rater_last_name
FROM user_ratings ur
JOIN users rater ON ur.rater_id = rater.id
WHERE ur.rated_user_id = $1 AND ur.rating_type = $2
ORDER BY ur.created_at DESC
LIMIT $3 OFFSET $4
`

type GetRatingsByTypeForUserParams struct {
	RatedUserID int64              `json:"rated_user_id"`
	RatingType  NullRatingTypeEnum `json:"rating_type"`
	Limit       int32              `json:"limit"`
	Offset      int32              `json:"offset"`
}

type GetRatingsByTypeForUserRow struct {
	ID                int64                 `json:"id"`
	RaterID           int64                 `json:"rater_id"`
	RatedUserID       int64                 `json:"rated_user_id"`
	RatingType        NullRatingTypeEnum    `json:"rating_type"`
	RelatedEntityType NullRelatedEntityEnum `json:"related_entity_type"`
	RelatedEntityID   pgtype.Int8           `json:"related_entity_id"`
	Rating            int32                 `json:"rating"`
	ReviewText        pgtype.Text           `json:"review_text"`
	ResponseText      pgtype.Text           `json:"response_text"`
	IsVerified        pgtype.Bool           `json:"is_verified"`
	CreatedAt         pgtype.Timestamptz    `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz    `json:"updated_at"`
	RaterFirstName    string                `json:"rater_first_name"`
	RaterLastName     string                `json:"rater_last_name"`
}

// Get ratings by type for user
func (q *Queries) GetRatingsByTypeForUser(ctx context.Context, arg GetRatingsByTypeForUserParams) ([]GetRatingsByTypeForUserRow, error) {
	rows, err := q.db.Query(ctx, getRatingsByTypeForUser,
		arg.RatedUserID,
		arg.RatingType,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRatingsByTypeForUserRow{}
	for rows.Next() {
		var i GetRatingsByTypeForUserRow
		if err := rows.Scan(
			&i.ID,
			&i.RaterID,
			&i.RatedUserID,
			&i.RatingType,
			&i.RelatedEntityType,
			&i.RelatedEntityID,
			&i.Rating,
			&i.ReviewText,
			&i.ResponseText,
			&i.IsVerified,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RaterFirstName,
			&i.RaterLastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRatingsByUser = `-- name: GetRatingsByUser :many
SELECT ur.id, ur.rater_id, ur.rated_user_id, ur.rating_type, ur.related_entity_type, ur.related_entity_id, ur.rating, ur.review_text, ur.response_text, ur.is_verified, ur.created_at, ur.updated_at, 
       rated.first_name as rated_first_name, rated.last_name as rated_last_name,
       rated.profile_picture_url as rated_profile_picture
FROM user_ratings ur
JOIN users rated ON ur.rated_user_id = rated.id
WHERE ur.rater_id = $1
ORDER BY ur.created_at DESC
LIMIT $2 OFFSET $3
`

type GetRatingsByUserParams struct {
	RaterID int64 `json:"rater_id"`
	Limit   int32 `json:"limit"`
	Offset  int32 `json:"offset"`
}

type GetRatingsByUserRow struct {
	ID                  int64                 `json:"id"`
	RaterID             int64                 `json:"rater_id"`
	RatedUserID         int64                 `json:"rated_user_id"`
	RatingType          NullRatingTypeEnum    `json:"rating_type"`
	RelatedEntityType   NullRelatedEntityEnum `json:"related_entity_type"`
	RelatedEntityID     pgtype.Int8           `json:"related_entity_id"`
	Rating              int32                 `json:"rating"`
	ReviewText          pgtype.Text           `json:"review_text"`
	ResponseText        pgtype.Text           `json:"response_text"`
	IsVerified          pgtype.Bool           `json:"is_verified"`
	CreatedAt           pgtype.Timestamptz    `json:"created_at"`
	UpdatedAt           pgtype.Timestamptz    `json:"updated_at"`
	RatedFirstName      string                `json:"rated_first_name"`
	RatedLastName       string                `json:"rated_last_name"`
	RatedProfilePicture pgtype.Text           `json:"rated_profile_picture"`
}

// Get ratings by user
func (q *Queries) GetRatingsByUser(ctx context.Context, arg GetRatingsByUserParams) ([]GetRatingsByUserRow, error) {
	rows, err := q.db.Query(ctx, getRatingsByUser, arg.RaterID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRatingsByUserRow{}
	for rows.Next() {
		var i GetRatingsByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.RaterID,
			&i.RatedUserID,
			&i.RatingType,
			&i.RelatedEntityType,
			&i.RelatedEntityID,
			&i.Rating,
			&i.ReviewText,
			&i.ResponseText,
			&i.IsVerified,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RatedFirstName,
			&i.RatedLastName,
			&i.RatedProfilePicture,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRatingsForUser = `-- name: GetRatingsForUser :many
SELECT ur.id, ur.rater_id, ur.rated_user_id, ur.rating_type, ur.related_entity_type, ur.related_entity_id, ur.rating, ur.review_text, ur.response_text, ur.is_verified, ur.created_at, ur.updated_at, 
       rater.first_name as rater_first_name, rater.last_name as rater_last_name,
       rater.profile_picture_url as rater_profile_picture
FROM user_ratings ur
JOIN users rater ON ur.rater_id = rater.id
WHERE ur.rated_user_id = $1
ORDER BY ur.created_at DESC
LIMIT $2 OFFSET $3
`

type GetRatingsForUserParams struct {
	RatedUserID int64 `json:"rated_user_id"`
	Limit       int32 `json:"limit"`
	Offset      int32 `json:"offset"`
}

type GetRatingsForUserRow struct {
	ID                  int64                 `json:"id"`
	RaterID             int64                 `json:"rater_id"`
	RatedUserID         int64                 `json:"rated_user_id"`
	RatingType          NullRatingTypeEnum    `json:"rating_type"`
	RelatedEntityType   NullRelatedEntityEnum `json:"related_entity_type"`
	RelatedEntityID     pgtype.Int8           `json:"related_entity_id"`
	Rating              int32                 `json:"rating"`
	ReviewText          pgtype.Text           `json:"review_text"`
	ResponseText        pgtype.Text           `json:"response_text"`
	IsVerified          pgtype.Bool           `json:"is_verified"`
	CreatedAt           pgtype.Timestamptz    `json:"created_at"`
	UpdatedAt           pgtype.Timestamptz    `json:"updated_at"`
	RaterFirstName      string                `json:"rater_first_name"`
	RaterLastName       string                `json:"rater_last_name"`
	RaterProfilePicture pgtype.Text           `json:"rater_profile_picture"`
}

// Get ratings for user
func (q *Queries) GetRatingsForUser(ctx context.Context, arg GetRatingsForUserParams) ([]GetRatingsForUserRow, error) {
	rows, err := q.db.Query(ctx, getRatingsForUser, arg.RatedUserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRatingsForUserRow{}
	for rows.Next() {
		var i GetRatingsForUserRow
		if err := rows.Scan(
			&i.ID,
			&i.RaterID,
			&i.RatedUserID,
			&i.RatingType,
			&i.RelatedEntityType,
			&i.RelatedEntityID,
			&i.Rating,
			&i.ReviewText,
			&i.ResponseText,
			&i.IsVerified,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RaterFirstName,
			&i.RaterLastName,
			&i.RaterProfilePicture,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentRatings = `-- name: GetRecentRatings :many
SELECT ur.id, ur.rater_id, ur.rated_user_id, ur.rating_type, ur.related_entity_type, ur.related_entity_id, ur.rating, ur.review_text, ur.response_text, ur.is_verified, ur.created_at, ur.updated_at, 
       rater.first_name as rater_first_name, rater.last_name as rater_last_name,
       rated.first_name as rated_first_name, rated.last_name as rated_last_name
FROM user_ratings ur
JOIN users rater ON ur.rater_id = rater.id
JOIN users rated ON ur.rated_user_id = rated.id
ORDER BY ur.created_at DESC
LIMIT $1 OFFSET $2
`

type GetRecentRatingsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetRecentRatingsRow struct {
	ID                int64                 `json:"id"`
	RaterID           int64                 `json:"rater_id"`
	RatedUserID       int64                 `json:"rated_user_id"`
	RatingType        NullRatingTypeEnum    `json:"rating_type"`
	RelatedEntityType NullRelatedEntityEnum `json:"related_entity_type"`
	RelatedEntityID   pgtype.Int8           `json:"related_entity_id"`
	Rating            int32                 `json:"rating"`
	ReviewText        pgtype.Text           `json:"review_text"`
	ResponseText      pgtype.Text           `json:"response_text"`
	IsVerified        pgtype.Bool           `json:"is_verified"`
	CreatedAt         pgtype.Timestamptz    `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz    `json:"updated_at"`
	RaterFirstName    string                `json:"rater_first_name"`
	RaterLastName     string                `json:"rater_last_name"`
	RatedFirstName    string                `json:"rated_first_name"`
	RatedLastName     string                `json:"rated_last_name"`
}

// Get recent ratings
func (q *Queries) GetRecentRatings(ctx context.Context, arg GetRecentRatingsParams) ([]GetRecentRatingsRow, error) {
	rows, err := q.db.Query(ctx, getRecentRatings, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecentRatingsRow{}
	for rows.Next() {
		var i GetRecentRatingsRow
		if err := rows.Scan(
			&i.ID,
			&i.RaterID,
			&i.RatedUserID,
			&i.RatingType,
			&i.RelatedEntityType,
			&i.RelatedEntityID,
			&i.Rating,
			&i.ReviewText,
			&i.ResponseText,
			&i.IsVerified,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RaterFirstName,
			&i.RaterLastName,
			&i.RatedFirstName,
			&i.RatedLastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTenantRatings = `-- name: GetTenantRatings :many
SELECT ur.id, ur.rater_id, ur.rated_user_id, ur.rating_type, ur.related_entity_type, ur.related_entity_id, ur.rating, ur.review_text, ur.response_text, ur.is_verified, ur.created_at, ur.updated_at, 
       rater.first_name as rater_first_name, rater.last_name as rater_last_name
FROM user_ratings ur
JOIN users rater ON ur.rater_id = rater.id
JOIN users rated ON ur.rated_user_id = rated.id
WHERE rated.user_type = 'tenant' AND ur.rating_type = 'landlord_to_tenant'
ORDER BY ur.created_at DESC
LIMIT $1 OFFSET $2
`

type GetTenantRatingsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetTenantRatingsRow struct {
	ID                int64                 `json:"id"`
	RaterID           int64                 `json:"rater_id"`
	RatedUserID       int64                 `json:"rated_user_id"`
	RatingType        NullRatingTypeEnum    `json:"rating_type"`
	RelatedEntityType NullRelatedEntityEnum `json:"related_entity_type"`
	RelatedEntityID   pgtype.Int8           `json:"related_entity_id"`
	Rating            int32                 `json:"rating"`
	ReviewText        pgtype.Text           `json:"review_text"`
	ResponseText      pgtype.Text           `json:"response_text"`
	IsVerified        pgtype.Bool           `json:"is_verified"`
	CreatedAt         pgtype.Timestamptz    `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz    `json:"updated_at"`
	RaterFirstName    string                `json:"rater_first_name"`
	RaterLastName     string                `json:"rater_last_name"`
}

// Get tenant ratings
func (q *Queries) GetTenantRatings(ctx context.Context, arg GetTenantRatingsParams) ([]GetTenantRatingsRow, error) {
	rows, err := q.db.Query(ctx, getTenantRatings, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTenantRatingsRow{}
	for rows.Next() {
		var i GetTenantRatingsRow
		if err := rows.Scan(
			&i.ID,
			&i.RaterID,
			&i.RatedUserID,
			&i.RatingType,
			&i.RelatedEntityType,
			&i.RelatedEntityID,
			&i.Rating,
			&i.ReviewText,
			&i.ResponseText,
			&i.IsVerified,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RaterFirstName,
			&i.RaterLastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserRatingByID = `-- name: GetUserRatingByID :one
SELECT id, rater_id, rated_user_id, rating_type, related_entity_type, related_entity_id, rating, review_text, response_text, is_verified, created_at, updated_at FROM user_ratings 
WHERE id = $1 LIMIT 1
`

// Get user rating by ID
func (q *Queries) GetUserRatingByID(ctx context.Context, id int64) (UserRating, error) {
	row := q.db.QueryRow(ctx, getUserRatingByID, id)
	var i UserRating
	err := row.Scan(
		&i.ID,
		&i.RaterID,
		&i.RatedUserID,
		&i.RatingType,
		&i.RelatedEntityType,
		&i.RelatedEntityID,
		&i.Rating,
		&i.ReviewText,
		&i.ResponseText,
		&i.IsVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserRatingStatistics = `-- name: GetUserRatingStatistics :one
SELECT 
  COUNT(*) as total_ratings,
  AVG(rating) as average_rating,
  COUNT(CASE WHEN rating = 5 THEN 1 END) as five_star_count,
  COUNT(CASE WHEN rating = 4 THEN 1 END) as four_star_count,
  COUNT(CASE WHEN rating = 3 THEN 1 END) as three_star_count,
  COUNT(CASE WHEN rating = 2 THEN 1 END) as two_star_count,
  COUNT(CASE WHEN rating = 1 THEN 1 END) as one_star_count
FROM user_ratings 
WHERE rated_user_id = $1 AND is_verified = true
`

type GetUserRatingStatisticsRow struct {
	TotalRatings   int64   `json:"total_ratings"`
	AverageRating  float64 `json:"average_rating"`
	FiveStarCount  int64   `json:"five_star_count"`
	FourStarCount  int64   `json:"four_star_count"`
	ThreeStarCount int64   `json:"three_star_count"`
	TwoStarCount   int64   `json:"two_star_count"`
	OneStarCount   int64   `json:"one_star_count"`
}

// Get user rating statistics
func (q *Queries) GetUserRatingStatistics(ctx context.Context, ratedUserID int64) (GetUserRatingStatisticsRow, error) {
	row := q.db.QueryRow(ctx, getUserRatingStatistics, ratedUserID)
	var i GetUserRatingStatisticsRow
	err := row.Scan(
		&i.TotalRatings,
		&i.AverageRating,
		&i.FiveStarCount,
		&i.FourStarCount,
		&i.ThreeStarCount,
		&i.TwoStarCount,
		&i.OneStarCount,
	)
	return i, err
}

const getUserRatingWithDetails = `-- name: GetUserRatingWithDetails :one
SELECT ur.id, ur.rater_id, ur.rated_user_id, ur.rating_type, ur.related_entity_type, ur.related_entity_id, ur.rating, ur.review_text, ur.response_text, ur.is_verified, ur.created_at, ur.updated_at, 
       rater.first_name as rater_first_name, rater.last_name as rater_last_name,
       rated.first_name as rated_first_name, rated.last_name as rated_last_name
FROM user_ratings ur
JOIN users rater ON ur.rater_id = rater.id
JOIN users rated ON ur.rated_user_id = rated.id
WHERE ur.id = $1 LIMIT 1
`

type GetUserRatingWithDetailsRow struct {
	ID                int64                 `json:"id"`
	RaterID           int64                 `json:"rater_id"`
	RatedUserID       int64                 `json:"rated_user_id"`
	RatingType        NullRatingTypeEnum    `json:"rating_type"`
	RelatedEntityType NullRelatedEntityEnum `json:"related_entity_type"`
	RelatedEntityID   pgtype.Int8           `json:"related_entity_id"`
	Rating            int32                 `json:"rating"`
	ReviewText        pgtype.Text           `json:"review_text"`
	ResponseText      pgtype.Text           `json:"response_text"`
	IsVerified        pgtype.Bool           `json:"is_verified"`
	CreatedAt         pgtype.Timestamptz    `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz    `json:"updated_at"`
	RaterFirstName    string                `json:"rater_first_name"`
	RaterLastName     string                `json:"rater_last_name"`
	RatedFirstName    string                `json:"rated_first_name"`
	RatedLastName     string                `json:"rated_last_name"`
}

// Get rating with details
func (q *Queries) GetUserRatingWithDetails(ctx context.Context, id int64) (GetUserRatingWithDetailsRow, error) {
	row := q.db.QueryRow(ctx, getUserRatingWithDetails, id)
	var i GetUserRatingWithDetailsRow
	err := row.Scan(
		&i.ID,
		&i.RaterID,
		&i.RatedUserID,
		&i.RatingType,
		&i.RelatedEntityType,
		&i.RelatedEntityID,
		&i.Rating,
		&i.ReviewText,
		&i.ResponseText,
		&i.IsVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RaterFirstName,
		&i.RaterLastName,
		&i.RatedFirstName,
		&i.RatedLastName,
	)
	return i, err
}

const getVerifiedRatingsForUser = `-- name: GetVerifiedRatingsForUser :many
SELECT ur.id, ur.rater_id, ur.rated_user_id, ur.rating_type, ur.related_entity_type, ur.related_entity_id, ur.rating, ur.review_text, ur.response_text, ur.is_verified, ur.created_at, ur.updated_at, 
       rater.first_name as rater_first_name, rater.last_name as rater_last_name
FROM user_ratings ur
JOIN users rater ON ur.rater_id = rater.id
WHERE ur.rated_user_id = $1 AND ur.is_verified = true
ORDER BY ur.created_at DESC
LIMIT $2 OFFSET $3
`

type GetVerifiedRatingsForUserParams struct {
	RatedUserID int64 `json:"rated_user_id"`
	Limit       int32 `json:"limit"`
	Offset      int32 `json:"offset"`
}

type GetVerifiedRatingsForUserRow struct {
	ID                int64                 `json:"id"`
	RaterID           int64                 `json:"rater_id"`
	RatedUserID       int64                 `json:"rated_user_id"`
	RatingType        NullRatingTypeEnum    `json:"rating_type"`
	RelatedEntityType NullRelatedEntityEnum `json:"related_entity_type"`
	RelatedEntityID   pgtype.Int8           `json:"related_entity_id"`
	Rating            int32                 `json:"rating"`
	ReviewText        pgtype.Text           `json:"review_text"`
	ResponseText      pgtype.Text           `json:"response_text"`
	IsVerified        pgtype.Bool           `json:"is_verified"`
	CreatedAt         pgtype.Timestamptz    `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz    `json:"updated_at"`
	RaterFirstName    string                `json:"rater_first_name"`
	RaterLastName     string                `json:"rater_last_name"`
}

// Get verified ratings for user
func (q *Queries) GetVerifiedRatingsForUser(ctx context.Context, arg GetVerifiedRatingsForUserParams) ([]GetVerifiedRatingsForUserRow, error) {
	rows, err := q.db.Query(ctx, getVerifiedRatingsForUser, arg.RatedUserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetVerifiedRatingsForUserRow{}
	for rows.Next() {
		var i GetVerifiedRatingsForUserRow
		if err := rows.Scan(
			&i.ID,
			&i.RaterID,
			&i.RatedUserID,
			&i.RatingType,
			&i.RelatedEntityType,
			&i.RelatedEntityID,
			&i.Rating,
			&i.ReviewText,
			&i.ResponseText,
			&i.IsVerified,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RaterFirstName,
			&i.RaterLastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUserRating = `-- name: UpdateUserRating :one
UPDATE user_ratings 
SET rating = $2, review_text = $3, updated_at = NOW()
WHERE id = $1 
RETURNING id, rater_id, rated_user_id, rating_type, related_entity_type, related_entity_id, rating, review_text, response_text, is_verified, created_at, updated_at
`

type UpdateUserRatingParams struct {
	ID         int64       `json:"id"`
	Rating     int32       `json:"rating"`
	ReviewText pgtype.Text `json:"review_text"`
}

// Update user rating
func (q *Queries) UpdateUserRating(ctx context.Context, arg UpdateUserRatingParams) (UserRating, error) {
	row := q.db.QueryRow(ctx, updateUserRating, arg.ID, arg.Rating, arg.ReviewText)
	var i UserRating
	err := row.Scan(
		&i.ID,
		&i.RaterID,
		&i.RatedUserID,
		&i.RatingType,
		&i.RelatedEntityType,
		&i.RelatedEntityID,
		&i.Rating,
		&i.ReviewText,
		&i.ResponseText,
		&i.IsVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const verifyRating = `-- name: VerifyRating :exec
UPDATE user_ratings 
SET is_verified = true, updated_at = NOW()
WHERE id = $1
`

// Verify rating
func (q *Queries) VerifyRating(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, verifyRating, id)
	return err
}
