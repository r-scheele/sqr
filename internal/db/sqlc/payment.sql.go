// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: payment.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const cancelPayment = `-- name: CancelPayment :one
UPDATE payments 
SET status = 'cancelled', updated_at = NOW()
WHERE id = $1 
RETURNING id, payer_id, payee_id, payment_type, related_entity_type, related_entity_id, amount, currency, payment_method, payment_reference, gateway_reference, status, gateway_response, processed_at, refunded_at, refund_reason, created_at, updated_at
`

// Cancel payment
func (q *Queries) CancelPayment(ctx context.Context, id int64) (Payment, error) {
	row := q.db.QueryRow(ctx, cancelPayment, id)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.PayerID,
		&i.PayeeID,
		&i.PaymentType,
		&i.RelatedEntityType,
		&i.RelatedEntityID,
		&i.Amount,
		&i.Currency,
		&i.PaymentMethod,
		&i.PaymentReference,
		&i.GatewayReference,
		&i.Status,
		&i.GatewayResponse,
		&i.ProcessedAt,
		&i.RefundedAt,
		&i.RefundReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const countPaymentsByStatus = `-- name: CountPaymentsByStatus :one
SELECT COUNT(*) FROM payments 
WHERE status = $1
`

// Count payments by status
func (q *Queries) CountPaymentsByStatus(ctx context.Context, status NullPaymentStatusFullEnum) (int64, error) {
	row := q.db.QueryRow(ctx, countPaymentsByStatus, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUserEarnings = `-- name: CountUserEarnings :one
SELECT COUNT(*) FROM payments 
WHERE payee_id = $1 AND status = 'completed'
`

// Count user earnings
func (q *Queries) CountUserEarnings(ctx context.Context, payeeID pgtype.Int8) (int64, error) {
	row := q.db.QueryRow(ctx, countUserEarnings, payeeID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUserPayments = `-- name: CountUserPayments :one
SELECT COUNT(*) FROM payments 
WHERE payer_id = $1
`

// Count user payments
func (q *Queries) CountUserPayments(ctx context.Context, payerID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countUserPayments, payerID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPayment = `-- name: CreatePayment :one
INSERT INTO payments (
  payer_id, payee_id, payment_type, related_entity_type, related_entity_id,
  amount, currency, payment_method, payment_reference, gateway_reference
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
) RETURNING id, payer_id, payee_id, payment_type, related_entity_type, related_entity_id, amount, currency, payment_method, payment_reference, gateway_reference, status, gateway_response, processed_at, refunded_at, refund_reason, created_at, updated_at
`

type CreatePaymentParams struct {
	PayerID           int64                 `json:"payer_id"`
	PayeeID           pgtype.Int8           `json:"payee_id"`
	PaymentType       PaymentTypeEnum       `json:"payment_type"`
	RelatedEntityType NullRelatedEntityEnum `json:"related_entity_type"`
	RelatedEntityID   pgtype.Int8           `json:"related_entity_id"`
	Amount            pgtype.Numeric        `json:"amount"`
	Currency          pgtype.Text           `json:"currency"`
	PaymentMethod     PaymentMethodEnum     `json:"payment_method"`
	PaymentReference  string                `json:"payment_reference"`
	GatewayReference  pgtype.Text           `json:"gateway_reference"`
}

// Create payment
func (q *Queries) CreatePayment(ctx context.Context, arg CreatePaymentParams) (Payment, error) {
	row := q.db.QueryRow(ctx, createPayment,
		arg.PayerID,
		arg.PayeeID,
		arg.PaymentType,
		arg.RelatedEntityType,
		arg.RelatedEntityID,
		arg.Amount,
		arg.Currency,
		arg.PaymentMethod,
		arg.PaymentReference,
		arg.GatewayReference,
	)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.PayerID,
		&i.PayeeID,
		&i.PaymentType,
		&i.RelatedEntityType,
		&i.RelatedEntityID,
		&i.Amount,
		&i.Currency,
		&i.PaymentMethod,
		&i.PaymentReference,
		&i.GatewayReference,
		&i.Status,
		&i.GatewayResponse,
		&i.ProcessedAt,
		&i.RefundedAt,
		&i.RefundReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deletePayment = `-- name: DeletePayment :exec
DELETE FROM payments 
WHERE id = $1
`

// Delete payment
func (q *Queries) DeletePayment(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deletePayment, id)
	return err
}

const failPayment = `-- name: FailPayment :one
UPDATE payments 
SET status = 'failed', gateway_response = $2, updated_at = NOW()
WHERE id = $1 
RETURNING id, payer_id, payee_id, payment_type, related_entity_type, related_entity_id, amount, currency, payment_method, payment_reference, gateway_reference, status, gateway_response, processed_at, refunded_at, refund_reason, created_at, updated_at
`

type FailPaymentParams struct {
	ID              int64       `json:"id"`
	GatewayResponse pgtype.Text `json:"gateway_response"`
}

// Fail payment
func (q *Queries) FailPayment(ctx context.Context, arg FailPaymentParams) (Payment, error) {
	row := q.db.QueryRow(ctx, failPayment, arg.ID, arg.GatewayResponse)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.PayerID,
		&i.PayeeID,
		&i.PaymentType,
		&i.RelatedEntityType,
		&i.RelatedEntityID,
		&i.Amount,
		&i.Currency,
		&i.PaymentMethod,
		&i.PaymentReference,
		&i.GatewayReference,
		&i.Status,
		&i.GatewayResponse,
		&i.ProcessedAt,
		&i.RefundedAt,
		&i.RefundReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPaymentByGatewayReference = `-- name: GetPaymentByGatewayReference :one
SELECT id, payer_id, payee_id, payment_type, related_entity_type, related_entity_id, amount, currency, payment_method, payment_reference, gateway_reference, status, gateway_response, processed_at, refunded_at, refund_reason, created_at, updated_at FROM payments 
WHERE gateway_reference = $1 LIMIT 1
`

// Get payment by gateway reference
func (q *Queries) GetPaymentByGatewayReference(ctx context.Context, gatewayReference pgtype.Text) (Payment, error) {
	row := q.db.QueryRow(ctx, getPaymentByGatewayReference, gatewayReference)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.PayerID,
		&i.PayeeID,
		&i.PaymentType,
		&i.RelatedEntityType,
		&i.RelatedEntityID,
		&i.Amount,
		&i.Currency,
		&i.PaymentMethod,
		&i.PaymentReference,
		&i.GatewayReference,
		&i.Status,
		&i.GatewayResponse,
		&i.ProcessedAt,
		&i.RefundedAt,
		&i.RefundReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPaymentByID = `-- name: GetPaymentByID :one
SELECT id, payer_id, payee_id, payment_type, related_entity_type, related_entity_id, amount, currency, payment_method, payment_reference, gateway_reference, status, gateway_response, processed_at, refunded_at, refund_reason, created_at, updated_at FROM payments 
WHERE id = $1 LIMIT 1
`

// Get payment by ID
func (q *Queries) GetPaymentByID(ctx context.Context, id int64) (Payment, error) {
	row := q.db.QueryRow(ctx, getPaymentByID, id)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.PayerID,
		&i.PayeeID,
		&i.PaymentType,
		&i.RelatedEntityType,
		&i.RelatedEntityID,
		&i.Amount,
		&i.Currency,
		&i.PaymentMethod,
		&i.PaymentReference,
		&i.GatewayReference,
		&i.Status,
		&i.GatewayResponse,
		&i.ProcessedAt,
		&i.RefundedAt,
		&i.RefundReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPaymentByReference = `-- name: GetPaymentByReference :one
SELECT id, payer_id, payee_id, payment_type, related_entity_type, related_entity_id, amount, currency, payment_method, payment_reference, gateway_reference, status, gateway_response, processed_at, refunded_at, refund_reason, created_at, updated_at FROM payments 
WHERE payment_reference = $1 LIMIT 1
`

// Get payment by reference
func (q *Queries) GetPaymentByReference(ctx context.Context, paymentReference string) (Payment, error) {
	row := q.db.QueryRow(ctx, getPaymentByReference, paymentReference)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.PayerID,
		&i.PayeeID,
		&i.PaymentType,
		&i.RelatedEntityType,
		&i.RelatedEntityID,
		&i.Amount,
		&i.Currency,
		&i.PaymentMethod,
		&i.PaymentReference,
		&i.GatewayReference,
		&i.Status,
		&i.GatewayResponse,
		&i.ProcessedAt,
		&i.RefundedAt,
		&i.RefundReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPaymentStatistics = `-- name: GetPaymentStatistics :one
SELECT 
  COUNT(*) as total_payments,
  COUNT(CASE WHEN status = 'completed' THEN 1 END) as completed_payments,
  COUNT(CASE WHEN status = 'pending' THEN 1 END) as pending_payments,
  COUNT(CASE WHEN status = 'failed' THEN 1 END) as failed_payments,
  SUM(CASE WHEN status = 'completed' THEN amount ELSE 0 END) as total_revenue,
  AVG(CASE WHEN status = 'completed' THEN amount ELSE NULL END) as average_payment
FROM payments
`

type GetPaymentStatisticsRow struct {
	TotalPayments     int64   `json:"total_payments"`
	CompletedPayments int64   `json:"completed_payments"`
	PendingPayments   int64   `json:"pending_payments"`
	FailedPayments    int64   `json:"failed_payments"`
	TotalRevenue      int64   `json:"total_revenue"`
	AveragePayment    float64 `json:"average_payment"`
}

// Get payment statistics
func (q *Queries) GetPaymentStatistics(ctx context.Context) (GetPaymentStatisticsRow, error) {
	row := q.db.QueryRow(ctx, getPaymentStatistics)
	var i GetPaymentStatisticsRow
	err := row.Scan(
		&i.TotalPayments,
		&i.CompletedPayments,
		&i.PendingPayments,
		&i.FailedPayments,
		&i.TotalRevenue,
		&i.AveragePayment,
	)
	return i, err
}

const getPaymentWithDetails = `-- name: GetPaymentWithDetails :one
SELECT p.id, p.payer_id, p.payee_id, p.payment_type, p.related_entity_type, p.related_entity_id, p.amount, p.currency, p.payment_method, p.payment_reference, p.gateway_reference, p.status, p.gateway_response, p.processed_at, p.refunded_at, p.refund_reason, p.created_at, p.updated_at, 
       payer.first_name as payer_first_name, payer.last_name as payer_last_name, payer.email as payer_email,
       payee.first_name as payee_first_name, payee.last_name as payee_last_name, payee.email as payee_email
FROM payments p
JOIN users payer ON p.payer_id = payer.id
LEFT JOIN users payee ON p.payee_id = payee.id
WHERE p.id = $1 LIMIT 1
`

type GetPaymentWithDetailsRow struct {
	ID                int64                     `json:"id"`
	PayerID           int64                     `json:"payer_id"`
	PayeeID           pgtype.Int8               `json:"payee_id"`
	PaymentType       PaymentTypeEnum           `json:"payment_type"`
	RelatedEntityType NullRelatedEntityEnum     `json:"related_entity_type"`
	RelatedEntityID   pgtype.Int8               `json:"related_entity_id"`
	Amount            pgtype.Numeric            `json:"amount"`
	Currency          pgtype.Text               `json:"currency"`
	PaymentMethod     PaymentMethodEnum         `json:"payment_method"`
	PaymentReference  string                    `json:"payment_reference"`
	GatewayReference  pgtype.Text               `json:"gateway_reference"`
	Status            NullPaymentStatusFullEnum `json:"status"`
	GatewayResponse   pgtype.Text               `json:"gateway_response"`
	ProcessedAt       pgtype.Timestamptz        `json:"processed_at"`
	RefundedAt        pgtype.Timestamptz        `json:"refunded_at"`
	RefundReason      pgtype.Text               `json:"refund_reason"`
	CreatedAt         pgtype.Timestamptz        `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz        `json:"updated_at"`
	PayerFirstName    string                    `json:"payer_first_name"`
	PayerLastName     string                    `json:"payer_last_name"`
	PayerEmail        string                    `json:"payer_email"`
	PayeeFirstName    pgtype.Text               `json:"payee_first_name"`
	PayeeLastName     pgtype.Text               `json:"payee_last_name"`
	PayeeEmail        pgtype.Text               `json:"payee_email"`
}

// Get payment with details
func (q *Queries) GetPaymentWithDetails(ctx context.Context, id int64) (GetPaymentWithDetailsRow, error) {
	row := q.db.QueryRow(ctx, getPaymentWithDetails, id)
	var i GetPaymentWithDetailsRow
	err := row.Scan(
		&i.ID,
		&i.PayerID,
		&i.PayeeID,
		&i.PaymentType,
		&i.RelatedEntityType,
		&i.RelatedEntityID,
		&i.Amount,
		&i.Currency,
		&i.PaymentMethod,
		&i.PaymentReference,
		&i.GatewayReference,
		&i.Status,
		&i.GatewayResponse,
		&i.ProcessedAt,
		&i.RefundedAt,
		&i.RefundReason,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PayerFirstName,
		&i.PayerLastName,
		&i.PayerEmail,
		&i.PayeeFirstName,
		&i.PayeeLastName,
		&i.PayeeEmail,
	)
	return i, err
}

const getPaymentsByDateRange = `-- name: GetPaymentsByDateRange :many
SELECT p.id, p.payer_id, p.payee_id, p.payment_type, p.related_entity_type, p.related_entity_id, p.amount, p.currency, p.payment_method, p.payment_reference, p.gateway_reference, p.status, p.gateway_response, p.processed_at, p.refunded_at, p.refund_reason, p.created_at, p.updated_at, 
       payer.first_name as payer_first_name, payer.last_name as payer_last_name,
       payee.first_name as payee_first_name, payee.last_name as payee_last_name
FROM payments p
JOIN users payer ON p.payer_id = payer.id
LEFT JOIN users payee ON p.payee_id = payee.id
WHERE p.created_at BETWEEN $1 AND $2
ORDER BY p.created_at DESC
LIMIT $3 OFFSET $4
`

type GetPaymentsByDateRangeParams struct {
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	CreatedAt_2 pgtype.Timestamptz `json:"created_at_2"`
	Limit       int32              `json:"limit"`
	Offset      int32              `json:"offset"`
}

type GetPaymentsByDateRangeRow struct {
	ID                int64                     `json:"id"`
	PayerID           int64                     `json:"payer_id"`
	PayeeID           pgtype.Int8               `json:"payee_id"`
	PaymentType       PaymentTypeEnum           `json:"payment_type"`
	RelatedEntityType NullRelatedEntityEnum     `json:"related_entity_type"`
	RelatedEntityID   pgtype.Int8               `json:"related_entity_id"`
	Amount            pgtype.Numeric            `json:"amount"`
	Currency          pgtype.Text               `json:"currency"`
	PaymentMethod     PaymentMethodEnum         `json:"payment_method"`
	PaymentReference  string                    `json:"payment_reference"`
	GatewayReference  pgtype.Text               `json:"gateway_reference"`
	Status            NullPaymentStatusFullEnum `json:"status"`
	GatewayResponse   pgtype.Text               `json:"gateway_response"`
	ProcessedAt       pgtype.Timestamptz        `json:"processed_at"`
	RefundedAt        pgtype.Timestamptz        `json:"refunded_at"`
	RefundReason      pgtype.Text               `json:"refund_reason"`
	CreatedAt         pgtype.Timestamptz        `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz        `json:"updated_at"`
	PayerFirstName    string                    `json:"payer_first_name"`
	PayerLastName     string                    `json:"payer_last_name"`
	PayeeFirstName    pgtype.Text               `json:"payee_first_name"`
	PayeeLastName     pgtype.Text               `json:"payee_last_name"`
}

// Get payments by date range
func (q *Queries) GetPaymentsByDateRange(ctx context.Context, arg GetPaymentsByDateRangeParams) ([]GetPaymentsByDateRangeRow, error) {
	rows, err := q.db.Query(ctx, getPaymentsByDateRange,
		arg.CreatedAt,
		arg.CreatedAt_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPaymentsByDateRangeRow{}
	for rows.Next() {
		var i GetPaymentsByDateRangeRow
		if err := rows.Scan(
			&i.ID,
			&i.PayerID,
			&i.PayeeID,
			&i.PaymentType,
			&i.RelatedEntityType,
			&i.RelatedEntityID,
			&i.Amount,
			&i.Currency,
			&i.PaymentMethod,
			&i.PaymentReference,
			&i.GatewayReference,
			&i.Status,
			&i.GatewayResponse,
			&i.ProcessedAt,
			&i.RefundedAt,
			&i.RefundReason,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PayerFirstName,
			&i.PayerLastName,
			&i.PayeeFirstName,
			&i.PayeeLastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaymentsByEntity = `-- name: GetPaymentsByEntity :many
SELECT p.id, p.payer_id, p.payee_id, p.payment_type, p.related_entity_type, p.related_entity_id, p.amount, p.currency, p.payment_method, p.payment_reference, p.gateway_reference, p.status, p.gateway_response, p.processed_at, p.refunded_at, p.refund_reason, p.created_at, p.updated_at, 
       payer.first_name as payer_first_name, payer.last_name as payer_last_name,
       payee.first_name as payee_first_name, payee.last_name as payee_last_name
FROM payments p
JOIN users payer ON p.payer_id = payer.id
LEFT JOIN users payee ON p.payee_id = payee.id
WHERE p.related_entity_type = $1 AND p.related_entity_id = $2
ORDER BY p.created_at DESC
LIMIT $3 OFFSET $4
`

type GetPaymentsByEntityParams struct {
	RelatedEntityType NullRelatedEntityEnum `json:"related_entity_type"`
	RelatedEntityID   pgtype.Int8           `json:"related_entity_id"`
	Limit             int32                 `json:"limit"`
	Offset            int32                 `json:"offset"`
}

type GetPaymentsByEntityRow struct {
	ID                int64                     `json:"id"`
	PayerID           int64                     `json:"payer_id"`
	PayeeID           pgtype.Int8               `json:"payee_id"`
	PaymentType       PaymentTypeEnum           `json:"payment_type"`
	RelatedEntityType NullRelatedEntityEnum     `json:"related_entity_type"`
	RelatedEntityID   pgtype.Int8               `json:"related_entity_id"`
	Amount            pgtype.Numeric            `json:"amount"`
	Currency          pgtype.Text               `json:"currency"`
	PaymentMethod     PaymentMethodEnum         `json:"payment_method"`
	PaymentReference  string                    `json:"payment_reference"`
	GatewayReference  pgtype.Text               `json:"gateway_reference"`
	Status            NullPaymentStatusFullEnum `json:"status"`
	GatewayResponse   pgtype.Text               `json:"gateway_response"`
	ProcessedAt       pgtype.Timestamptz        `json:"processed_at"`
	RefundedAt        pgtype.Timestamptz        `json:"refunded_at"`
	RefundReason      pgtype.Text               `json:"refund_reason"`
	CreatedAt         pgtype.Timestamptz        `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz        `json:"updated_at"`
	PayerFirstName    string                    `json:"payer_first_name"`
	PayerLastName     string                    `json:"payer_last_name"`
	PayeeFirstName    pgtype.Text               `json:"payee_first_name"`
	PayeeLastName     pgtype.Text               `json:"payee_last_name"`
}

// Get payments by entity
func (q *Queries) GetPaymentsByEntity(ctx context.Context, arg GetPaymentsByEntityParams) ([]GetPaymentsByEntityRow, error) {
	rows, err := q.db.Query(ctx, getPaymentsByEntity,
		arg.RelatedEntityType,
		arg.RelatedEntityID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPaymentsByEntityRow{}
	for rows.Next() {
		var i GetPaymentsByEntityRow
		if err := rows.Scan(
			&i.ID,
			&i.PayerID,
			&i.PayeeID,
			&i.PaymentType,
			&i.RelatedEntityType,
			&i.RelatedEntityID,
			&i.Amount,
			&i.Currency,
			&i.PaymentMethod,
			&i.PaymentReference,
			&i.GatewayReference,
			&i.Status,
			&i.GatewayResponse,
			&i.ProcessedAt,
			&i.RefundedAt,
			&i.RefundReason,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PayerFirstName,
			&i.PayerLastName,
			&i.PayeeFirstName,
			&i.PayeeLastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaymentsByStatus = `-- name: GetPaymentsByStatus :many
SELECT p.id, p.payer_id, p.payee_id, p.payment_type, p.related_entity_type, p.related_entity_id, p.amount, p.currency, p.payment_method, p.payment_reference, p.gateway_reference, p.status, p.gateway_response, p.processed_at, p.refunded_at, p.refund_reason, p.created_at, p.updated_at, 
       payer.first_name as payer_first_name, payer.last_name as payer_last_name,
       payee.first_name as payee_first_name, payee.last_name as payee_last_name
FROM payments p
JOIN users payer ON p.payer_id = payer.id
LEFT JOIN users payee ON p.payee_id = payee.id
WHERE p.status = $1
ORDER BY p.created_at DESC
LIMIT $2 OFFSET $3
`

type GetPaymentsByStatusParams struct {
	Status NullPaymentStatusFullEnum `json:"status"`
	Limit  int32                     `json:"limit"`
	Offset int32                     `json:"offset"`
}

type GetPaymentsByStatusRow struct {
	ID                int64                     `json:"id"`
	PayerID           int64                     `json:"payer_id"`
	PayeeID           pgtype.Int8               `json:"payee_id"`
	PaymentType       PaymentTypeEnum           `json:"payment_type"`
	RelatedEntityType NullRelatedEntityEnum     `json:"related_entity_type"`
	RelatedEntityID   pgtype.Int8               `json:"related_entity_id"`
	Amount            pgtype.Numeric            `json:"amount"`
	Currency          pgtype.Text               `json:"currency"`
	PaymentMethod     PaymentMethodEnum         `json:"payment_method"`
	PaymentReference  string                    `json:"payment_reference"`
	GatewayReference  pgtype.Text               `json:"gateway_reference"`
	Status            NullPaymentStatusFullEnum `json:"status"`
	GatewayResponse   pgtype.Text               `json:"gateway_response"`
	ProcessedAt       pgtype.Timestamptz        `json:"processed_at"`
	RefundedAt        pgtype.Timestamptz        `json:"refunded_at"`
	RefundReason      pgtype.Text               `json:"refund_reason"`
	CreatedAt         pgtype.Timestamptz        `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz        `json:"updated_at"`
	PayerFirstName    string                    `json:"payer_first_name"`
	PayerLastName     string                    `json:"payer_last_name"`
	PayeeFirstName    pgtype.Text               `json:"payee_first_name"`
	PayeeLastName     pgtype.Text               `json:"payee_last_name"`
}

// Get payments by status
func (q *Queries) GetPaymentsByStatus(ctx context.Context, arg GetPaymentsByStatusParams) ([]GetPaymentsByStatusRow, error) {
	rows, err := q.db.Query(ctx, getPaymentsByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPaymentsByStatusRow{}
	for rows.Next() {
		var i GetPaymentsByStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.PayerID,
			&i.PayeeID,
			&i.PaymentType,
			&i.RelatedEntityType,
			&i.RelatedEntityID,
			&i.Amount,
			&i.Currency,
			&i.PaymentMethod,
			&i.PaymentReference,
			&i.GatewayReference,
			&i.Status,
			&i.GatewayResponse,
			&i.ProcessedAt,
			&i.RefundedAt,
			&i.RefundReason,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PayerFirstName,
			&i.PayerLastName,
			&i.PayeeFirstName,
			&i.PayeeLastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaymentsByType = `-- name: GetPaymentsByType :many
SELECT p.id, p.payer_id, p.payee_id, p.payment_type, p.related_entity_type, p.related_entity_id, p.amount, p.currency, p.payment_method, p.payment_reference, p.gateway_reference, p.status, p.gateway_response, p.processed_at, p.refunded_at, p.refund_reason, p.created_at, p.updated_at, 
       payer.first_name as payer_first_name, payer.last_name as payer_last_name,
       payee.first_name as payee_first_name, payee.last_name as payee_last_name
FROM payments p
JOIN users payer ON p.payer_id = payer.id
LEFT JOIN users payee ON p.payee_id = payee.id
WHERE p.payment_type = $1
ORDER BY p.created_at DESC
LIMIT $2 OFFSET $3
`

type GetPaymentsByTypeParams struct {
	PaymentType PaymentTypeEnum `json:"payment_type"`
	Limit       int32           `json:"limit"`
	Offset      int32           `json:"offset"`
}

type GetPaymentsByTypeRow struct {
	ID                int64                     `json:"id"`
	PayerID           int64                     `json:"payer_id"`
	PayeeID           pgtype.Int8               `json:"payee_id"`
	PaymentType       PaymentTypeEnum           `json:"payment_type"`
	RelatedEntityType NullRelatedEntityEnum     `json:"related_entity_type"`
	RelatedEntityID   pgtype.Int8               `json:"related_entity_id"`
	Amount            pgtype.Numeric            `json:"amount"`
	Currency          pgtype.Text               `json:"currency"`
	PaymentMethod     PaymentMethodEnum         `json:"payment_method"`
	PaymentReference  string                    `json:"payment_reference"`
	GatewayReference  pgtype.Text               `json:"gateway_reference"`
	Status            NullPaymentStatusFullEnum `json:"status"`
	GatewayResponse   pgtype.Text               `json:"gateway_response"`
	ProcessedAt       pgtype.Timestamptz        `json:"processed_at"`
	RefundedAt        pgtype.Timestamptz        `json:"refunded_at"`
	RefundReason      pgtype.Text               `json:"refund_reason"`
	CreatedAt         pgtype.Timestamptz        `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz        `json:"updated_at"`
	PayerFirstName    string                    `json:"payer_first_name"`
	PayerLastName     string                    `json:"payer_last_name"`
	PayeeFirstName    pgtype.Text               `json:"payee_first_name"`
	PayeeLastName     pgtype.Text               `json:"payee_last_name"`
}

// Get payments by type
func (q *Queries) GetPaymentsByType(ctx context.Context, arg GetPaymentsByTypeParams) ([]GetPaymentsByTypeRow, error) {
	rows, err := q.db.Query(ctx, getPaymentsByType, arg.PaymentType, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPaymentsByTypeRow{}
	for rows.Next() {
		var i GetPaymentsByTypeRow
		if err := rows.Scan(
			&i.ID,
			&i.PayerID,
			&i.PayeeID,
			&i.PaymentType,
			&i.RelatedEntityType,
			&i.RelatedEntityID,
			&i.Amount,
			&i.Currency,
			&i.PaymentMethod,
			&i.PaymentReference,
			&i.GatewayReference,
			&i.Status,
			&i.GatewayResponse,
			&i.ProcessedAt,
			&i.RefundedAt,
			&i.RefundReason,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PayerFirstName,
			&i.PayerLastName,
			&i.PayeeFirstName,
			&i.PayeeLastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingPayments = `-- name: GetPendingPayments :many
SELECT p.id, p.payer_id, p.payee_id, p.payment_type, p.related_entity_type, p.related_entity_id, p.amount, p.currency, p.payment_method, p.payment_reference, p.gateway_reference, p.status, p.gateway_response, p.processed_at, p.refunded_at, p.refund_reason, p.created_at, p.updated_at, 
       payer.first_name as payer_first_name, payer.last_name as payer_last_name, payer.email as payer_email
FROM payments p
JOIN users payer ON p.payer_id = payer.id
WHERE p.status = 'pending'
ORDER BY p.created_at ASC
LIMIT $1 OFFSET $2
`

type GetPendingPaymentsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetPendingPaymentsRow struct {
	ID                int64                     `json:"id"`
	PayerID           int64                     `json:"payer_id"`
	PayeeID           pgtype.Int8               `json:"payee_id"`
	PaymentType       PaymentTypeEnum           `json:"payment_type"`
	RelatedEntityType NullRelatedEntityEnum     `json:"related_entity_type"`
	RelatedEntityID   pgtype.Int8               `json:"related_entity_id"`
	Amount            pgtype.Numeric            `json:"amount"`
	Currency          pgtype.Text               `json:"currency"`
	PaymentMethod     PaymentMethodEnum         `json:"payment_method"`
	PaymentReference  string                    `json:"payment_reference"`
	GatewayReference  pgtype.Text               `json:"gateway_reference"`
	Status            NullPaymentStatusFullEnum `json:"status"`
	GatewayResponse   pgtype.Text               `json:"gateway_response"`
	ProcessedAt       pgtype.Timestamptz        `json:"processed_at"`
	RefundedAt        pgtype.Timestamptz        `json:"refunded_at"`
	RefundReason      pgtype.Text               `json:"refund_reason"`
	CreatedAt         pgtype.Timestamptz        `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz        `json:"updated_at"`
	PayerFirstName    string                    `json:"payer_first_name"`
	PayerLastName     string                    `json:"payer_last_name"`
	PayerEmail        string                    `json:"payer_email"`
}

// Get pending payments
func (q *Queries) GetPendingPayments(ctx context.Context, arg GetPendingPaymentsParams) ([]GetPendingPaymentsRow, error) {
	rows, err := q.db.Query(ctx, getPendingPayments, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPendingPaymentsRow{}
	for rows.Next() {
		var i GetPendingPaymentsRow
		if err := rows.Scan(
			&i.ID,
			&i.PayerID,
			&i.PayeeID,
			&i.PaymentType,
			&i.RelatedEntityType,
			&i.RelatedEntityID,
			&i.Amount,
			&i.Currency,
			&i.PaymentMethod,
			&i.PaymentReference,
			&i.GatewayReference,
			&i.Status,
			&i.GatewayResponse,
			&i.ProcessedAt,
			&i.RefundedAt,
			&i.RefundReason,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PayerFirstName,
			&i.PayerLastName,
			&i.PayerEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserEarningSummary = `-- name: GetUserEarningSummary :one
SELECT 
  COUNT(*) as total_earnings,
  SUM(CASE WHEN status = 'completed' THEN amount ELSE 0 END) as total_earned,
  COUNT(CASE WHEN status = 'completed' THEN 1 END) as successful_earnings,
  COUNT(CASE WHEN status = 'refunded' THEN 1 END) as refunded_payments
FROM payments 
WHERE payee_id = $1
`

type GetUserEarningSummaryRow struct {
	TotalEarnings      int64 `json:"total_earnings"`
	TotalEarned        int64 `json:"total_earned"`
	SuccessfulEarnings int64 `json:"successful_earnings"`
	RefundedPayments   int64 `json:"refunded_payments"`
}

// Get user earning summary
func (q *Queries) GetUserEarningSummary(ctx context.Context, payeeID pgtype.Int8) (GetUserEarningSummaryRow, error) {
	row := q.db.QueryRow(ctx, getUserEarningSummary, payeeID)
	var i GetUserEarningSummaryRow
	err := row.Scan(
		&i.TotalEarnings,
		&i.TotalEarned,
		&i.SuccessfulEarnings,
		&i.RefundedPayments,
	)
	return i, err
}

const getUserEarnings = `-- name: GetUserEarnings :many
SELECT p.id, p.payer_id, p.payee_id, p.payment_type, p.related_entity_type, p.related_entity_id, p.amount, p.currency, p.payment_method, p.payment_reference, p.gateway_reference, p.status, p.gateway_response, p.processed_at, p.refunded_at, p.refund_reason, p.created_at, p.updated_at, payer.first_name as payer_first_name, payer.last_name as payer_last_name
FROM payments p
JOIN users payer ON p.payer_id = payer.id
WHERE p.payee_id = $1
ORDER BY p.created_at DESC
LIMIT $2 OFFSET $3
`

type GetUserEarningsParams struct {
	PayeeID pgtype.Int8 `json:"payee_id"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

type GetUserEarningsRow struct {
	ID                int64                     `json:"id"`
	PayerID           int64                     `json:"payer_id"`
	PayeeID           pgtype.Int8               `json:"payee_id"`
	PaymentType       PaymentTypeEnum           `json:"payment_type"`
	RelatedEntityType NullRelatedEntityEnum     `json:"related_entity_type"`
	RelatedEntityID   pgtype.Int8               `json:"related_entity_id"`
	Amount            pgtype.Numeric            `json:"amount"`
	Currency          pgtype.Text               `json:"currency"`
	PaymentMethod     PaymentMethodEnum         `json:"payment_method"`
	PaymentReference  string                    `json:"payment_reference"`
	GatewayReference  pgtype.Text               `json:"gateway_reference"`
	Status            NullPaymentStatusFullEnum `json:"status"`
	GatewayResponse   pgtype.Text               `json:"gateway_response"`
	ProcessedAt       pgtype.Timestamptz        `json:"processed_at"`
	RefundedAt        pgtype.Timestamptz        `json:"refunded_at"`
	RefundReason      pgtype.Text               `json:"refund_reason"`
	CreatedAt         pgtype.Timestamptz        `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz        `json:"updated_at"`
	PayerFirstName    string                    `json:"payer_first_name"`
	PayerLastName     string                    `json:"payer_last_name"`
}

// Get user earnings (as payee)
func (q *Queries) GetUserEarnings(ctx context.Context, arg GetUserEarningsParams) ([]GetUserEarningsRow, error) {
	rows, err := q.db.Query(ctx, getUserEarnings, arg.PayeeID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserEarningsRow{}
	for rows.Next() {
		var i GetUserEarningsRow
		if err := rows.Scan(
			&i.ID,
			&i.PayerID,
			&i.PayeeID,
			&i.PaymentType,
			&i.RelatedEntityType,
			&i.RelatedEntityID,
			&i.Amount,
			&i.Currency,
			&i.PaymentMethod,
			&i.PaymentReference,
			&i.GatewayReference,
			&i.Status,
			&i.GatewayResponse,
			&i.ProcessedAt,
			&i.RefundedAt,
			&i.RefundReason,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PayerFirstName,
			&i.PayerLastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserPaymentSummary = `-- name: GetUserPaymentSummary :one
SELECT 
  COUNT(*) as total_payments,
  SUM(CASE WHEN status = 'completed' THEN amount ELSE 0 END) as total_spent,
  COUNT(CASE WHEN status = 'completed' THEN 1 END) as successful_payments,
  COUNT(CASE WHEN status = 'failed' THEN 1 END) as failed_payments
FROM payments 
WHERE payer_id = $1
`

type GetUserPaymentSummaryRow struct {
	TotalPayments      int64 `json:"total_payments"`
	TotalSpent         int64 `json:"total_spent"`
	SuccessfulPayments int64 `json:"successful_payments"`
	FailedPayments     int64 `json:"failed_payments"`
}

// Get user payment summary
func (q *Queries) GetUserPaymentSummary(ctx context.Context, payerID int64) (GetUserPaymentSummaryRow, error) {
	row := q.db.QueryRow(ctx, getUserPaymentSummary, payerID)
	var i GetUserPaymentSummaryRow
	err := row.Scan(
		&i.TotalPayments,
		&i.TotalSpent,
		&i.SuccessfulPayments,
		&i.FailedPayments,
	)
	return i, err
}

const getUserPayments = `-- name: GetUserPayments :many
SELECT p.id, p.payer_id, p.payee_id, p.payment_type, p.related_entity_type, p.related_entity_id, p.amount, p.currency, p.payment_method, p.payment_reference, p.gateway_reference, p.status, p.gateway_response, p.processed_at, p.refunded_at, p.refund_reason, p.created_at, p.updated_at, payee.first_name as payee_first_name, payee.last_name as payee_last_name
FROM payments p
LEFT JOIN users payee ON p.payee_id = payee.id
WHERE p.payer_id = $1
ORDER BY p.created_at DESC
LIMIT $2 OFFSET $3
`

type GetUserPaymentsParams struct {
	PayerID int64 `json:"payer_id"`
	Limit   int32 `json:"limit"`
	Offset  int32 `json:"offset"`
}

type GetUserPaymentsRow struct {
	ID                int64                     `json:"id"`
	PayerID           int64                     `json:"payer_id"`
	PayeeID           pgtype.Int8               `json:"payee_id"`
	PaymentType       PaymentTypeEnum           `json:"payment_type"`
	RelatedEntityType NullRelatedEntityEnum     `json:"related_entity_type"`
	RelatedEntityID   pgtype.Int8               `json:"related_entity_id"`
	Amount            pgtype.Numeric            `json:"amount"`
	Currency          pgtype.Text               `json:"currency"`
	PaymentMethod     PaymentMethodEnum         `json:"payment_method"`
	PaymentReference  string                    `json:"payment_reference"`
	GatewayReference  pgtype.Text               `json:"gateway_reference"`
	Status            NullPaymentStatusFullEnum `json:"status"`
	GatewayResponse   pgtype.Text               `json:"gateway_response"`
	ProcessedAt       pgtype.Timestamptz        `json:"processed_at"`
	RefundedAt        pgtype.Timestamptz        `json:"refunded_at"`
	RefundReason      pgtype.Text               `json:"refund_reason"`
	CreatedAt         pgtype.Timestamptz        `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz        `json:"updated_at"`
	PayeeFirstName    pgtype.Text               `json:"payee_first_name"`
	PayeeLastName     pgtype.Text               `json:"payee_last_name"`
}

// Get user payments (as payer)
func (q *Queries) GetUserPayments(ctx context.Context, arg GetUserPaymentsParams) ([]GetUserPaymentsRow, error) {
	rows, err := q.db.Query(ctx, getUserPayments, arg.PayerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserPaymentsRow{}
	for rows.Next() {
		var i GetUserPaymentsRow
		if err := rows.Scan(
			&i.ID,
			&i.PayerID,
			&i.PayeeID,
			&i.PaymentType,
			&i.RelatedEntityType,
			&i.RelatedEntityID,
			&i.Amount,
			&i.Currency,
			&i.PaymentMethod,
			&i.PaymentReference,
			&i.GatewayReference,
			&i.Status,
			&i.GatewayResponse,
			&i.ProcessedAt,
			&i.RefundedAt,
			&i.RefundReason,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PayeeFirstName,
			&i.PayeeLastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const processPayment = `-- name: ProcessPayment :one
UPDATE payments 
SET status = 'completed', processed_at = NOW(), gateway_response = $2, updated_at = NOW()
WHERE id = $1 
RETURNING id, payer_id, payee_id, payment_type, related_entity_type, related_entity_id, amount, currency, payment_method, payment_reference, gateway_reference, status, gateway_response, processed_at, refunded_at, refund_reason, created_at, updated_at
`

type ProcessPaymentParams struct {
	ID              int64       `json:"id"`
	GatewayResponse pgtype.Text `json:"gateway_response"`
}

// Process payment
func (q *Queries) ProcessPayment(ctx context.Context, arg ProcessPaymentParams) (Payment, error) {
	row := q.db.QueryRow(ctx, processPayment, arg.ID, arg.GatewayResponse)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.PayerID,
		&i.PayeeID,
		&i.PaymentType,
		&i.RelatedEntityType,
		&i.RelatedEntityID,
		&i.Amount,
		&i.Currency,
		&i.PaymentMethod,
		&i.PaymentReference,
		&i.GatewayReference,
		&i.Status,
		&i.GatewayResponse,
		&i.ProcessedAt,
		&i.RefundedAt,
		&i.RefundReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const refundPayment = `-- name: RefundPayment :one
UPDATE payments 
SET status = 'refunded', refunded_at = NOW(), refund_reason = $2, updated_at = NOW()
WHERE id = $1 
RETURNING id, payer_id, payee_id, payment_type, related_entity_type, related_entity_id, amount, currency, payment_method, payment_reference, gateway_reference, status, gateway_response, processed_at, refunded_at, refund_reason, created_at, updated_at
`

type RefundPaymentParams struct {
	ID           int64       `json:"id"`
	RefundReason pgtype.Text `json:"refund_reason"`
}

// Refund payment
func (q *Queries) RefundPayment(ctx context.Context, arg RefundPaymentParams) (Payment, error) {
	row := q.db.QueryRow(ctx, refundPayment, arg.ID, arg.RefundReason)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.PayerID,
		&i.PayeeID,
		&i.PaymentType,
		&i.RelatedEntityType,
		&i.RelatedEntityID,
		&i.Amount,
		&i.Currency,
		&i.PaymentMethod,
		&i.PaymentReference,
		&i.GatewayReference,
		&i.Status,
		&i.GatewayResponse,
		&i.ProcessedAt,
		&i.RefundedAt,
		&i.RefundReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePaymentStatus = `-- name: UpdatePaymentStatus :one
UPDATE payments 
SET status = $2, gateway_response = $3, processed_at = CASE WHEN $2 = 'completed' THEN NOW() ELSE processed_at END,
    updated_at = NOW()
WHERE id = $1 
RETURNING id, payer_id, payee_id, payment_type, related_entity_type, related_entity_id, amount, currency, payment_method, payment_reference, gateway_reference, status, gateway_response, processed_at, refunded_at, refund_reason, created_at, updated_at
`

type UpdatePaymentStatusParams struct {
	ID              int64                     `json:"id"`
	Status          NullPaymentStatusFullEnum `json:"status"`
	GatewayResponse pgtype.Text               `json:"gateway_response"`
}

// Update payment status
func (q *Queries) UpdatePaymentStatus(ctx context.Context, arg UpdatePaymentStatusParams) (Payment, error) {
	row := q.db.QueryRow(ctx, updatePaymentStatus, arg.ID, arg.Status, arg.GatewayResponse)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.PayerID,
		&i.PayeeID,
		&i.PaymentType,
		&i.RelatedEntityType,
		&i.RelatedEntityID,
		&i.Amount,
		&i.Currency,
		&i.PaymentMethod,
		&i.PaymentReference,
		&i.GatewayReference,
		&i.Status,
		&i.GatewayResponse,
		&i.ProcessedAt,
		&i.RefundedAt,
		&i.RefundReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
